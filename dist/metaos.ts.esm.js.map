{"version":3,"file":"metaos.ts.esm.js","sources":["../src/api/APIRequester.ts","../src/api/BaseAPI.ts","../src/api/AuthAPI.ts","../src/api/AuthzAPI.ts","../src/api/BankAPI.ts","../src/api/DeflationAPI.ts","../src/api/GovAPI.ts","../src/api/MintAPI.ts","../src/api/PoolIncentive.ts","../src/api/SlashingAPI.ts","../src/api/StakingAPI.ts","../src/api/SwapAPI.ts","../src/api/TendermintAPI.ts","../src/api/TokenAPI.ts","../src/api/TxAPI.ts","../src/api/WasmAPI.ts","../src/utils/crypto.ts","../src/utils/deepCopy.ts","../src/utils/encrypt.ts","../src/constants/date.ts","../src/constants/fee.ts","../src/constants/network.ts","../src/constants/number.ts","../src/constants/precision.ts","../src/constants/tick.ts","../src/utils/formatCurrencyAmount.ts","../src/utils/formatMoment.ts","../src/utils/formatPrice.ts","../src/utils/getPoolAddress.ts","../src/utils/toPercentFee.ts","../src/utils/isNumberic.ts","../src/utils/mathUtil.ts","../src/utils/parseToMap.ts","../src/utils/sort.ts","../src/utils/toPercent.ts","../src/utils/decimalNumber.ts","../src/types/wallet.ts","../src/types/index.ts","../src/core/LiquidityMath.ts","../src/core/TickMath.ts","../src/core/TransactionLooper.ts","../src/clients/APIClient.ts","../src/msgs/BaseMsg.ts","../src/proto/google/protobuf/any.ts","../src/proto/google/protobuf/timestamp.ts","../src/proto/cosmos/authz/v1beta1/authz.ts","../src/proto/cosmos/authz/v1beta1/tx.ts","../src/msgs/cosmos/AuthzMsg.ts","../src/proto/cosmos/base/v1beta1/coin.ts","../src/proto/cosmos/bank/v1beta1/bank.ts","../src/proto/cosmos/bank/v1beta1/tx.ts","../src/msgs/cosmos/BankMsg.ts","../src/proto/cosmos/crisis/v1beta1/tx.ts","../src/msgs/cosmos/CrisisMsg.ts","../src/proto/cosmos/distribution/v1beta1/tx.ts","../src/msgs/cosmos/DistributionMsg.ts","../src/proto/cosmos/evidence/v1beta1/tx.ts","../src/msgs/cosmos/EvidenceMsg.ts","../src/proto/cosmos/feegrant/v1beta1/tx.ts","../src/msgs/cosmos/FeeGrantMsg.ts","../src/proto/google/protobuf/duration.ts","../src/proto/cosmos/gov/v1beta1/gov.ts","../src/proto/cosmos/gov/v1beta1/tx.ts","../src/msgs/cosmos/GovMsg.ts","../src/proto/cosmos/vesting/v1beta1/tx.ts","../src/msgs/cosmos/VestingMsg.ts","../src/proto/deflation/repurchase.ts","../src/proto/deflation/tx.ts","../src/msgs/DeflationMsg.ts","../src/proto/ethermint/evm/v1/evm.ts","../src/proto/ethermint/evm/v1/tx.ts","../src/msgs/EvmMsg.ts","../src/proto/nft/tx.ts","../src/msgs/NftMsg.ts","../src/proto/pool-incentives/rand_swap_reward.ts","../src/proto/pool-incentives/liquidity_reward.ts","../src/proto/pool-incentives/tx.ts","../src/msgs/PoolMsg.ts","../src/proto/tendermint/crypto/proof.ts","../src/proto/tendermint/version/types.ts","../src/proto/tendermint/crypto/keys.ts","../src/proto/tendermint/types/validator.ts","../src/proto/tendermint/types/types.ts","../src/proto/cosmos/staking/v1beta1/staking.ts","../src/proto/cosmos/staking/v1beta1/tx.ts","../src/msgs/StakingMsg.ts","../src/proto/swap/tx.ts","../src/msgs/SwapMsg.ts","../src/proto/token/tx.ts","../src/msgs/TokenMsg.ts","../src/proto/cosmwasm/wasm/v1/types.ts","../src/proto/cosmwasm/wasm/v1/tx.ts","../src/msgs/WasmMsg.ts","../src/proto/cosmos/crypto/secp256k1/keys.ts","../src/proto/cosmos/crypto/multisig/v1beta1/multisig.ts","../src/proto/cosmos/tx/signing/v1beta1/signing.ts","../src/proto/cosmos/tx/v1beta1/tx.ts","../src/clients/TxClient.ts"],"sourcesContent":["import Axios, { AxiosInstance } from \"axios\";\nimport _ from 'lodash';\nimport { OrderBy } from \"../proto/cosmos/tx/v1beta1/service\";\nimport Long from \"long\";\n\n// export type APIParams = Record<string, string | number | null | undefined | boolean | Array<string> | Array<number> | Long>;\nexport type APIParams = Record<string, any>;\n\nexport interface PaginationOptions {\n  \"pagination.limit\"?: string;\n  \"pagination.offset\"?: string;\n  \"pagination.key\"?: string;\n  \"pagination.count_total\"?: \"true\" | \"false\";\n  \"pagination.reverse\"?: \"true\" | \"false\";\n  \"order_by\"?: keyof typeof OrderBy;\n}\n\nexport interface Pagination {\n  next_key: string | null;\n  total: number;\n}\n\nexport class APIRequester {\n  private axios: AxiosInstance;\n\n  constructor(baseURL: string) {\n    this.axios = Axios.create({\n      baseURL,\n      headers: {\n        Accept: \"application/json\",\n      },\n      timeout: 60000,\n    });\n  }\n\n  public async get<T>(\n    endpoint: string,\n    params: URLSearchParams | APIParams = {}\n  ): Promise<T> {\n    return this.axios.get(endpoint, { params }).then((d) => toCamelCase(d.data));\n  }\n\n  public async post<T>(endpoint: string, data?: APIParams): Promise<T> {\n    return this.axios.post(endpoint, data).then((d) => toCamelCase(d.data));\n  }\n}\n\nfunction toCamelCase (obj: any) {\n  let rtn = obj\n  if(!rtn) {\n    return rtn\n  } else if (typeof (obj) === 'object') {\n    if (obj instanceof Array) {\n      rtn = obj.map(toCamelCase)\n    } else {\n      rtn = {}\n      for (let key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          const newKey = key.replace(/(_\\w)/g, k => k[1].toUpperCase())\n          rtn[newKey] = toCamelCase(obj[key])\n        }\n      }\n    }\n  }\n  return rtn\n}\n","import { APIRequester } from \"./APIRequester\";\n\nexport abstract class BaseAPI {\n  constructor(protected request: APIRequester) {}\n}\n","import { BaseAPI } from \"./BaseAPI\";\n\nexport interface IResAccountInfo {\n  account: {\n    \"@type\": string;\n    base_account: {\n      address: string;\n      pub_key: {\n        \"@type\": string;\n        key: string;\n      };\n      account_number: string;\n      sequence: string;\n    };\n    code_hash: string;\n  };\n}\n\nexport class AuthAPI extends BaseAPI {\n  public async accounts(\n    accountAddress: string,\n  ): Promise<IResAccountInfo> {\n    return this.request.get<IResAccountInfo>(\n      `/cosmos/auth/v1beta1/accounts/${accountAddress}`\n    );\n  }\n}\n","import { BaseAPI } from \"./BaseAPI\";\nimport {PaginationOptions} from \"./APIRequester\";\nimport {QueryGrantsResponse} from \"../proto/cosmos/authz/v1beta1/query\";\n\nexport class AuthzAPI extends BaseAPI {\n  public async grants(\n    granter: string,\n    grantee: string,\n    msgTypeUrl?: string,\n    params?: PaginationOptions\n  ): Promise<QueryGrantsResponse> {\n    return this.request.get<QueryGrantsResponse>(\n      `/cosmos/authz/v1beta1/grants`,\n      {\n        granter,\n        grantee,\n        msg_type_url: msgTypeUrl,\n        ...params\n      }\n    );\n  }\n}\n","import { BaseAPI } from \"./BaseAPI\";\nimport { Token } from \"../types\";\nimport {PaginationOptions} from \"./APIRequester\";\nimport {Balance} from \"../proto/cosmos/bank/v1beta1/genesis\";\nimport {\n  QueryAllBalancesResponse,\n  QueryBalanceResponse,\n  QueryDenomMetadataResponse, QueryDenomsMetadataResponse,\n  QuerySupplyOfResponse,\n  QueryTotalSupplyResponse,\n} from \"../proto/cosmos/bank/v1beta1/query\";\nimport {QueryAllMetadataResponse} from \"../proto/token/query\";\n\nexport class BankAPI extends BaseAPI {\n  public async allBalances(\n    accountAddress: string,\n    params?: PaginationOptions\n  ): Promise<QueryAllBalancesResponse> {\n    return this.request.get<QueryAllBalancesResponse>(\n      `/cosmos/bank/v1beta1/balances/${accountAddress}`,\n      {\n        ...params\n      }\n    );\n  }\n\n  public async balance(\n    denom: string,\n    accountAddress: string,\n  ): Promise<QueryBalanceResponse> {\n    return this.request.get<QueryBalanceResponse>(\n      `/cosmos/bank/v1beta1/balances/${accountAddress}/by_denom`,\n      {\n        denom: denom,\n      }\n    );\n  }\n\n  public async totalSupply(params?: PaginationOptions): Promise<QueryTotalSupplyResponse> {\n    return this.request.get<QueryTotalSupplyResponse>(\n      `/cosmos/bank/v1beta1/supply`,\n      { ...params }\n    );\n  }\n\n  public async supplyOf(\n    denom: string\n  ): Promise<QuerySupplyOfResponse> {\n    return this.request.get<QuerySupplyOfResponse>(\n      `/cosmos/bank/v1beta1/supply/${denom}`\n    );\n  }\n}\n","import {BaseAPI} from \"./BaseAPI\";\nimport {PaginationOptions} from \"./APIRequester\";\nimport {QueryAllRepurchaseResponse, QueryGetRepurchaseResponse, QueryParamsResponse} from \"../proto/deflation/query\";\n\nexport class DeflationAPI extends BaseAPI {\n  public async allRepurchase(\n    params?: PaginationOptions\n  ): Promise<QueryAllRepurchaseResponse> {\n    return this.request.get<QueryAllRepurchaseResponse>(\n      `/metaos-labs/metaos/deflation/repurchases`,\n      { ...params }\n    );\n  }\n\n  public async getRepurchase(\n    denom: string,\n  ): Promise<QueryGetRepurchaseResponse> {\n    return this.request.get<QueryGetRepurchaseResponse>(\n      `/metaos-labs/metaos/deflation/repurchases/${denom}`,\n    );\n  }\n\n  public async params(): Promise<QueryParamsResponse> {\n    return this.request.get<QueryParamsResponse>(\n      `/metaos-labs/metaos/deflation/params`,\n    );\n  }\n\n}\n","import {BaseAPI} from \"./BaseAPI\";\nimport {PaginationOptions} from \"./APIRequester\";\nimport {\n  QueryDepositResponse,\n  QueryDepositsResponse,\n  QueryParamsResponse,\n  QueryProposalResponse,\n  QueryProposalsResponse,\n  QueryTallyResultResponse,\n  QueryVoteResponse,\n  QueryVotesResponse\n} from \"../proto/cosmos/gov/v1beta1/query\";\n\nexport class GovAPI extends BaseAPI {\n  public async proposals(\n    params?: PaginationOptions\n  ): Promise<QueryProposalsResponse> {\n    return this.request.get<QueryProposalsResponse>(\n      `/cosmos/gov/v1beta1/proposals`,\n      {\n        ...params\n      }\n    );\n  }\n\n  public async proposal(\n    proposalId: number,\n  ): Promise<QueryProposalResponse> {\n    return this.request.get<QueryProposalResponse>(\n      `/cosmos/gov/v1beta1/proposals/${proposalId}`\n    );\n  }\n\n  public async deposits(\n    proposalId: number,\n    params?: PaginationOptions\n  ): Promise<QueryDepositsResponse> {\n    return this.request.get<QueryDepositsResponse>(\n      `/cosmos/gov/v1beta1/proposals/${proposalId}/deposits`,\n      { ...params }\n    );\n  }\n\n  public async deposit(\n    proposalId: number,\n    depositor: string\n  ): Promise<QueryDepositResponse> {\n    return this.request.get<QueryDepositResponse>(\n      `/cosmos/gov/v1beta1/proposals/${proposalId}/deposits/${depositor}`,\n    );\n  }\n\n  public async votes(\n    proposalId: number,\n    params?: PaginationOptions\n  ): Promise<QueryVotesResponse> {\n    return this.request.get<QueryVotesResponse>(\n      `/cosmos/gov/v1beta1/proposals/${proposalId}/votes`,\n      { ...params }\n    );\n  }\n\n  public async vote(\n    proposalId: number,\n    voter: string\n  ): Promise<QueryVoteResponse> {\n    return this.request.get<QueryVoteResponse>(\n      `/cosmos/gov/v1beta1/proposals/${proposalId}/votes/${voter}`,\n    );\n  }\n\n  public async tallyResult(\n    proposalId: number,\n  ): Promise<QueryTallyResultResponse> {\n    return this.request.get<QueryTallyResultResponse>(\n      `/cosmos/gov/v1beta1/proposals/${proposalId}/tally`,\n    );\n  }\n\n  public async params(paramsType: 'voting' | 'tally' | 'deposit'): Promise<QueryParamsResponse> {\n    return this.request.get<QueryParamsResponse>(\n      `/cosmos/gov/v1beta1/params/${paramsType}`,\n    );\n  }\n\n}\n","import {BaseAPI} from \"./BaseAPI\";\nimport {\n  QueryParamsResponse,\n  QueryAnnualProvisionsResponse,\n  QueryInflationResponse\n} from \"../proto/cosmos/mint/v1beta1/query\";\n\nexport class MintAPI extends BaseAPI {\n  public async inflation(): Promise<QueryInflationResponse> {\n    return this.request.get<QueryInflationResponse>(\n      `/cosmos/mint/v1beta1/inflation`,\n    );\n  }\n\n  public async annualProvisions(): Promise<QueryAnnualProvisionsResponse> {\n    return this.request.get<QueryAnnualProvisionsResponse>(\n      `cosmos/mint/v1beta1/annual_provisions`,\n    );\n  }\n\n  public async params(): Promise<QueryParamsResponse> {\n    return this.request.get<QueryParamsResponse>(\n      `/cosmos/mint/v1beta1/params`,\n    );\n  }\n\n}\n","import {BaseAPI} from \"./BaseAPI\";\nimport {PaginationOptions} from \"./APIRequester\";\nimport {\n  QueryAllLiquidityPoolRewardResponse,\n  QueryAllLiquidityRewardConfigResponse,\n  QueryAllLiquidityRewardDenomResponse,\n  QueryAllRandSwapAccountRewardResponse,\n  QueryAllRandSwapPoolRewardResponse,\n  QueryAllRandSwapRewardConfigResponse,\n  QueryAllRandSwapRewardDenomResponse,\n  QueryAllRandSwapRewardRevealResponse,\n  QueryGetLiquidityPoolRewardResponse,\n  QueryGetLiquidityRewardConfigResponse,\n  QueryGetLiquidityRewardDenomResponse,\n  QueryGetRandSwapAccountRewardResponse,\n  QueryGetRandSwapPoolRewardResponse,\n  QueryGetRandSwapRewardConfigResponse,\n  QueryGetRandSwapRewardDenomResponse,\n  QueryParamsResponse\n} from \"../proto/pool-incentives/query\";\n\nexport class PoolIncentiveAPI extends BaseAPI {\n  public async allLiquidityPoolReward(\n    params?: PaginationOptions\n  ): Promise<QueryAllLiquidityPoolRewardResponse> {\n    return this.request.get<QueryAllLiquidityPoolRewardResponse>(\n      `/metaos-labs/metaos/pool-incentives/liquidity_pool_rewards`,\n      { ...params }\n    );\n  }\n\n  public async getLiquidityPoolReward(\n    address: string,\n  ): Promise<QueryGetLiquidityPoolRewardResponse> {\n    return this.request.get<QueryGetLiquidityPoolRewardResponse>(\n      `/metaos-labs/metaos/pool-incentives/liquidity_pool_rewards/${address}`,\n    );\n  }\n\n  public async allLiquidityRewardConfig(\n    params?: PaginationOptions\n  ): Promise<QueryAllLiquidityRewardConfigResponse> {\n    return this.request.get<QueryAllLiquidityRewardConfigResponse>(\n      `/metaos-labs/metaos/pool-incentives/liquidity_reward_configs`,\n      { ...params }\n    );\n  }\n\n  public async getLiquidityRewardConfig(\n    id: string\n  ): Promise<QueryGetLiquidityRewardConfigResponse> {\n    return this.request.get<QueryGetLiquidityRewardConfigResponse>(\n      `/metaos-labs/metaos/pool-incentives/liquidity_reward_configs/${id}`,\n    );\n  }\n\n  public async allLiquidityRewardDenomR(\n    params?: PaginationOptions\n  ): Promise<QueryAllLiquidityRewardDenomResponse> {\n    return this.request.get<QueryAllLiquidityRewardDenomResponse>(\n      `/metaos-labs/metaos/pool-incentives/liquidity_reward_denoms`,\n      { ...params }\n    );\n  }\n\n  public async getLiquidityRewardDenom(\n    denom: string\n  ): Promise<QueryGetLiquidityRewardDenomResponse> {\n    return this.request.get<QueryGetLiquidityRewardDenomResponse>(\n      `/metaos-labs/metaos/pool-incentives/liquidity_reward_denoms/by_denom`,\n      {\n        denom\n      }\n    );\n  }\n\n  public async params(): Promise<QueryParamsResponse> {\n    return this.request.get<QueryParamsResponse>(\n      `/metaos-labs/metaos/pool-incentives/params`,\n    );\n  }\n\n  public async allRandSwapAccountReward(\n    params?: PaginationOptions\n  ): Promise<QueryAllRandSwapAccountRewardResponse> {\n    return this.request.get<QueryAllRandSwapAccountRewardResponse>(\n      `/metaos-labs/metaos/pool-incentives/rand_swap_account_rewards`,\n      { ...params }\n    );\n  }\n\n  public async getRandSwapAccountReward(\n    account: string,\n    denom: string\n  ): Promise<QueryGetRandSwapAccountRewardResponse> {\n    return this.request.get<QueryGetRandSwapAccountRewardResponse>(\n      `/metaos-labs/metaos/pool-incentives/rand_swap_account_rewards/${account}/by_denom`,\n      {\n        denom\n      }\n    );\n  }\n\n  public async allRandSwapPoolReward(\n    params?: PaginationOptions\n  ): Promise<QueryAllRandSwapPoolRewardResponse> {\n    return this.request.get<QueryAllRandSwapPoolRewardResponse>(\n      `/metaos-labs/metaos/pool-incentives/rand_swap_pool_rewards`,\n      { ...params }\n    );\n  }\n\n  public async getRandSwapPoolReward(\n    address: string,\n  ): Promise<QueryGetRandSwapPoolRewardResponse> {\n    return this.request.get<QueryGetRandSwapPoolRewardResponse>(\n      `/metaos-labs/metaos/pool-incentives/rand_swap_pool_rewards/${address}`,\n    );\n  }\n\n  public async allRandSwapRewardConfig(\n    params?: PaginationOptions\n  ): Promise<QueryAllRandSwapRewardConfigResponse> {\n    return this.request.get<QueryAllRandSwapRewardConfigResponse>(\n      `/metaos-labs/metaos/pool-incentives/rand_swap_reward_configs`,\n      { ...params }\n    );\n  }\n\n  public async getRandSwapRewardConfig(\n    id: string\n  ): Promise<QueryGetRandSwapRewardConfigResponse> {\n    return this.request.get<QueryGetRandSwapRewardConfigResponse>(\n      `/metaos-labs/metaos/pool-incentives/rand_swap_reward_configs/${id}`,\n    );\n  }\n\n  public async allRandSwapRewardDenom(\n    params?: PaginationOptions\n  ): Promise<QueryAllRandSwapRewardDenomResponse> {\n    return this.request.get<QueryAllRandSwapRewardDenomResponse>(\n      `/metaos-labs/metaos/pool-incentives/rand_swap_reward_denoms`,\n      { ...params }\n    );\n  }\n\n  public async getRandSwapRewardDenom(\n    denom: string\n  ): Promise<QueryGetRandSwapRewardDenomResponse> {\n    return this.request.get<QueryGetRandSwapRewardDenomResponse>(\n      `/metaos-labs/metaos/pool-incentives/rand_swap_reward_denoms/by_denom`,\n      {\n        denom\n      }\n    );\n  }\n\n  public async allRandSwapRewardReveal(\n    params?: PaginationOptions\n  ): Promise<QueryAllRandSwapRewardRevealResponse> {\n    return this.request.get<QueryAllRandSwapRewardRevealResponse>(\n      `/metaos-labs/metaos/pool-incentives/rand_swap_reward_reveals`,\n      { ...params }\n    );\n  }\n\n  public async getRandSwapRewardReveal(\n    configId: number,\n    round: number\n  ): Promise<QueryGetRandSwapRewardDenomResponse> {\n    return this.request.get<QueryGetRandSwapRewardDenomResponse>(\n      `/metaos-labs/metaos/pool-incentives/rand_swap_reward_reveals/${configId}/${round}`\n    );\n  }\n\n}\n","import {BaseAPI} from \"./BaseAPI\";\nimport {PaginationOptions} from \"./APIRequester\";\nimport {\n  QueryParamsResponse,\n  QuerySigningInfoResponse,\n  QuerySigningInfosResponse\n} from \"../proto/cosmos/slashing/v1beta1/query\";\n\nexport class SlashingAPI extends BaseAPI {\n  public async signingInfos(\n    params?: PaginationOptions\n  ): Promise<QuerySigningInfosResponse> {\n    return this.request.get<QuerySigningInfosResponse>(\n      `/cosmos/slashing/v1beta1/signing_infos`,\n      { ...params }\n    );\n  }\n\n  public async signingInfo(\n    valConsAddress: string,\n  ): Promise<QuerySigningInfoResponse> {\n    return this.request.get<QuerySigningInfoResponse>(\n      `/cosmos/slashing/v1beta1/signing_infos/${valConsAddress}`,\n    );\n  }\n\n  public async params(): Promise<QueryParamsResponse> {\n    return this.request.get<QueryParamsResponse>(\n      `/cosmos/slashing/v1beta1/params`,\n    );\n  }\n\n}\n","import {BaseAPI} from \"./BaseAPI\";\nimport {PaginationOptions} from \"./APIRequester\";\nimport {\n  QueryDelegatorDelegationsResponse,\n  QueryDelegatorUnbondingDelegationsResponse,\n  QueryRedelegationsResponse, QueryValidatorResponse, QueryValidatorsResponse,\n  QueryParamsResponse, QueryPoolResponse, QueryDelegationResponse, QueryUnbondingDelegationResponse\n} from \"../proto/cosmos/staking/v1beta1/query\";\n\nexport class StakingAPI extends BaseAPI {\n  public async delegations(\n    delegator: string,\n    params?: PaginationOptions\n  ): Promise<QueryDelegatorDelegationsResponse> {\n    return this.request.get<QueryDelegatorDelegationsResponse>(\n      `/cosmos/staking/v1beta1/delegations/${delegator}`,\n      { ...params }\n    );\n  }\n\n  public async redelegations(\n    delegator?: string,\n    params?: PaginationOptions\n  ): Promise<QueryRedelegationsResponse> {\n    return this.request.get<QueryRedelegationsResponse>(\n      `/cosmos/staking/v1beta1/delegators/${delegator}/redelegations`,\n      { ...params }\n    );\n  }\n\n  public async unbondingDelegations(\n    delegator?: string,\n    params?: PaginationOptions\n  ): Promise<QueryDelegatorUnbondingDelegationsResponse> {\n    return this.request.get<QueryDelegatorUnbondingDelegationsResponse>(\n      `/cosmos/staking/v1beta1/delegators/${delegator}/unbonding_redelegations`,\n      { ...params }\n    );\n  }\n\n  public async delegatorDelegations(\n    delegator: string,\n    validator: string,\n    params?: PaginationOptions\n  ): Promise<QueryDelegatorDelegationsResponse> {\n    return this.request.get<QueryDelegatorDelegationsResponse>(\n      `/cosmos/staking/v1beta1/delegations/${validator}`,\n      { ...params }\n    );\n  }\n\n  public async delegationsByDelegator(\n    delegator: string,\n    params?: PaginationOptions\n  ): Promise<QueryValidatorsResponse> {\n    return this.request.get<QueryValidatorsResponse>(\n      `/cosmos/staking/v1beta1/delegators/${delegator}/validators`,\n      { ...params }\n    );\n  }\n\n  public async delegationsByDelegatorValidator(\n    delegator: string,\n    validator: string,\n    params?: PaginationOptions\n  ): Promise<QueryValidatorsResponse> {\n    return this.request.get<QueryValidatorsResponse>(\n      `/cosmos/staking/v1beta1/delegators/${delegator}/validators/${validator}`,\n      { ...params }\n    );\n  }\n\n  public async validators(\n    params?: PaginationOptions\n  ): Promise<QueryValidatorsResponse> {\n    return this.request.get<QueryValidatorsResponse>(\n      `/cosmos/staking/v1beta1/validators`,\n      { ...params }\n    );\n  }\n\n  public async validatorsByValidator(\n    validator: string\n  ): Promise<QueryValidatorResponse> {\n    return this.request.get<QueryValidatorResponse>(\n      `/cosmos/staking/v1beta1/validators/${validator}`,\n    );\n  }\n\n  public async validatorsDelegationsByValidator(\n    validator: string\n  ): Promise<QueryDelegatorDelegationsResponse> {\n    return this.request.get<QueryDelegatorDelegationsResponse>(\n      `/cosmos/staking/v1beta1/validators/${validator}/delegations`,\n    );\n  }\n\n  public async validatorsDelegationsByValidatorDelegator(\n    validator: string,\n    delegator: string,\n  ): Promise<QueryDelegationResponse> {\n    return this.request.get<QueryDelegationResponse>(\n      `/cosmos/staking/v1beta1/validators/${validator}/delegations/${delegator}`,\n    );\n  }\n\n  public async validatorsUnbondingDelegationsByValidatorDelegator(\n    validator: string,\n    delegator: string,\n  ): Promise<QueryUnbondingDelegationResponse> {\n    return this.request.get<QueryUnbondingDelegationResponse>(\n      `/cosmos/staking/v1beta1/validators/${validator}/delegations/${delegator}/unbonding_delegation`,\n    );\n  }\n\n  public async validatorsUnbondingDelegations(\n    validator: string,\n  ): Promise<QueryDelegatorUnbondingDelegationsResponse> {\n    return this.request.get<QueryDelegatorUnbondingDelegationsResponse>(\n      `/cosmos/staking/v1beta1/validators/${validator}/unbonding_delegations`,\n    );\n  }\n\n  public async pool(): Promise<QueryPoolResponse> {\n    return this.request.get<QueryPoolResponse>(\n      `/cosmos/staking/v1beta1/pool`,\n    );\n  }\n\n  public async params(): Promise<QueryParamsResponse> {\n    return this.request.get<QueryParamsResponse>(\n      `/cosmos/staking/v1beta1/params`,\n    );\n  }\n\n}\n","import { BaseAPI } from \"./BaseAPI\";\nimport { ILiquidityPosition, IPool, IPoolPrice } from \"../types\";\nimport qs from 'qs';\nimport {\n  QueryAllCorePoolResponse,\n  QueryAllLiquidityPositionOwnerResponse,\n  QueryAllPoolFeeResponse,\n  QueryAllPoolObservationResponse,\n  QueryAllPoolPositionResponse,\n  QueryAllPoolResponse,\n  QueryAllPoolSlot0Response,\n  QueryAllPoolTickResponse,\n  QueryGetCorePoolResponse,\n  QueryGetLiquidityPositionResponse,\n  QueryGetLiquidityPositionTokenUriResponse,\n  QueryGetPoolFeeResponse,\n  QueryGetPoolObservationRequest,\n  QueryGetPoolObservationResponse,\n  QueryGetPoolPositionResponse,\n  QueryGetPoolResponse,\n  QueryGetPoolSlot0Response,\n  QueryLiquidityPositionByIdsResponse,\n  QueryParamsResponse,\n  QueryPoolSlot0AggregationResponse,\n  QueryQuoteSwapExactInRequest,\n  QueryQuoteSwapExactInResponse,\n  QueryQuoteSwapExactOutRequest,\n  QueryQuoteSwapExactOutResponse\n} from \"../proto/swap/query\";\nimport {PaginationOptions} from \"./APIRequester\";\n\nexport class SwapAPI extends BaseAPI {\n\n  public async allCorePool(\n    params?: PaginationOptions\n  ): Promise<QueryAllCorePoolResponse> {\n    return this.request.get<QueryAllCorePoolResponse>(\n      `/metaos-labs/metaos/swap/core_pools`,\n      { ...params }\n    );\n  }\n\n  public async getCorePool(address: string): Promise<QueryGetCorePoolResponse> {\n    return this.request.get<QueryGetCorePoolResponse>(\n      `/metaos-labs/metaos/swap/core_pools/${address}`\n    );\n  }\n\n  public async liquidityPositionByIds(\n    tokenIds: Array<string>\n  ): Promise<QueryLiquidityPositionByIdsResponse> {\n    const params = qs.stringify({ tokenIds }, { indices: false });\n    return this.request.get<QueryLiquidityPositionByIdsResponse>(\n      `/metaos-labs/metaos/swap/liquidity_position_by_ids?${params}`\n    );\n  }\n\n  public async liquidityPositionById(\n    tokenId: string\n  ): Promise<QueryGetLiquidityPositionResponse> {\n    return this.request.get<QueryGetLiquidityPositionResponse>(\n      `/metaos-labs/metaos/swap/liquidity_positions/${tokenId}`\n    );\n  }\n\n  public async getLiquidityPositionTokenUri(tokenId: string): Promise<QueryGetLiquidityPositionTokenUriResponse> {\n    return this.request.get<QueryGetLiquidityPositionTokenUriResponse>(\n      `/metaos-labs/metaos/swap/liquidity_positions/${tokenId}/token_uri`\n    );\n  }\n\n  public async allLiquidityPositionOwner(\n    accountAddress: string,\n    skip_zero_liquidity: boolean\n  ): Promise<QueryAllLiquidityPositionOwnerResponse> {\n    return this.request.get<QueryAllLiquidityPositionOwnerResponse>(\n      `/metaos-labs/metaos/swap/liquidity_positions_owner/${accountAddress}`,\n      {\n        skip_zero_liquidity\n      }\n    );\n  }\n\n  public async params(): Promise<QueryParamsResponse> {\n    return this.request.get<QueryParamsResponse>(\n      `/metaos-labs/metaos/swap/params`,\n    );\n  }\n\n  public async allPoolFee(\n    params?: PaginationOptions\n  ): Promise<QueryAllPoolFeeResponse> {\n    return this.request.get<QueryAllPoolFeeResponse>(\n      `/metaos-labs/metaos/swap/pool/fees`,\n      {...params}\n    );\n  }\n\n  public async getPoolFee(\n    fee: number\n  ): Promise<QueryGetPoolFeeResponse> {\n    return this.request.get<QueryGetPoolFeeResponse>(\n      `/metaos-labs/metaos/swap/pool/fees/${fee}`,\n    );\n  }\n\n  public async allPoolObservation(\n    params?: PaginationOptions\n  ): Promise<QueryAllPoolObservationResponse> {\n    return this.request.get<QueryAllPoolObservationResponse>(\n      `/metaos-labs/metaos/swap/pool_observations`,\n      {...params}\n    );\n  }\n\n  public async allPoolPosition(\n    address: string,\n    owner: string,\n    params?: PaginationOptions\n  ): Promise<QueryAllPoolPositionResponse> {\n    return this.request.get<QueryAllPoolPositionResponse>(\n      `/metaos-labs/metaos/swap/pool_positions`,\n      {address, owner, ...params}\n    );\n  }\n\n  /**\n   * find pool list by address array\n   * @param addresses\n   */\n  public async poolSlot0Aggregation(\n    addresses: Array<string>\n  ): Promise<QueryPoolSlot0AggregationResponse> {\n    const params = qs.stringify({ addresses }, { indices: false });\n    return this.request.get<QueryPoolSlot0AggregationResponse>(\n      `/metaos-labs/metaos/swap/pool_slot0_aggregations?${params}`,\n    );\n  }\n\n  public async allPoolSlot0(\n    params?: PaginationOptions\n  ): Promise<QueryAllPoolSlot0Response> {\n    return this.request.get<QueryAllPoolSlot0Response>(\n      `/metaos-labs/metaos/swap/pool_slot0s`,\n      {...params}\n    );\n  }\n\n  public async allPoolTick(\n    address: string,\n    params?: PaginationOptions\n  ): Promise<QueryAllPoolTickResponse> {\n    return this.request.get<QueryAllPoolTickResponse>(\n      `/metaos-labs/metaos/swap/pool_ticks`,\n      {address, ...params}\n    );\n  }\n\n  public async allPool(\n    params?: PaginationOptions\n  ): Promise<QueryAllPoolResponse> {\n    return this.request.get<QueryAllPoolResponse>(\n      `/metaos-labs/metaos/swap/pools`,\n      {...params}\n    );\n  }\n\n  public async getPool(\n    address: string\n  ): Promise<QueryGetPoolResponse> {\n    return this.request.get<QueryGetPoolResponse>(\n      `/metaos-labs/metaos/swap/pools/${address}`\n    );\n  }\n\n  public async getPoolObservation(\n    address: string,\n    index: number\n  ): Promise<QueryGetPoolObservationResponse> {\n    return this.request.get<QueryGetPoolObservationResponse>(\n      `/metaos-labs/metaos/swap/pools/${address}/observations/${index}`\n    );\n  }\n\n  public async getPoolPosition(\n    address: string,\n    owner: string,\n    tickLower: number,\n    tickUpper: number\n  ): Promise<QueryGetPoolPositionResponse> {\n    return this.request.get<QueryGetPoolPositionResponse>(\n      `/metaos-labs/metaos/swap/pools/${address}/positions/${owner}/${tickLower}/${tickUpper}`\n    );\n  }\n\n  public async getPoolSlot0(\n    address: string\n  ): Promise<QueryGetPoolSlot0Response> {\n    return this.request.get<QueryGetPoolSlot0Response>(\n      `/metaos-labs/metaos/swap/pools/${address}/slot0`\n    );\n  }\n\n  public async quoteSwapExactIn(params: QueryQuoteSwapExactInRequest): Promise<QueryQuoteSwapExactInResponse> {\n    return this.request.get<QueryQuoteSwapExactInResponse>(\n      `/metaos-labs/metaos/swap/quote_swap_exact_in`,\n      { ...params }\n    );\n  }\n\n  public async quoteSwapExactOut(params: QueryQuoteSwapExactOutRequest): Promise<QueryQuoteSwapExactOutResponse> {\n    return this.request.get<QueryQuoteSwapExactOutResponse>(\n      `/metaos-labs/metaos/swap/quote_swap_exact_out`,\n      { ...params }\n    );\n  }\n\n}\n","import {BaseAPI} from \"./BaseAPI\";\nimport {DefaultNodeInfo} from \"../proto/tendermint/p2p/types\";\nimport {PaginationOptions} from \"./APIRequester\";\nimport {\n  GetBlockByHeightResponse,\n  GetLatestBlockResponse,\n  GetLatestValidatorSetResponse,\n  GetValidatorSetByHeightResponse\n} from \"../proto/cosmos/base/tendermint/v1beta1/query\";\n\nexport class TendermintAPI extends BaseAPI {\n\n  public async blockInfo(\n    height?: number\n  ): Promise<GetLatestBlockResponse | GetBlockByHeightResponse> {\n    const url =\n      height !== undefined\n        ? `/cosmos/base/tendermint/v1beta1/blocks/${height}`\n        : `/cosmos/base/tendermint/v1beta1/blocks/latest`;\n    return this.request.get<GetLatestBlockResponse | GetBlockByHeightResponse>(\n      url\n    );\n  }\n\n  public async nodeInfo(): Promise<DefaultNodeInfo> {\n    return this.request.get<DefaultNodeInfo>(\n      `/cosmos/base/tendermint/v1beta1/node_info`,\n    );\n  }\n\n  public async syncing(): Promise<boolean> {\n    return this.request.get<boolean>(\n      `/cosmos/base/tendermint/v1beta1/syncing`,\n    );\n  }\n\n  public async validatorSet(\n    height?: number,\n    params?: PaginationOptions\n  ): Promise<GetValidatorSetByHeightResponse | GetLatestValidatorSetResponse> {\n    const url =\n      height !== undefined\n        ? `/cosmos/base/tendermint/v1beta1/validatorsets/${height}`\n        : `/cosmos/base/tendermint/v1beta1/validatorsets/latest`;\n    return this.request.get<GetValidatorSetByHeightResponse | GetLatestValidatorSetResponse>(\n      url,\n      {...params}\n    );\n  }\n\n}\n","import { BaseAPI } from \"./BaseAPI\";\nimport {DenomUnit, Metadata} from \"../proto/cosmos/bank/v1beta1/bank\";\nimport {MetadataExt} from \"../proto/token/token\";\nimport {\n  QueryAllMetadataResponse,\n  QueryAllOwnershipConfirmationResponse,\n  QueryGetMetadataResponse, QueryGetOwnershipConfirmationResponse\n} from \"../proto/token/query\";\nimport {PaginationOptions} from \"./APIRequester\";\n\nexport class TokenAPI extends BaseAPI {\n\n  public async allMetadata(\n    params?: PaginationOptions\n  ): Promise<QueryAllMetadataResponse> {\n    return this.request.get<QueryAllMetadataResponse>(\n      `/metaos-labs/metaos/token/metadatas`,\n      { ...params }\n    );\n  }\n\n  public async getMetadata(\n    denom: string\n  ): Promise<QueryGetMetadataResponse> {\n    return this.request.get<QueryGetMetadataResponse>(\n      `/metaos-labs/metaos/token/metadatas/by_denom`,\n      {\n        denom\n      }\n    );\n  }\n\n  public async allOwnershipConfirmation(\n    params?: PaginationOptions\n  ): Promise<QueryAllOwnershipConfirmationResponse> {\n    return this.request.get<QueryAllOwnershipConfirmationResponse>(\n      `/metaos-labs/metaos/token/ownership_confirmations`,\n      { ...params }\n    );\n  }\n\n  public async getOwnershipConfirmation(\n    denom: string\n  ): Promise<QueryGetOwnershipConfirmationResponse> {\n    return this.request.get<QueryGetOwnershipConfirmationResponse>(\n      `/metaos-labs/metaos/token/ownership_confirmations/by_denom`,\n      {\n        denom\n      }\n    );\n  }\n\n}\n","import { BaseAPI } from \"./BaseAPI\";\nimport { TxResponse } from \"../proto/cosmos/base/abci/v1beta1/abci\";\nimport {\n  BroadcastTxRequest,\n  BroadcastTxResponse,\n  GetBlockWithTxsResponse,\n  GetTxsEventRequest,\n  GetTxsEventResponse, SimulateRequest, SimulateResponse,\n} from \"../proto/cosmos/tx/v1beta1/service\";\nimport {PaginationOptions} from \"./APIRequester\";\n\nexport class TxAPI extends BaseAPI {\n\n  public async simulate(params: SimulateRequest): Promise<SimulateResponse> {\n    return this.request.post<SimulateResponse>(\n    `/cosmos/tx/v1beta1/simulate`,\n      params\n    );\n  }\n\n  public async broadcast(tx: BroadcastTxRequest): Promise<BroadcastTxResponse> {\n    return this.request.post<BroadcastTxResponse>(\n      `/cosmos/tx/v1beta1/txs`,\n      tx\n    );\n  }\n\n  public async txBlock(\n    height: number,\n    params?: PaginationOptions\n  ): Promise<GetBlockWithTxsResponse> {\n    return this.request.get<GetBlockWithTxsResponse>(\n      `/cosmos/tx/v1beta1/txs/block/${height}`,\n      { ...params }\n    );\n  }\n\n  public async txInfo(txHash: string): Promise<TxResponse> {\n    return this.request.get<TxResponse>(`/cosmos/tx/v1beta1/txs/${txHash}`);\n  }\n\n  public async search(\n    options: Partial<GetTxsEventRequest>\n  ): Promise<GetTxsEventResponse> {\n    return this.request.get<GetTxsEventResponse>(\n      `cosmos/tx/v1beta1/txs`,\n      { ...options }\n    );\n  }\n\n}\n","import {BaseAPI} from \"./BaseAPI\";\nimport {PaginationOptions} from \"./APIRequester\";\nimport {\n  QueryCodeResponse,\n  QueryCodesResponse,\n  QueryContractInfoResponse,\n  QueryContractsByCodeResponse\n} from \"../proto/cosmwasm/wasm/v1/query\";\n\nexport class WasmAPI extends BaseAPI {\n  public async codes(\n    params?: PaginationOptions\n  ): Promise<QueryCodesResponse> {\n    return this.request.get<QueryCodesResponse>(\n      `/cosmwasm/wasm/v1/code`,\n      { ...params }\n    );\n  }\n\n  public async code(\n    codeID: number\n  ): Promise<QueryCodeResponse> {\n    return this.request.get<QueryCodeResponse>(\n      `/cosmwasm/wasm/v1/code/${codeID}`,\n    );\n  }\n\n  public async contractsByCode(\n    codeID: number,\n    params?: PaginationOptions\n  ): Promise<QueryContractsByCodeResponse> {\n    return this.request.get<QueryContractsByCodeResponse>(\n      `/cosmwasm/wasm/v1/code/${codeID}/contracts`,\n      { ...params }\n    );\n  }\n\n  public async contractInfo(\n    contractAddress: string,\n  ): Promise<QueryContractInfoResponse> {\n    return this.request.get<QueryContractInfoResponse>(\n      `/cosmwasm/wasm/v1/contract/${contractAddress}`,\n    );\n  }\n\n}\n","export function to32(value: string) {\n  const arr = value.split(\",\");\n  const len = 32 - arr.length;\n  const result: Array<number> = [];\n  arr.forEach((item) => {\n    result.push(+item);\n  });\n  for (let i = 0; i < len; i++) {\n    result.unshift(0);\n  }\n  return result;\n}\n","export function deepCopy(source: Object) {\n  // if (typeof source != \"object\") {\n  //   return source;\n  // }\n  // if (source == null) {\n  //   return source;\n  // }\n  // const newObj = source.constructor === Array ? [] as Array<T> : {};\n  // for (const i in source) {\n  //   newObj[i] = deepCopy(source[i]);\n  // }\n  // return newObj;\n\n  return JSON.parse(JSON.stringify(source));\n}\n","export function encrypt(value: string, prefix = 6, suffix = 4) {\n  if (value) {\n    return value.substr(0, prefix) + \"...\" + value.substr(-suffix);\n  } else {\n    return value;\n  }\n}\n","export const ONE_DAY_TO_SECONDS = 86400;\n\nexport const ONE_YEAR_TO_DAYS = 365;\n","export enum Fee_Amount {\n  LOWEST = 100,\n  LOW = 500,\n  MEDIUM = 3000,\n  HIGH = 10000,\n}\n\nexport const FEE_AMOUNT_DETAIL: Record<\n  Fee_Amount,\n  { label: string; value: Fee_Amount; description: string }\n> = {\n  [Fee_Amount.LOWEST]: {\n    label: \"0.01\",\n    value: Fee_Amount.LOWEST,\n    description: \"Best for very stable pairs.\",\n  },\n  [Fee_Amount.LOW]: {\n    label: \"0.05\",\n    value: Fee_Amount.LOW,\n    description: \"Best for stable pairs.\",\n  },\n  [Fee_Amount.MEDIUM]: {\n    label: \"0.3\",\n    value: Fee_Amount.MEDIUM,\n    description: \"Best for most pairs.\",\n  },\n  [Fee_Amount.HIGH]: {\n    label: \"1\",\n    value: Fee_Amount.HIGH,\n    description: \"Best for exotic pairs.\",\n  },\n};\n","export enum Chain_Id {\n  Mainnet = 'metaos_99237-1',\n  Testnet = 'metaos_99237-2',\n  Devnet = 'metaos_99237-3'\n}\n\nexport const CHAIN_NAMES = {\n  [Chain_Id.Mainnet]: 'Mainnet',\n  [Chain_Id.Testnet]: 'Testnet',\n  [Chain_Id.Devnet]: 'Devnet',\n}\n\nexport const NETWORK_DETAILS = {\n  [Chain_Id.Mainnet]: {\n    chainId: 'metaos_99237-1',\n    chainName: 'Metaos Mainnet',\n    nativeCurrency: {\n      base: 'umtos',\n      name: 'MetaOS',\n      symbol: 'MTOS',\n      display_exponent: 18,\n      logo_uri: 'https://s2.coinmarketcap.com/static/img/coins/64x64/2025.png',\n    },\n    nodeUrl: 'https://node.metaos.im',\n    rpcUrl: 'https://tendermint.metaos.im',\n    blockExplorerUrl: 'https://scan.metaos.im',\n  },\n  [Chain_Id.Testnet]: {\n    chainId: 'metaos_99237-2',\n    chainName: 'Metaos Mainnet',\n    nativeCurrency: {\n      base: 'umtos',\n      name: 'MetaOS',\n      symbol: 'MTOS',\n      display_exponent: 18,\n      logo_uri: 'https://s2.coinmarketcap.com/static/img/coins/64x64/2025.png',\n    },\n    nodeUrl: 'https://node.metaos.im',\n    rpcUrl: 'https://tendermint.metaos.im',\n    blockExplorerUrl: 'https://scan.metaos.im',\n  },\n  [Chain_Id.Devnet]: {\n    chainId: 'metaos_99237-3',\n    chainName: 'Metaos Mainnet',\n    nativeCurrency: {\n      base: 'umtos',\n      name: 'MetaOS',\n      symbol: 'MTOS',\n      display_exponent: 18,\n      logo_uri: 'https://s2.coinmarketcap.com/static/img/coins/64x64/2025.png',\n    },\n    nodeUrl: 'https://node.metaos.im',\n    rpcUrl: 'https://tendermint.metaos.im',\n    blockExplorerUrl: 'https://scan.metaos.im',\n  },\n}\n","export const ZERO = \"0\";\n","export const DEFAULT_USER_PRECISION = 6;\n\nexport const DEFAULT_PRECISION = 18;\n\nexport const MAX_PRECISION = 28;\n\nexport const REG_NUMBER = new RegExp(\n  \"^[1-9]+[0-9]*(\\\\.\\\\d{0,\" + DEFAULT_PRECISION + \"})?$\"\n);\n\nexport const REG_DECIMAL_SIMPLE = /^\\d*(\\.\\d*)?$/;\n\nexport const REG_DECIMAL = new RegExp(\n  \"^0(\\\\.\\\\d{0,\" + DEFAULT_PRECISION + \"})?$\"\n);\n","export const TICK_SPACINGS = {\n  100: 1,\n  500: 10,\n  3000: 60,\n  10000: 200,\n};\n\nexport const BASE_UNIT_TICK = 1.0001;\n","import Decimal from \"decimal.js\";\nimport { Decimal as CosmosDecimal } from \"@cosmjs/math\";\nimport {\n  DEFAULT_PRECISION,\n  DEFAULT_USER_PRECISION,\n  MAX_PRECISION,\n} from \"../constants\";\n\nexport function toDecimalPlaces(\n  value: string | number | Decimal,\n  precision: number = DEFAULT_PRECISION\n) {\n  try {\n    return new Decimal(value)\n      .toDecimalPlaces(precision, Decimal.ROUND_UP)\n      .toString();\n  } catch (e) {\n    return String(value || \"-\");\n  }\n}\n\nexport function toAmountString(\n  value: Decimal.Value | undefined = \"\",\n  precision: number = DEFAULT_USER_PRECISION,\n  roundingMode: Decimal.Rounding = Decimal.ROUND_DOWN\n): string {\n  try {\n    return new Decimal(value)\n      .toSignificantDigits(precision, roundingMode)\n      .toString();\n  } catch (e) {\n    return String(value || \"-\");\n  }\n}\n\nexport function toAmountFloor(\n  value: string | number,\n  precision: number = DEFAULT_USER_PRECISION\n): string {\n  return toAmountString(value, precision, Decimal.ROUND_DOWN);\n}\n\nexport function toAmountCeil(\n  value: string | number,\n  precision: number = DEFAULT_USER_PRECISION\n) {\n  return toAmountString(value, precision, Decimal.ROUND_UP);\n}\n\nexport function toAmountFee(\n  value: string | number,\n  precision: number = DEFAULT_PRECISION\n): string {\n  try {\n    return new Decimal(value)\n      .toDecimalPlaces(precision, Decimal.ROUND_DOWN)\n      .toString();\n  } catch (e) {\n    return String(value || \"-\");\n  }\n}\n\nexport function isEmptyAmount(\n  value: Decimal.Value,\n  precision: number = MAX_PRECISION\n): boolean {\n  const _value = new Decimal(value).mul(Math.pow(10, precision)).floor();\n  return _value.isZero();\n}\n\nexport function toExactAmount(\n  value: string,\n  precision = MAX_PRECISION\n): string {\n  try {\n    return CosmosDecimal.fromUserInput(value, precision).toString();\n  } catch (e) {\n    return String(value || \"-\");\n  }\n}\n\nexport const formatNumber = (\n  value: Decimal.Value,\n  seperator: number = 3,\n  fixed: number = 2\n) => {\n  return `${new Decimal(value)\n    .div(new Decimal(10).pow(seperator))\n    .toFixed(fixed)}k`;\n};\n","import moment from \"moment\";\n\nmoment.locale(\"en-ca\");\n\nexport function formatMoment(value: string, pattern = \"YYYY/MM/DD HH:mm:ss\") {\n  return moment(+value).format(pattern);\n}\n\nexport function formatUnixMoment(value: string, pattern = \"MM/DD HH:mm:ss\") {\n  return moment(+value * 1000).format(pattern);\n}\n\nexport const formatTime = (time: string) => {\n  return moment(time).format(\"YYYY-MM-DD HH:mm:ss\");\n};\n\nexport const formatDiffTime = (time: string) => {\n  return moment(time).fromNow();\n};\n","import Decimal from \"decimal.js\";\n\nexport function toUsd(value: Decimal.Value): string | number {\n  try {\n    return \"$\" + new Decimal(value).toFixed(2);\n  } catch (e) {\n    return String(value || \"-\");\n  }\n}\n","import { Fee_Amount } from \"../constants\";\nimport { Bech32, toUtf8 } from \"@cosmjs/encoding\";\nimport { sha256 } from \"@cosmjs/crypto\";\n\nexport function getPoolAddress(\n  denom0: string,\n  denom1: string,\n  fee: Fee_Amount\n) {\n  let key;\n  if (denom0 > denom1) {\n    key = `${denom1}-${denom0}-${fee}`;\n  } else {\n    key = `${denom0}-${denom1}-${fee}`;\n  }\n  return Bech32.encode(\"mtos\", sha256(toUtf8(key)).slice(0, 20));\n}\n","import { Fee_Amount, FEE_AMOUNT_DETAIL } from \"../constants\";\n\nexport function getPercentByFeeAmount(fee: Fee_Amount | undefined) {\n  if (fee) {\n    return `${FEE_AMOUNT_DETAIL[fee].label}%`;\n  } else {\n    return \"-\";\n  }\n}\n","import { REG_DECIMAL, REG_NUMBER, ZERO } from \"../constants\";\nimport Decimal from \"decimal.js\";\n\nexport function isNumeric(value: string) {\n  return !isNaN(parseFloat(value));\n  // return new Decimal(value).lessThan(ZERO);\n}\n\nexport function checkInputNumber(value: string) {\n  if (REG_NUMBER.test(value) || REG_DECIMAL.test(value) === true) {\n    return true;\n  }\n  return false;\n}\n","import Decimal from \"decimal.js\";\nimport { DEFAULT_PRECISION } from \"../constants\";\n\nexport function plus(value1: string, value2: string) {\n  return new Decimal(value1).plus(value2).toString();\n}\n\nexport function minus(value1: string | number, value2: string | number) {\n  return new Decimal(value1).minus(value2).toString();\n}\n\nexport function multipliedBy(value1: string | number, value2: string | number) {\n  return new Decimal(value1).mul(value2).toString();\n}\n\nexport function div(value1: string, value2: string): string {\n  return new Decimal(value1).div(value2).toString();\n}\n\nexport function isGreaterThan(value1: string, value2: string) {\n  return new Decimal(value1).greaterThanOrEqualTo(value2);\n}\n\nexport function isLessThan(value1: string, value2: string) {\n  return new Decimal(value1).lessThan(value2);\n}\n\nexport function isEqualTo(value1: string, value2: string) {\n  return new Decimal(value1).equals(value2);\n}\n\nexport function pow18(value: string): string {\n  return new Decimal(value).mul(Math.pow(10, DEFAULT_PRECISION)).toFixed();\n}\n\nexport function pow(\n  value: string | number | Decimal,\n  precision: number = DEFAULT_PRECISION,\n  round: Decimal.Rounding = Decimal.ROUND_DOWN\n): string {\n  if (value === \"\") {\n    return \"0\";\n  }\n  const _value = new Decimal(value).mul(Math.pow(10, precision));\n  if (round === Decimal.ROUND_UP) {\n    return _value.ceil().toFixed();\n  }\n  return _value.floor().toFixed();\n}\n\nexport function powM18(value: string | number) {\n  return new Decimal(value).div(Math.pow(10, DEFAULT_PRECISION)).toString();\n}\n\nexport function shift(value: string, precision: number = DEFAULT_PRECISION) {\n  return new Decimal(value).div(Math.pow(10, precision)).toFixed();\n}\n\nexport function isPositive(value: string | number) {\n  if (!value) {\n    return false;\n  }\n  return new Decimal(value).greaterThan(0);\n}\n","export function objectToMap<K, T>(source: Object) {\n  return new Map(Object.entries(source));\n}\n\nexport function arrayToMap<T, K extends keyof T>(array: Array<T>, property: K) {\n  const map = new Map<T[K], T>();\n  for (const item of array) {\n    map.set(item[property], item);\n  }\n  return map;\n}\n","import { Token } from \"../types\";\n\nexport function sortsBefore(baseToken: Token, quoteToken: Token) {\n  return baseToken.base.toLowerCase() < quoteToken.base.toLowerCase();\n}\n","import Decimal from \"decimal.js\";\n\nexport function toPercent(value: Decimal.Value, hundred: boolean = true): string {\n  try {\n    if (hundred) {\n      return `${new Decimal(value).mul(100).toFixed(2)}%`;\n    } else {\n      return `${new Decimal(value).toFixed(2)}%`;\n    }\n  } catch (e) {\n    return value.toString();\n  }\n}\n","import Decimal from \"decimal.js\";\n\nexport const decimalNumber = (number = \" \") => {\n  const [int = \"\", float = \"\"] = number.toString().replace(\"$\", \"\").split(\".\");\n\n  if (int.length > 10) {\n    return `${new Decimal(int).div(new Decimal(10).pow(10)).toFixed(2)}B`;\n  } else if (int.length > 7) {\n    return `${new Decimal(int).div(new Decimal(10).pow(7)).toFixed(2)}M`;\n  } else if (int.length > 3) {\n    return `${new Decimal(int).div(new Decimal(10).pow(3)).toFixed(2)}K`;\n  } else {\n    return `${Number(int) > 0 ? int : 0}.${\n      float.length > 0 ? float.slice(0, 2) : \"00\"\n    }`;\n  }\n};\n","import { DeliverTxResponse } from \"@cosmjs/stargate\";\n\nexport type BroadcastResult = DeliverTxResponse;\n\nexport interface ITransaction {\n  transactionHash: string;\n  description: string;\n  status: Transaction_Status;\n}\n\nexport enum Transaction_Status {\n  Wallet = \"wallet\",\n  Pending = \"pending\",\n  Complete = \"complete\",\n  Success = \"success\",\n  Error = \"error\",\n  Reject = \"reject\",\n}\n\nexport function longToNumber(long: Long): number {\n  if (long.gt(Number.MAX_SAFE_INTEGER)) {\n    throw new globalThis.Error(\"Value is larger than Number.MAX_SAFE_INTEGER\");\n  }\n  return long.toNumber();\n}\n","export * from \"./pool\";\nexport * from \"./token\";\nexport * from \"./wallet\";\n\nexport type DeepPartial<T> = T extends object\n  ? {\n    [P in keyof T]?: DeepPartial<T[P]>;\n  }\n  : T;\n\ntype Pick<T, K extends keyof T> = {\n  [P in K]: T[P];\n};\n\nexport enum Tip_Level {\n  Info = \"info\",\n  Warning = \"warning\",\n  Error = \"error\",\n}\n\nexport enum Direction {\n  In = \"exactIn\",\n  Out = \"exactOut\",\n}\n","import { Token } from \"../types\";\nimport { toDecimalPlaces } from \"../utils\";\nimport Decimal from \"decimal.js\";\n\nexport class LiquidityMath {\n  private static getRightSideLiquidity(\n    leftRangeValue: number, // pa\n    rightRangeValue: number, // pb\n    priceValue: number,\n    amount: string\n  ): Decimal {\n    const numerator = new Decimal(amount);\n    const _value1 = new Decimal(1).div(Decimal.sqrt(leftRangeValue));\n    const _value2 = new Decimal(1).div(Decimal.sqrt(rightRangeValue));\n    const denominator = Decimal.sub(_value1, _value2);\n    return numerator.div(denominator);\n  }\n\n  private static getLeftSideLiquidity(\n    leftRangeValue: number, // pa\n    rightRangeValue: number, // pb\n    priceValue: number,\n    amount: string\n  ): Decimal {\n    const numerator = new Decimal(amount);\n    const denominator = Decimal.sub(\n      Decimal.sqrt(rightRangeValue),\n      Decimal.sqrt(leftRangeValue)\n    );\n    return numerator.div(denominator);\n  }\n\n  public static getLiquidityFromAmount0(\n    leftRangeValue: number, // pa\n    rightRangeValue: number, // pb\n    priceValue: number,\n    amount0: string\n  ): Decimal {\n    const pc = new Decimal(priceValue);\n    if (pc.lessThan(leftRangeValue)) {\n      return this.getRightSideLiquidity(\n        leftRangeValue,\n        rightRangeValue,\n        priceValue,\n        amount0\n      );\n    } else if (pc.greaterThan(rightRangeValue)) {\n      return this.getLeftSideLiquidity(\n        leftRangeValue,\n        rightRangeValue,\n        priceValue,\n        amount0\n      );\n    }\n    const deltaX = new Decimal(amount0);\n    const _value1 = new Decimal(1).div(Decimal.sqrt(priceValue));\n    const _value2 = new Decimal(1).div(Decimal.sqrt(rightRangeValue));\n    const denominator = Decimal.sub(_value1, _value2);\n    return deltaX.div(denominator);\n  }\n\n  private static _getDiverForDeltaX(\n    lower: Decimal.Value,\n    upper: Decimal.Value\n  ): Decimal {\n    const _value1 = new Decimal(1).div(Decimal.sqrt(lower));\n    const _value2 = new Decimal(1).div(Decimal.sqrt(upper));\n    return Decimal.sub(_value1, _value2);\n  }\n\n  private static _getDiverForDeltaY(\n    lower: Decimal.Value,\n    upper: Decimal.Value\n  ): Decimal {\n    return Decimal.sub(Decimal.sqrt(upper), Decimal.sqrt(lower));\n  }\n\n  public static getLiquidityFromAmount1(\n    leftRangeValue: number, // pa\n    rightRangeValue: number, // pb\n    priceValue: number,\n    amount1: string\n  ): Decimal {\n    const pc = new Decimal(priceValue);\n\n    if (pc.lessThan(leftRangeValue)) {\n      return this.getRightSideLiquidity(\n        leftRangeValue,\n        rightRangeValue,\n        priceValue,\n        amount1\n      );\n    } else if (pc.greaterThan(rightRangeValue)) {\n      return this.getLeftSideLiquidity(\n        leftRangeValue,\n        rightRangeValue,\n        priceValue,\n        amount1\n      );\n    }\n\n    const deltaY = new Decimal(amount1);\n    const denominator = Decimal.sub(\n      Decimal.sqrt(priceValue),\n      Decimal.sqrt(leftRangeValue)\n    );\n    return deltaY.div(denominator);\n  }\n\n  public static getAmount1FromAmount0(\n    leftRangeValue: number, // pa\n    rightRangeValue: number, // pb\n    priceValue: number,\n    amount0: string,\n    token0: Token\n  ): string {\n    const liquidity = this.getLiquidityFromAmount0(\n      leftRangeValue,\n      rightRangeValue,\n      priceValue,\n      amount0\n    );\n    // console.log(\"liquidity: \" + liquidity);\n\n    const _value1 = new Decimal(liquidity);\n    const _value2 = this._getDiverForDeltaY(leftRangeValue, priceValue);\n    return _value1.mul(_value2).toString();\n  }\n\n  public static getAmount0FromAmount1(\n    leftRangeValue: number, // pa\n    rightRangeValue: number, // pb\n    priceValue: number,\n    amount1: string,\n    token1: Token\n  ): string {\n    const liquidity = this.getLiquidityFromAmount1(\n      leftRangeValue,\n      rightRangeValue,\n      priceValue,\n      amount1\n    );\n\n    // console.log(\"liquidity: \" + liquidity);\n\n    const _value1 = new Decimal(liquidity);\n    const _value2 = this._getDiverForDeltaX(priceValue, rightRangeValue);\n    return _value1.mul(_value2).toString();\n  }\n\n  public static getAmountByLiquidity(\n    leftRangeValue: Decimal.Value,\n    rightRangeValue: Decimal.Value,\n    priceValue: Decimal.Value,\n    liquidity: string,\n    token0: Token,\n    token1: Token\n  ): { amount0: Decimal.Value; amount1: Decimal.Value } {\n    const pc = new Decimal(priceValue);\n\n    const _value1 = new Decimal(liquidity);\n\n    if (pc.lessThan(leftRangeValue)) {\n      const _value2 = this._getDiverForDeltaX(leftRangeValue, rightRangeValue);\n      return {\n        amount0: _value1.mul(_value2),\n        amount1: \"0\",\n      };\n    } else if (pc.greaterThan(rightRangeValue)) {\n      const _value2 = this._getDiverForDeltaY(leftRangeValue, rightRangeValue);\n      return {\n        amount0: \"0\",\n        amount1: _value1.mul(_value2),\n      };\n    }\n    const deltaXDiver = this._getDiverForDeltaX(priceValue, rightRangeValue);\n    const deltaYDiver = this._getDiverForDeltaY(leftRangeValue, priceValue);\n    return {\n      amount0: _value1.mul(deltaXDiver),\n      amount1: _value1.mul(deltaYDiver)\n    };\n  }\n}\n","import invariant from \"tiny-invariant\";\nimport Decimal from \"decimal.js\";\nimport { Fee_Amount, TICK_SPACINGS, BASE_UNIT_TICK } from \"../constants\";\nimport { Token } from \"../types\";\nimport { sortsBefore, toAmountString } from \"../utils\";\n\nexport class TickMath {\n  public static INVALID_TICK = -99999999;\n\n  public static MIN_TICK = -887272;\n\n  public static MIN_TICK_VALUE = \"0\";\n\n  public static MAX_TICK: number = -TickMath.MIN_TICK;\n\n  public static MAX_TICK_VALUE = \"∞\";\n\n  public static nearestUsableTick = (\n    tick: number,\n    tickSpacing: number\n  ): number => {\n    const rounded = Math.round(tick / tickSpacing) * tickSpacing;\n    if (rounded < TickMath.MIN_TICK) return rounded + tickSpacing;\n    else if (rounded > TickMath.MAX_TICK) return rounded - tickSpacing;\n    else return rounded;\n  };\n\n  private static priceToClosestTick(price: string): number {\n    const numerator = Decimal.log2(Decimal.sqrt(price));\n    const denominator = Decimal.log2(Decimal.sqrt(BASE_UNIT_TICK));\n    return numerator.div(denominator).toNumber();\n  }\n\n  /**\n   * Compute nearest tick of price for input\n   * @param feeAmount\n   * @param value\n   */\n  public static getNearestTickByPrice(\n    feeAmount: Fee_Amount,\n    value: string\n  ): number {\n    const _value = value.trim();\n    if (_value === \"\") {\n      return this.INVALID_TICK;\n    }\n    if (value === this.MIN_TICK_VALUE) {\n      return this.MIN_TICK;\n    }\n    if (value === this.MAX_TICK_VALUE) {\n      return this.MAX_TICK;\n    }\n    const tick: number = this.priceToClosestTick(value);\n    // console.log(`[priceToClosestTick]: ` + tick);\n    const result = this.nearestUsableTick(tick, TICK_SPACINGS[feeAmount]);\n    // console.log(`[nearestUsableTick]: ` + result);\n    return result;\n  }\n\n  public static getFormattedPriceByTick(\n    tick: Decimal.Value,\n    fee: Fee_Amount\n  ): string {\n    if (tick === this.INVALID_TICK) {\n      return \"\";\n    }\n    if (this.isLowestTick(tick, fee)) {\n      return this.MIN_TICK_VALUE;\n    }\n    if (this.isHighestTick(tick, fee)) {\n      return this.MAX_TICK_VALUE;\n    }\n    const base = Decimal.pow(Decimal.sqrt(BASE_UNIT_TICK), tick);\n    return Decimal.pow(base, 2).toString();\n  }\n\n  public static getPriceByTick(tick: Decimal.Value): string {\n    if (tick === this.INVALID_TICK) {\n      return \"\";\n    }\n    // if (this.isLowestTick(tick, fee)) {\n    //   return this.MIN_TICK_VALUE;\n    // }\n    // if (this.isHighestTick(tick, fee)) {\n    //   return this.MAX_TICK_VALUE;\n    // }\n    const base = Decimal.pow(Decimal.sqrt(BASE_UNIT_TICK), tick);\n    return Decimal.pow(base, 2).toString();\n  }\n\n  public static getNearestPriceByInput(\n    feeAmount: Fee_Amount,\n    price: string\n  ): string {\n    // console.log('INPUT price: ' + price);\n    const nearestTick = this.getNearestTickByPrice(feeAmount, price);\n    const result = this.getPriceByTick(nearestTick);\n    // console.log('getPriceByTick: ' + result);\n    // console.log('==========');\n    return result;\n  }\n\n  public static getPriceBySqrtPrice(sqrtPrice: string): string {\n    if (!sqrtPrice) {\n      return \"\";\n    }\n    if (sqrtPrice === \"0\") {\n      return \"0\";\n    }\n    return new Decimal(sqrtPrice).pow(2).toString();\n  }\n\n  public static getSqrtPriceByPrice(price: string): string {\n    if (price === \"0\") {\n      return \"0\";\n    }\n    return new Decimal(price).sqrt().toString();\n  }\n\n  public static getBaseTickRange(\n    fromToken: Token,\n    toToken: Token,\n    fee: Fee_Amount,\n    leftRange: string,\n    rightRange: string\n  ): { tickLower: number; tickUpper: number } {\n    let tickLower: number;\n    let tickUpper: number;\n    if (sortsBefore(fromToken, toToken)) {\n      tickLower =\n        leftRange === TickMath.MIN_TICK_VALUE\n          ? TickMath.getNearestLowestTick(fee)\n          : TickMath.getNearestTickByPrice(fee, leftRange);\n      tickUpper =\n        rightRange === TickMath.MAX_TICK_VALUE\n          ? TickMath.getNearestHighestTick(fee)\n          : TickMath.getNearestTickByPrice(fee, rightRange);\n    } else {\n      if (leftRange === TickMath.MIN_TICK_VALUE) {\n        tickUpper = TickMath.getNearestHighestTick(fee);\n      } else {\n        tickUpper = TickMath.getNearestTickByPrice(\n          fee,\n          new Decimal(1).div(leftRange).toString()\n        );\n      }\n      if (rightRange === TickMath.MAX_TICK_VALUE) {\n        tickLower = TickMath.getNearestLowestTick(fee);\n      } else {\n        tickLower = TickMath.getNearestTickByPrice(\n          fee,\n          new Decimal(1).div(rightRange).toString()\n        );\n      }\n    }\n    // console.log(\"tickLower: \" + tickLower);\n    // console.log(\"tickUpper: \" + tickUpper);\n    return {\n      tickLower,\n      tickUpper,\n    };\n  }\n\n  public static getNearestLowestTick(fee: Fee_Amount): number {\n    const tickLower = this.nearestUsableTick(this.MIN_TICK, TICK_SPACINGS[fee]);\n    // console.log('getNearestLowestTick: ' + tickLower);\n    return tickLower;\n  }\n\n  public static getNearestHighestTick(fee: Fee_Amount): number {\n    const tickUpper = this.nearestUsableTick(this.MAX_TICK, TICK_SPACINGS[fee]);\n    // console.log('getNearestHighestTick: ' + tickUpper);\n    return tickUpper;\n  }\n\n  public static getNearestPricesByFullTick(fee: Fee_Amount): {\n    lowestPrice: string;\n    highestPrice: string;\n  } {\n    const tickLower = this.nearestUsableTick(this.MIN_TICK, TICK_SPACINGS[fee]);\n    const tickUpper = this.nearestUsableTick(this.MAX_TICK, TICK_SPACINGS[fee]);\n    const lowestPrice = this.getPriceByTick(tickLower);\n    const highestPrice = this.getPriceByTick(tickUpper);\n    return {\n      lowestPrice,\n      highestPrice,\n    };\n  }\n\n  public static isHighestTick(tick: Decimal.Value, fee: Fee_Amount): boolean {\n    const highestTick = this.getNearestHighestTick(fee);\n    return tick >= highestTick;\n  }\n\n  public static isLowestTick(tick: Decimal.Value, fee: Fee_Amount): boolean {\n    const lowestTick = this.getNearestLowestTick(fee);\n    return tick <= lowestTick;\n  }\n}\n","import { Transaction_Status } from \"../types\";\n\nexport class TransactionLooper {\n  transactionHash: string;\n  description: string;\n  status: Transaction_Status;\n  counter: number;\n  onTransactionSuccess: Function | undefined;\n\n  constructor(\n    txHash: string,\n    description: string,\n    status: Transaction_Status,\n    onTransactionSuccess?: Function\n  ) {\n    this.transactionHash = txHash;\n    this.description = description;\n    this.status = status;\n    this.counter = 0;\n    this.onTransactionSuccess = onTransactionSuccess;\n  }\n}\n","import {\n  APIRequester,\n  AuthAPI,\n  AuthzAPI,\n  BankAPI,\n  DeflationAPI,\n  GovAPI,\n  MintAPI,\n  PoolIncentiveAPI,\n  SlashingAPI,\n  StakingAPI,\n  SwapAPI,\n  TendermintAPI,\n  TokenAPI,\n  TxAPI,\n  WasmAPI\n} from \"../api\";\nimport {Chain_Id} from \"../constants\";\n\nexport class APIClient {\n  public apiRequester: APIRequester;\n  public nodeUrl: string;\n\n  // API access\n  public authAPI: AuthAPI;\n  public authzAPI: AuthzAPI;\n  public bankAPI: BankAPI;\n  public deflationAPI: DeflationAPI;\n  public govAPI: GovAPI;\n  public mintAPI: MintAPI;\n  public poolIncentiveAPI: PoolIncentiveAPI;\n  public slashingAPI: SlashingAPI;\n  public stakingAPI: StakingAPI;\n  public swapAPI: SwapAPI;\n  public tendermintAPI: TendermintAPI;\n  public tokenAPI: TokenAPI;\n  public txAPI: TxAPI;\n  public wasmAPI: WasmAPI;\n\n  constructor(URL: string, chainId: Chain_Id = Chain_Id.Mainnet) {\n    this.nodeUrl = URL;\n    this.apiRequester = new APIRequester(URL);\n\n    // instantiate APIs\n    this.authAPI = new AuthAPI(this.apiRequester);\n    this.authzAPI = new AuthzAPI(this.apiRequester);\n    this.bankAPI = new BankAPI(this.apiRequester);\n    this.deflationAPI = new DeflationAPI(this.apiRequester);\n    this.govAPI = new GovAPI(this.apiRequester);\n    this.mintAPI = new MintAPI(this.apiRequester);\n    this.poolIncentiveAPI = new PoolIncentiveAPI(this.apiRequester);\n    this.slashingAPI = new SlashingAPI(this.apiRequester);\n    this.stakingAPI = new StakingAPI(this.apiRequester);\n    this.swapAPI = new SwapAPI(this.apiRequester);\n    this.tendermintAPI = new TendermintAPI(this.apiRequester);\n    this.tokenAPI = new TokenAPI(this.apiRequester);\n    this.txAPI = new TxAPI(this.apiRequester);\n    this.wasmAPI = new WasmAPI(this.apiRequester);\n  }\n}\n","import { EncodeObject, TxBodyEncodeObject } from \"@cosmjs/proto-signing\";\n\nexport abstract class BaseMsg {\n  constructor() {}\n  public abstract generateMessage(): EncodeObject;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"google.protobuf\";\n\n/**\n * `Any` contains an arbitrary serialized protocol buffer message along with a\n * URL that describes the type of the serialized message.\n *\n * Protobuf library provides support to pack/unpack Any values in the form\n * of utility functions or additional generated methods of the Any type.\n *\n * Example 1: Pack and unpack a message in C++.\n *\n *     Foo foo = ...;\n *     Any any;\n *     any.PackFrom(foo);\n *     ...\n *     if (any.UnpackTo(&foo)) {\n *       ...\n *     }\n *\n * Example 2: Pack and unpack a message in Java.\n *\n *     Foo foo = ...;\n *     Any any = Any.pack(foo);\n *     ...\n *     if (any.is(Foo.class)) {\n *       foo = any.unpack(Foo.class);\n *     }\n *\n *  Example 3: Pack and unpack a message in Python.\n *\n *     foo = Foo(...)\n *     any = Any()\n *     any.Pack(foo)\n *     ...\n *     if any.Is(Foo.DESCRIPTOR):\n *       any.Unpack(foo)\n *       ...\n *\n *  Example 4: Pack and unpack a message in Go\n *\n *      foo := &pb.Foo{...}\n *      any, err := ptypes.MarshalAny(foo)\n *      ...\n *      foo := &pb.Foo{}\n *      if err := ptypes.UnmarshalAny(any, foo); err != nil {\n *        ...\n *      }\n *\n * The pack methods provided by protobuf library will by default use\n * 'type.googleapis.com/full.type.name' as the type URL and the unpack\n * methods only use the fully qualified type name after the last '/'\n * in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n * name \"y.z\".\n *\n *\n * JSON\n * ====\n * The JSON representation of an `Any` value uses the regular\n * representation of the deserialized, embedded message, with an\n * additional field `@type` which contains the type URL. Example:\n *\n *     package google.profile;\n *     message Person {\n *       string first_name = 1;\n *       string last_name = 2;\n *     }\n *\n *     {\n *       \"@type\": \"type.googleapis.com/google.profile.Person\",\n *       \"firstName\": <string>,\n *       \"lastName\": <string>\n *     }\n *\n * If the embedded message type is well-known and has a custom JSON\n * representation, that representation will be embedded adding a field\n * `value` which holds the custom JSON in addition to the `@type`\n * field. Example (for message [google.protobuf.Duration][]):\n *\n *     {\n *       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n *       \"value\": \"1.212s\"\n *     }\n */\nexport interface Any {\n  /**\n   * A URL/resource name that uniquely identifies the type of the serialized\n   * protocol buffer message. This string must contain at least\n   * one \"/\" character. The last segment of the URL's path must represent\n   * the fully qualified name of the type (as in\n   * `path/google.protobuf.Duration`). The name should be in a canonical form\n   * (e.g., leading \".\" is not accepted).\n   *\n   * In practice, teams usually precompile into the binary all types that they\n   * expect it to use in the context of Any. However, for URLs which use the\n   * scheme `http`, `https`, or no scheme, one can optionally set up a type\n   * server that maps type URLs to message definitions as follows:\n   *\n   * * If no scheme is provided, `https` is assumed.\n   * * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n   *   value in binary format, or produce an error.\n   * * Applications are allowed to cache lookup results based on the\n   *   URL, or have them precompiled into a binary to avoid any\n   *   lookup. Therefore, binary compatibility needs to be preserved\n   *   on changes to types. (Use versioned type names to manage\n   *   breaking changes.)\n   *\n   * Note: this functionality is not currently available in the official\n   * protobuf release, and it is not used for type URLs beginning with\n   * type.googleapis.com.\n   *\n   * Schemes other than `http`, `https` (or the empty scheme) might be\n   * used with implementation specific semantics.\n   */\n  typeUrl: string;\n  /** Must be a valid serialized protocol buffer of the above specified type. */\n  value: Uint8Array;\n}\n\nfunction createBaseAny(): Any {\n  return { typeUrl: \"\", value: new Uint8Array() };\n}\n\nexport const Any = {\n  encode(message: Any, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (message.typeUrl !== \"\") {\n      writer.uint32(10).string(message.typeUrl);\n    }\n    if (message.value.length !== 0) {\n      writer.uint32(18).bytes(message.value);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Any {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseAny();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.typeUrl = reader.string();\n          break;\n        case 2:\n          message.value = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Any {\n    return {\n      typeUrl: isSet(object.typeUrl) ? String(object.typeUrl) : \"\",\n      value: isSet(object.value)\n        ? bytesFromBase64(object.value)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: Any): unknown {\n    const obj: any = {};\n    message.typeUrl !== undefined && (obj.typeUrl = message.typeUrl);\n    message.value !== undefined &&\n      (obj.value = base64FromBytes(\n        message.value !== undefined ? message.value : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Any>, I>>(object: I): Any {\n    const message = createBaseAny();\n    message.typeUrl = object.typeUrl ?? \"\";\n    message.value = object.value ?? new Uint8Array();\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"google.protobuf\";\n\n/**\n * A Timestamp represents a point in time independent of any time zone or local\n * calendar, encoded as a count of seconds and fractions of seconds at\n * nanosecond resolution. The count is relative to an epoch at UTC midnight on\n * January 1, 1970, in the proleptic Gregorian calendar which extends the\n * Gregorian calendar backwards to year one.\n *\n * All minutes are 60 seconds long. Leap seconds are \"smeared\" so that no leap\n * second table is needed for interpretation, using a [24-hour linear\n * smear](https://developers.google.com/time/smear).\n *\n * The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By\n * restricting to that range, we ensure that we can convert to and from [RFC\n * 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.\n *\n * # Examples\n *\n * Example 1: Compute Timestamp from POSIX `time()`.\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(time(NULL));\n *     timestamp.set_nanos(0);\n *\n * Example 2: Compute Timestamp from POSIX `gettimeofday()`.\n *\n *     struct timeval tv;\n *     gettimeofday(&tv, NULL);\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(tv.tv_sec);\n *     timestamp.set_nanos(tv.tv_usec * 1000);\n *\n * Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.\n *\n *     FILETIME ft;\n *     GetSystemTimeAsFileTime(&ft);\n *     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;\n *\n *     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z\n *     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.\n *     Timestamp timestamp;\n *     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));\n *     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));\n *\n * Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.\n *\n *     long millis = System.currentTimeMillis();\n *\n *     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)\n *         .setNanos((int) ((millis % 1000) * 1000000)).build();\n *\n *\n * Example 5: Compute Timestamp from Java `Instant.now()`.\n *\n *     Instant now = Instant.now();\n *\n *     Timestamp timestamp =\n *         Timestamp.newBuilder().setSeconds(now.getEpochSecond())\n *             .setNanos(now.getNano()).build();\n *\n *\n * Example 6: Compute Timestamp from current time in Python.\n *\n *     timestamp = Timestamp()\n *     timestamp.GetCurrentTime()\n *\n * # JSON Mapping\n *\n * In JSON format, the Timestamp type is encoded as a string in the\n * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the\n * format is \"{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z\"\n * where {year} is always expressed using four digits while {month}, {day},\n * {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional\n * seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),\n * are optional. The \"Z\" suffix indicates the timezone (\"UTC\"); the timezone\n * is required. A proto3 JSON serializer should always use UTC (as indicated by\n * \"Z\") when printing the Timestamp type and a proto3 JSON parser should be\n * able to accept both UTC and other timezones (as indicated by an offset).\n *\n * For example, \"2017-01-15T01:30:15.01Z\" encodes 15.01 seconds past\n * 01:30 UTC on January 15, 2017.\n *\n * In JavaScript, one can convert a Date object to this format using the\n * standard\n * [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)\n * method. In Python, a standard `datetime.datetime` object can be converted\n * to this format using\n * [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with\n * the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use\n * the Joda Time's [`ISODateTimeFormat.dateTime()`](\n * http://www.joda.org/joda-time/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime%2D%2D\n * ) to obtain a formatter capable of generating timestamps in this format.\n */\nexport interface Timestamp {\n  /**\n   * Represents seconds of UTC time since Unix epoch\n   * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n   * 9999-12-31T23:59:59Z inclusive.\n   */\n  seconds: Long;\n  /**\n   * Non-negative fractions of a second at nanosecond resolution. Negative\n   * second values with fractions must still have non-negative nanos values\n   * that count forward in time. Must be from 0 to 999,999,999\n   * inclusive.\n   */\n  nanos: number;\n}\n\nfunction createBaseTimestamp(): Timestamp {\n  return { seconds: Long.ZERO, nanos: 0 };\n}\n\nexport const Timestamp = {\n  encode(\n    message: Timestamp,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.seconds.isZero()) {\n      writer.uint32(8).int64(message.seconds);\n    }\n    if (message.nanos !== 0) {\n      writer.uint32(16).int32(message.nanos);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Timestamp {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTimestamp();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.seconds = reader.int64() as Long;\n          break;\n        case 2:\n          message.nanos = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Timestamp {\n    return {\n      seconds: isSet(object.seconds)\n        ? Long.fromValue(object.seconds)\n        : Long.ZERO,\n      nanos: isSet(object.nanos) ? Number(object.nanos) : 0,\n    };\n  },\n\n  toJSON(message: Timestamp): unknown {\n    const obj: any = {};\n    message.seconds !== undefined &&\n      (obj.seconds = (message.seconds || Long.ZERO).toString());\n    message.nanos !== undefined && (obj.nanos = Math.round(message.nanos));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Timestamp>, I>>(\n    object: I\n  ): Timestamp {\n    const message = createBaseTimestamp();\n    message.seconds =\n      object.seconds !== undefined && object.seconds !== null\n        ? Long.fromValue(object.seconds)\n        : Long.ZERO;\n    message.nanos = object.nanos ?? 0;\n    return message;\n  },\n};\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Any } from \"../../../google/protobuf/any\";\nimport { Timestamp } from \"../../../google/protobuf/timestamp\";\n\nexport const protobufPackage = \"cosmos.authz.v1beta1\";\n\n/** Since: cosmos-sdk 0.43 */\n\n/**\n * GenericAuthorization gives the grantee unrestricted permissions to execute\n * the provided method on behalf of the granter's account.\n */\nexport interface GenericAuthorization {\n  /** Msg, identified by it's type URL, to grant unrestricted permissions to execute */\n  msg: string;\n}\n\n/**\n * Grant gives permissions to execute\n * the provide method with expiration time.\n */\nexport interface Grant {\n  authorization?: Any;\n  expiration?: Date;\n}\n\n/**\n * GrantAuthorization extends a grant with both the addresses of the grantee and granter.\n * It is used in genesis.proto and query.proto\n *\n * Since: cosmos-sdk 0.45.2\n */\nexport interface GrantAuthorization {\n  granter: string;\n  grantee: string;\n  authorization?: Any;\n  expiration?: Date;\n}\n\nfunction createBaseGenericAuthorization(): GenericAuthorization {\n  return { msg: \"\" };\n}\n\nexport const GenericAuthorization = {\n  encode(\n    message: GenericAuthorization,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.msg !== \"\") {\n      writer.uint32(10).string(message.msg);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): GenericAuthorization {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseGenericAuthorization();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.msg = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): GenericAuthorization {\n    return {\n      msg: isSet(object.msg) ? String(object.msg) : \"\",\n    };\n  },\n\n  toJSON(message: GenericAuthorization): unknown {\n    const obj: any = {};\n    message.msg !== undefined && (obj.msg = message.msg);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<GenericAuthorization>, I>>(\n    object: I\n  ): GenericAuthorization {\n    const message = createBaseGenericAuthorization();\n    message.msg = object.msg ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseGrant(): Grant {\n  return { authorization: undefined, expiration: undefined };\n}\n\nexport const Grant = {\n  encode(message: Grant, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (message.authorization !== undefined) {\n      Any.encode(message.authorization, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.expiration !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.expiration),\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Grant {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseGrant();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.authorization = Any.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.expiration = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Grant {\n    return {\n      authorization: isSet(object.authorization)\n        ? Any.fromJSON(object.authorization)\n        : undefined,\n      expiration: isSet(object.expiration)\n        ? fromJsonTimestamp(object.expiration)\n        : undefined,\n    };\n  },\n\n  toJSON(message: Grant): unknown {\n    const obj: any = {};\n    message.authorization !== undefined &&\n      (obj.authorization = message.authorization\n        ? Any.toJSON(message.authorization)\n        : undefined);\n    message.expiration !== undefined &&\n      (obj.expiration = message.expiration.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Grant>, I>>(object: I): Grant {\n    const message = createBaseGrant();\n    message.authorization =\n      object.authorization !== undefined && object.authorization !== null\n        ? Any.fromPartial(object.authorization)\n        : undefined;\n    message.expiration = object.expiration ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseGrantAuthorization(): GrantAuthorization {\n  return {\n    granter: \"\",\n    grantee: \"\",\n    authorization: undefined,\n    expiration: undefined,\n  };\n}\n\nexport const GrantAuthorization = {\n  encode(\n    message: GrantAuthorization,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.granter !== \"\") {\n      writer.uint32(10).string(message.granter);\n    }\n    if (message.grantee !== \"\") {\n      writer.uint32(18).string(message.grantee);\n    }\n    if (message.authorization !== undefined) {\n      Any.encode(message.authorization, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.expiration !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.expiration),\n        writer.uint32(34).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): GrantAuthorization {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseGrantAuthorization();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.granter = reader.string();\n          break;\n        case 2:\n          message.grantee = reader.string();\n          break;\n        case 3:\n          message.authorization = Any.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.expiration = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): GrantAuthorization {\n    return {\n      granter: isSet(object.granter) ? String(object.granter) : \"\",\n      grantee: isSet(object.grantee) ? String(object.grantee) : \"\",\n      authorization: isSet(object.authorization)\n        ? Any.fromJSON(object.authorization)\n        : undefined,\n      expiration: isSet(object.expiration)\n        ? fromJsonTimestamp(object.expiration)\n        : undefined,\n    };\n  },\n\n  toJSON(message: GrantAuthorization): unknown {\n    const obj: any = {};\n    message.granter !== undefined && (obj.granter = message.granter);\n    message.grantee !== undefined && (obj.grantee = message.grantee);\n    message.authorization !== undefined &&\n      (obj.authorization = message.authorization\n        ? Any.toJSON(message.authorization)\n        : undefined);\n    message.expiration !== undefined &&\n      (obj.expiration = message.expiration.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<GrantAuthorization>, I>>(\n    object: I\n  ): GrantAuthorization {\n    const message = createBaseGrantAuthorization();\n    message.granter = object.granter ?? \"\";\n    message.grantee = object.grantee ?? \"\";\n    message.authorization =\n      object.authorization !== undefined && object.authorization !== null\n        ? Any.fromPartial(object.authorization)\n        : undefined;\n    message.expiration = object.expiration ?? undefined;\n    return message;\n  },\n};\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nfunction toTimestamp(date: Date): Timestamp {\n  const seconds = numberToLong(date.getTime() / 1_000);\n  const nanos = (date.getTime() % 1_000) * 1_000_000;\n  return { seconds, nanos };\n}\n\nfunction fromTimestamp(t: Timestamp): Date {\n  let millis = t.seconds.toNumber() * 1_000;\n  millis += t.nanos / 1_000_000;\n  return new Date(millis);\n}\n\nfunction fromJsonTimestamp(o: any): Date {\n  if (o instanceof Date) {\n    return o;\n  } else if (typeof o === \"string\") {\n    return new Date(o);\n  } else {\n    return fromTimestamp(Timestamp.fromJSON(o));\n  }\n}\n\nfunction numberToLong(number: number) {\n  return Long.fromNumber(number);\n}\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport { grpc } from \"@improbable-eng/grpc-web\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Grant } from \"./authz\";\nimport { BrowserHeaders } from \"browser-headers\";\nimport { Any } from \"../../../google/protobuf/any\";\n\nexport const protobufPackage = \"cosmos.authz.v1beta1\";\n\n/** Since: cosmos-sdk 0.43 */\n\n/**\n * MsgGrant is a request type for Grant method. It declares authorization to the grantee\n * on behalf of the granter with the provided expiration time.\n */\nexport interface MsgGrant {\n  granter: string;\n  grantee: string;\n  grant?: Grant;\n}\n\n/** MsgExecResponse defines the Msg/MsgExecResponse response type. */\nexport interface MsgExecResponse {\n  results: Uint8Array[];\n}\n\n/**\n * MsgExec attempts to execute the provided messages using\n * authorizations granted to the grantee. Each message should have only\n * one signer corresponding to the granter of the authorization.\n */\nexport interface MsgExec {\n  grantee: string;\n  /**\n   * Authorization Msg requests to execute. Each msg must implement Authorization interface\n   * The x/authz will try to find a grant matching (msg.signers[0], grantee, MsgTypeURL(msg))\n   * triple and validate it.\n   */\n  msgs: Any[];\n}\n\n/** MsgGrantResponse defines the Msg/MsgGrant response type. */\nexport interface MsgGrantResponse {}\n\n/**\n * MsgRevoke revokes any authorization with the provided sdk.Msg type on the\n * granter's account with that has been granted to the grantee.\n */\nexport interface MsgRevoke {\n  granter: string;\n  grantee: string;\n  msgTypeUrl: string;\n}\n\n/** MsgRevokeResponse defines the Msg/MsgRevokeResponse response type. */\nexport interface MsgRevokeResponse {}\n\nfunction createBaseMsgGrant(): MsgGrant {\n  return { granter: \"\", grantee: \"\", grant: undefined };\n}\n\nexport const MsgGrant = {\n  encode(\n    message: MsgGrant,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.granter !== \"\") {\n      writer.uint32(10).string(message.granter);\n    }\n    if (message.grantee !== \"\") {\n      writer.uint32(18).string(message.grantee);\n    }\n    if (message.grant !== undefined) {\n      Grant.encode(message.grant, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgGrant {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgGrant();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.granter = reader.string();\n          break;\n        case 2:\n          message.grantee = reader.string();\n          break;\n        case 3:\n          message.grant = Grant.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgGrant {\n    return {\n      granter: isSet(object.granter) ? String(object.granter) : \"\",\n      grantee: isSet(object.grantee) ? String(object.grantee) : \"\",\n      grant: isSet(object.grant) ? Grant.fromJSON(object.grant) : undefined,\n    };\n  },\n\n  toJSON(message: MsgGrant): unknown {\n    const obj: any = {};\n    message.granter !== undefined && (obj.granter = message.granter);\n    message.grantee !== undefined && (obj.grantee = message.grantee);\n    message.grant !== undefined &&\n      (obj.grant = message.grant ? Grant.toJSON(message.grant) : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgGrant>, I>>(object: I): MsgGrant {\n    const message = createBaseMsgGrant();\n    message.granter = object.granter ?? \"\";\n    message.grantee = object.grantee ?? \"\";\n    message.grant =\n      object.grant !== undefined && object.grant !== null\n        ? Grant.fromPartial(object.grant)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgExecResponse(): MsgExecResponse {\n  return { results: [] };\n}\n\nexport const MsgExecResponse = {\n  encode(\n    message: MsgExecResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.results) {\n      writer.uint32(10).bytes(v!);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgExecResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgExecResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.results.push(reader.bytes());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgExecResponse {\n    return {\n      results: Array.isArray(object?.results)\n        ? object.results.map((e: any) => bytesFromBase64(e))\n        : [],\n    };\n  },\n\n  toJSON(message: MsgExecResponse): unknown {\n    const obj: any = {};\n    if (message.results) {\n      obj.results = message.results.map((e) =>\n        base64FromBytes(e !== undefined ? e : new Uint8Array())\n      );\n    } else {\n      obj.results = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgExecResponse>, I>>(\n    object: I\n  ): MsgExecResponse {\n    const message = createBaseMsgExecResponse();\n    message.results = object.results?.map((e) => e) || [];\n    return message;\n  },\n};\n\nfunction createBaseMsgExec(): MsgExec {\n  return { grantee: \"\", msgs: [] };\n}\n\nexport const MsgExec = {\n  encode(\n    message: MsgExec,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.grantee !== \"\") {\n      writer.uint32(10).string(message.grantee);\n    }\n    for (const v of message.msgs) {\n      Any.encode(v!, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgExec {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgExec();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.grantee = reader.string();\n          break;\n        case 2:\n          message.msgs.push(Any.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgExec {\n    return {\n      grantee: isSet(object.grantee) ? String(object.grantee) : \"\",\n      msgs: Array.isArray(object?.msgs)\n        ? object.msgs.map((e: any) => Any.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: MsgExec): unknown {\n    const obj: any = {};\n    message.grantee !== undefined && (obj.grantee = message.grantee);\n    if (message.msgs) {\n      obj.msgs = message.msgs.map((e) => (e ? Any.toJSON(e) : undefined));\n    } else {\n      obj.msgs = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgExec>, I>>(object: I): MsgExec {\n    const message = createBaseMsgExec();\n    message.grantee = object.grantee ?? \"\";\n    message.msgs = object.msgs?.map((e) => Any.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseMsgGrantResponse(): MsgGrantResponse {\n  return {};\n}\n\nexport const MsgGrantResponse = {\n  encode(\n    _: MsgGrantResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgGrantResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgGrantResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgGrantResponse {\n    return {};\n  },\n\n  toJSON(_: MsgGrantResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgGrantResponse>, I>>(\n    _: I\n  ): MsgGrantResponse {\n    const message = createBaseMsgGrantResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgRevoke(): MsgRevoke {\n  return { granter: \"\", grantee: \"\", msgTypeUrl: \"\" };\n}\n\nexport const MsgRevoke = {\n  encode(\n    message: MsgRevoke,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.granter !== \"\") {\n      writer.uint32(10).string(message.granter);\n    }\n    if (message.grantee !== \"\") {\n      writer.uint32(18).string(message.grantee);\n    }\n    if (message.msgTypeUrl !== \"\") {\n      writer.uint32(26).string(message.msgTypeUrl);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgRevoke {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgRevoke();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.granter = reader.string();\n          break;\n        case 2:\n          message.grantee = reader.string();\n          break;\n        case 3:\n          message.msgTypeUrl = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgRevoke {\n    return {\n      granter: isSet(object.granter) ? String(object.granter) : \"\",\n      grantee: isSet(object.grantee) ? String(object.grantee) : \"\",\n      msgTypeUrl: isSet(object.msgTypeUrl) ? String(object.msgTypeUrl) : \"\",\n    };\n  },\n\n  toJSON(message: MsgRevoke): unknown {\n    const obj: any = {};\n    message.granter !== undefined && (obj.granter = message.granter);\n    message.grantee !== undefined && (obj.grantee = message.grantee);\n    message.msgTypeUrl !== undefined && (obj.msgTypeUrl = message.msgTypeUrl);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgRevoke>, I>>(\n    object: I\n  ): MsgRevoke {\n    const message = createBaseMsgRevoke();\n    message.granter = object.granter ?? \"\";\n    message.grantee = object.grantee ?? \"\";\n    message.msgTypeUrl = object.msgTypeUrl ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgRevokeResponse(): MsgRevokeResponse {\n  return {};\n}\n\nexport const MsgRevokeResponse = {\n  encode(\n    _: MsgRevokeResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgRevokeResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgRevokeResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgRevokeResponse {\n    return {};\n  },\n\n  toJSON(_: MsgRevokeResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgRevokeResponse>, I>>(\n    _: I\n  ): MsgRevokeResponse {\n    const message = createBaseMsgRevokeResponse();\n    return message;\n  },\n};\n\n/** Msg defines the authz Msg service. */\nexport interface Msg {\n  /**\n   * Grant grants the provided authorization to the grantee on the granter's\n   * account with the provided expiration time. If there is already a grant\n   * for the given (granter, grantee, Authorization) triple, then the grant\n   * will be overwritten.\n   */\n  Grant(\n    request: DeepPartial<MsgGrant>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgGrantResponse>;\n  /**\n   * Exec attempts to execute the provided messages using\n   * authorizations granted to the grantee. Each message should have only\n   * one signer corresponding to the granter of the authorization.\n   */\n  Exec(\n    request: DeepPartial<MsgExec>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgExecResponse>;\n  /**\n   * Revoke revokes any authorization corresponding to the provided method name on the\n   * granter's account that has been granted to the grantee.\n   */\n  Revoke(\n    request: DeepPartial<MsgRevoke>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgRevokeResponse>;\n}\n\nexport class MsgClientImpl implements Msg {\n  private readonly rpc: Rpc;\n\n  constructor(rpc: Rpc) {\n    this.rpc = rpc;\n    this.Grant = this.Grant.bind(this);\n    this.Exec = this.Exec.bind(this);\n    this.Revoke = this.Revoke.bind(this);\n  }\n\n  Grant(\n    request: DeepPartial<MsgGrant>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgGrantResponse> {\n    return this.rpc.unary(\n      MsgGrantDesc,\n      MsgGrant.fromPartial(request),\n      metadata\n    );\n  }\n\n  Exec(\n    request: DeepPartial<MsgExec>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgExecResponse> {\n    return this.rpc.unary(MsgExecDesc, MsgExec.fromPartial(request), metadata);\n  }\n\n  Revoke(\n    request: DeepPartial<MsgRevoke>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgRevokeResponse> {\n    return this.rpc.unary(\n      MsgRevokeDesc,\n      MsgRevoke.fromPartial(request),\n      metadata\n    );\n  }\n}\n\nexport const MsgDesc = {\n  serviceName: \"cosmos.authz.v1beta1.Msg\",\n};\n\nexport const MsgGrantDesc: UnaryMethodDefinitionish = {\n  methodName: \"Grant\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgGrant.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgGrantResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgExecDesc: UnaryMethodDefinitionish = {\n  methodName: \"Exec\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgExec.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgExecResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgRevokeDesc: UnaryMethodDefinitionish = {\n  methodName: \"Revoke\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgRevoke.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgRevokeResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\ninterface UnaryMethodDefinitionishR\n  extends grpc.UnaryMethodDefinition<any, any> {\n  requestStream: any;\n  responseStream: any;\n}\n\ntype UnaryMethodDefinitionish = UnaryMethodDefinitionishR;\n\ninterface Rpc {\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any>;\n}\n\nexport class GrpcWebImpl {\n  private host: string;\n  private options: {\n    transport?: grpc.TransportFactory;\n\n    debug?: boolean;\n    metadata?: grpc.Metadata;\n  };\n\n  constructor(\n    host: string,\n    options: {\n      transport?: grpc.TransportFactory;\n\n      debug?: boolean;\n      metadata?: grpc.Metadata;\n    }\n  ) {\n    this.host = host;\n    this.options = options;\n  }\n\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    _request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any> {\n    const request = { ..._request, ...methodDesc.requestType };\n    const maybeCombinedMetadata =\n      metadata && this.options.metadata\n        ? new BrowserHeaders({\n            ...this.options?.metadata.headersMap,\n            ...metadata?.headersMap,\n          })\n        : metadata || this.options.metadata;\n    return new Promise((resolve, reject) => {\n      grpc.unary(methodDesc, {\n        request,\n        host: this.host,\n        metadata: maybeCombinedMetadata,\n        transport: this.options.transport,\n        debug: this.options.debug,\n        onEnd: function (response) {\n          if (response.status === grpc.Code.OK) {\n            resolve(response.message);\n          } else {\n            const err = new Error(response.statusMessage) as any;\n            err.code = response.status;\n            err.metadata = response.trailers;\n            reject(err);\n          }\n        },\n      });\n    });\n  }\n}\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","import { BaseMsg } from \"../BaseMsg\";\nimport { EncodeObject } from \"@cosmjs/proto-signing\";\nimport {\n  protobufPackage,\n  MsgGrant as MsgGrant_pb,\n  MsgExec as MsgExec_pb,\n  MsgRevoke as MsgRevoke_pb,\n} from \"../../proto/cosmos/authz/v1beta1/tx\";\n\nexport class MsgGrant extends BaseMsg {\n  public protoMsg: MsgGrant_pb;\n  constructor(msg: MsgGrant_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgGrant.typeUrl,\n      value: MsgGrant_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgGrant {\n  export const typeUrl: string = `/${protobufPackage}.MsgGrant`;\n  export const Proto = MsgGrant_pb;\n  export interface Proto extends MsgGrant_pb {}\n}\n\nexport class MsgExec extends BaseMsg {\n  public protoMsg: MsgExec_pb;\n  constructor(msg: MsgExec_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgExec.typeUrl,\n      value: MsgExec_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgExec {\n  export const typeUrl: string = `/${protobufPackage}.MsgExec`;\n  export const Proto = MsgExec_pb;\n  export interface Proto extends MsgExec_pb {}\n}\n\nexport class MsgRevoke extends BaseMsg {\n  public protoMsg: MsgRevoke_pb;\n  constructor(msg: MsgRevoke_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgExec.typeUrl,\n      value: MsgRevoke_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgRevoke {\n  export const typeUrl: string = `/${protobufPackage}.MsgRevoke`;\n  export const Proto = MsgRevoke_pb;\n  export interface Proto extends MsgRevoke_pb {}\n}\n\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"cosmos.base.v1beta1\";\n\n/**\n * Coin defines a token with a denomination and an amount.\n *\n * NOTE: The amount field is an Int which implements the custom method\n * signatures required by gogoproto.\n */\nexport interface Coin {\n  denom: string;\n  amount: string;\n}\n\n/**\n * DecCoin defines a token with a denomination and a decimal amount.\n *\n * NOTE: The amount field is an Dec which implements the custom method\n * signatures required by gogoproto.\n */\nexport interface DecCoin {\n  denom: string;\n  amount: string;\n}\n\n/** IntProto defines a Protobuf wrapper around an Int object. */\nexport interface IntProto {\n  int: string;\n}\n\n/** DecProto defines a Protobuf wrapper around a Dec object. */\nexport interface DecProto {\n  dec: string;\n}\n\nfunction createBaseCoin(): Coin {\n  return { denom: \"\", amount: \"\" };\n}\n\nexport const Coin = {\n  encode(message: Coin, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (message.denom !== \"\") {\n      writer.uint32(10).string(message.denom);\n    }\n    if (message.amount !== \"\") {\n      writer.uint32(18).string(message.amount);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Coin {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseCoin();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.denom = reader.string();\n          break;\n        case 2:\n          message.amount = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Coin {\n    return {\n      denom: isSet(object.denom) ? String(object.denom) : \"\",\n      amount: isSet(object.amount) ? String(object.amount) : \"\",\n    };\n  },\n\n  toJSON(message: Coin): unknown {\n    const obj: any = {};\n    message.denom !== undefined && (obj.denom = message.denom);\n    message.amount !== undefined && (obj.amount = message.amount);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Coin>, I>>(object: I): Coin {\n    const message = createBaseCoin();\n    message.denom = object.denom ?? \"\";\n    message.amount = object.amount ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseDecCoin(): DecCoin {\n  return { denom: \"\", amount: \"\" };\n}\n\nexport const DecCoin = {\n  encode(\n    message: DecCoin,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.denom !== \"\") {\n      writer.uint32(10).string(message.denom);\n    }\n    if (message.amount !== \"\") {\n      writer.uint32(18).string(message.amount);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): DecCoin {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDecCoin();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.denom = reader.string();\n          break;\n        case 2:\n          message.amount = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): DecCoin {\n    return {\n      denom: isSet(object.denom) ? String(object.denom) : \"\",\n      amount: isSet(object.amount) ? String(object.amount) : \"\",\n    };\n  },\n\n  toJSON(message: DecCoin): unknown {\n    const obj: any = {};\n    message.denom !== undefined && (obj.denom = message.denom);\n    message.amount !== undefined && (obj.amount = message.amount);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<DecCoin>, I>>(object: I): DecCoin {\n    const message = createBaseDecCoin();\n    message.denom = object.denom ?? \"\";\n    message.amount = object.amount ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseIntProto(): IntProto {\n  return { int: \"\" };\n}\n\nexport const IntProto = {\n  encode(\n    message: IntProto,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.int !== \"\") {\n      writer.uint32(10).string(message.int);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): IntProto {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseIntProto();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.int = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): IntProto {\n    return {\n      int: isSet(object.int) ? String(object.int) : \"\",\n    };\n  },\n\n  toJSON(message: IntProto): unknown {\n    const obj: any = {};\n    message.int !== undefined && (obj.int = message.int);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<IntProto>, I>>(object: I): IntProto {\n    const message = createBaseIntProto();\n    message.int = object.int ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseDecProto(): DecProto {\n  return { dec: \"\" };\n}\n\nexport const DecProto = {\n  encode(\n    message: DecProto,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.dec !== \"\") {\n      writer.uint32(10).string(message.dec);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): DecProto {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDecProto();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.dec = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): DecProto {\n    return {\n      dec: isSet(object.dec) ? String(object.dec) : \"\",\n    };\n  },\n\n  toJSON(message: DecProto): unknown {\n    const obj: any = {};\n    message.dec !== undefined && (obj.dec = message.dec);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<DecProto>, I>>(object: I): DecProto {\n    const message = createBaseDecProto();\n    message.dec = object.dec ?? \"\";\n    return message;\n  },\n};\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Coin } from \"../../base/v1beta1/coin\";\n\nexport const protobufPackage = \"cosmos.bank.v1beta1\";\n\n/** Params defines the parameters for the bank module. */\nexport interface Params {\n  sendEnabled: SendEnabled[];\n  defaultSendEnabled: boolean;\n}\n\n/**\n * SendEnabled maps coin denom to a send_enabled status (whether a denom is\n * sendable).\n */\nexport interface SendEnabled {\n  denom: string;\n  enabled: boolean;\n}\n\n/** Input models transaction input. */\nexport interface Input {\n  address: string;\n  coins: Coin[];\n}\n\n/** Output models transaction outputs. */\nexport interface Output {\n  address: string;\n  coins: Coin[];\n}\n\n/**\n * Supply represents a struct that passively keeps track of the total supply\n * amounts in the network.\n * This message is deprecated now that supply is indexed by denom.\n *\n * @deprecated\n */\nexport interface Supply {\n  total: Coin[];\n}\n\n/**\n * DenomUnit represents a struct that describes a given\n * denomination unit of the basic token.\n */\nexport interface DenomUnit {\n  /** denom represents the string name of the given denom unit (e.g uatom). */\n  denom: string;\n  /**\n   * exponent represents power of 10 exponent that one must\n   * raise the base_denom to in order to equal the given DenomUnit's denom\n   * 1 denom = 1^exponent base_denom\n   * (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with\n   * exponent = 6, thus: 1 atom = 10^6 uatom).\n   */\n  exponent: number;\n  /** aliases is a list of string aliases for the given denom */\n  aliases: string[];\n}\n\n/**\n * Metadata represents a struct that describes\n * a basic token.\n */\nexport interface Metadata {\n  description: string;\n  /** denom_units represents the list of DenomUnit's for a given coin */\n  denomUnits: DenomUnit[];\n  /** base represents the base denom (should be the DenomUnit with exponent = 0). */\n  base: string;\n  /**\n   * display indicates the suggested denom that should be\n   * displayed in clients.\n   */\n  display: string;\n  /**\n   * name defines the name of the token (eg: Cosmos Atom)\n   *\n   * Since: cosmos-sdk 0.43\n   */\n  name: string;\n  /**\n   * symbol is the token symbol usually shown on exchanges (eg: ATOM). This can\n   * be the same as the display.\n   *\n   * Since: cosmos-sdk 0.43\n   */\n  symbol: string;\n}\n\nfunction createBaseParams(): Params {\n  return { sendEnabled: [], defaultSendEnabled: false };\n}\n\nexport const Params = {\n  encode(\n    message: Params,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.sendEnabled) {\n      SendEnabled.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.defaultSendEnabled === true) {\n      writer.uint32(16).bool(message.defaultSendEnabled);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Params {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseParams();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.sendEnabled.push(SendEnabled.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.defaultSendEnabled = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Params {\n    return {\n      sendEnabled: Array.isArray(object?.sendEnabled)\n        ? object.sendEnabled.map((e: any) => SendEnabled.fromJSON(e))\n        : [],\n      defaultSendEnabled: isSet(object.defaultSendEnabled)\n        ? Boolean(object.defaultSendEnabled)\n        : false,\n    };\n  },\n\n  toJSON(message: Params): unknown {\n    const obj: any = {};\n    if (message.sendEnabled) {\n      obj.sendEnabled = message.sendEnabled.map((e) =>\n        e ? SendEnabled.toJSON(e) : undefined\n      );\n    } else {\n      obj.sendEnabled = [];\n    }\n    message.defaultSendEnabled !== undefined &&\n      (obj.defaultSendEnabled = message.defaultSendEnabled);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Params>, I>>(object: I): Params {\n    const message = createBaseParams();\n    message.sendEnabled =\n      object.sendEnabled?.map((e) => SendEnabled.fromPartial(e)) || [];\n    message.defaultSendEnabled = object.defaultSendEnabled ?? false;\n    return message;\n  },\n};\n\nfunction createBaseSendEnabled(): SendEnabled {\n  return { denom: \"\", enabled: false };\n}\n\nexport const SendEnabled = {\n  encode(\n    message: SendEnabled,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.denom !== \"\") {\n      writer.uint32(10).string(message.denom);\n    }\n    if (message.enabled === true) {\n      writer.uint32(16).bool(message.enabled);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): SendEnabled {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSendEnabled();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.denom = reader.string();\n          break;\n        case 2:\n          message.enabled = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SendEnabled {\n    return {\n      denom: isSet(object.denom) ? String(object.denom) : \"\",\n      enabled: isSet(object.enabled) ? Boolean(object.enabled) : false,\n    };\n  },\n\n  toJSON(message: SendEnabled): unknown {\n    const obj: any = {};\n    message.denom !== undefined && (obj.denom = message.denom);\n    message.enabled !== undefined && (obj.enabled = message.enabled);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SendEnabled>, I>>(\n    object: I\n  ): SendEnabled {\n    const message = createBaseSendEnabled();\n    message.denom = object.denom ?? \"\";\n    message.enabled = object.enabled ?? false;\n    return message;\n  },\n};\n\nfunction createBaseInput(): Input {\n  return { address: \"\", coins: [] };\n}\n\nexport const Input = {\n  encode(message: Input, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (message.address !== \"\") {\n      writer.uint32(10).string(message.address);\n    }\n    for (const v of message.coins) {\n      Coin.encode(v!, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Input {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseInput();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.address = reader.string();\n          break;\n        case 2:\n          message.coins.push(Coin.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Input {\n    return {\n      address: isSet(object.address) ? String(object.address) : \"\",\n      coins: Array.isArray(object?.coins)\n        ? object.coins.map((e: any) => Coin.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: Input): unknown {\n    const obj: any = {};\n    message.address !== undefined && (obj.address = message.address);\n    if (message.coins) {\n      obj.coins = message.coins.map((e) => (e ? Coin.toJSON(e) : undefined));\n    } else {\n      obj.coins = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Input>, I>>(object: I): Input {\n    const message = createBaseInput();\n    message.address = object.address ?? \"\";\n    message.coins = object.coins?.map((e) => Coin.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseOutput(): Output {\n  return { address: \"\", coins: [] };\n}\n\nexport const Output = {\n  encode(\n    message: Output,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.address !== \"\") {\n      writer.uint32(10).string(message.address);\n    }\n    for (const v of message.coins) {\n      Coin.encode(v!, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Output {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseOutput();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.address = reader.string();\n          break;\n        case 2:\n          message.coins.push(Coin.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Output {\n    return {\n      address: isSet(object.address) ? String(object.address) : \"\",\n      coins: Array.isArray(object?.coins)\n        ? object.coins.map((e: any) => Coin.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: Output): unknown {\n    const obj: any = {};\n    message.address !== undefined && (obj.address = message.address);\n    if (message.coins) {\n      obj.coins = message.coins.map((e) => (e ? Coin.toJSON(e) : undefined));\n    } else {\n      obj.coins = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Output>, I>>(object: I): Output {\n    const message = createBaseOutput();\n    message.address = object.address ?? \"\";\n    message.coins = object.coins?.map((e) => Coin.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseSupply(): Supply {\n  return { total: [] };\n}\n\nexport const Supply = {\n  encode(\n    message: Supply,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.total) {\n      Coin.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Supply {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSupply();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.total.push(Coin.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Supply {\n    return {\n      total: Array.isArray(object?.total)\n        ? object.total.map((e: any) => Coin.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: Supply): unknown {\n    const obj: any = {};\n    if (message.total) {\n      obj.total = message.total.map((e) => (e ? Coin.toJSON(e) : undefined));\n    } else {\n      obj.total = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Supply>, I>>(object: I): Supply {\n    const message = createBaseSupply();\n    message.total = object.total?.map((e) => Coin.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseDenomUnit(): DenomUnit {\n  return { denom: \"\", exponent: 0, aliases: [] };\n}\n\nexport const DenomUnit = {\n  encode(\n    message: DenomUnit,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.denom !== \"\") {\n      writer.uint32(10).string(message.denom);\n    }\n    if (message.exponent !== 0) {\n      writer.uint32(16).uint32(message.exponent);\n    }\n    for (const v of message.aliases) {\n      writer.uint32(26).string(v!);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): DenomUnit {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDenomUnit();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.denom = reader.string();\n          break;\n        case 2:\n          message.exponent = reader.uint32();\n          break;\n        case 3:\n          message.aliases.push(reader.string());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): DenomUnit {\n    return {\n      denom: isSet(object.denom) ? String(object.denom) : \"\",\n      exponent: isSet(object.exponent) ? Number(object.exponent) : 0,\n      aliases: Array.isArray(object?.aliases)\n        ? object.aliases.map((e: any) => String(e))\n        : [],\n    };\n  },\n\n  toJSON(message: DenomUnit): unknown {\n    const obj: any = {};\n    message.denom !== undefined && (obj.denom = message.denom);\n    message.exponent !== undefined &&\n      (obj.exponent = Math.round(message.exponent));\n    if (message.aliases) {\n      obj.aliases = message.aliases.map((e) => e);\n    } else {\n      obj.aliases = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<DenomUnit>, I>>(\n    object: I\n  ): DenomUnit {\n    const message = createBaseDenomUnit();\n    message.denom = object.denom ?? \"\";\n    message.exponent = object.exponent ?? 0;\n    message.aliases = object.aliases?.map((e) => e) || [];\n    return message;\n  },\n};\n\nfunction createBaseMetadata(): Metadata {\n  return {\n    description: \"\",\n    denomUnits: [],\n    base: \"\",\n    display: \"\",\n    name: \"\",\n    symbol: \"\",\n  };\n}\n\nexport const Metadata = {\n  encode(\n    message: Metadata,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.description !== \"\") {\n      writer.uint32(10).string(message.description);\n    }\n    for (const v of message.denomUnits) {\n      DenomUnit.encode(v!, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.base !== \"\") {\n      writer.uint32(26).string(message.base);\n    }\n    if (message.display !== \"\") {\n      writer.uint32(34).string(message.display);\n    }\n    if (message.name !== \"\") {\n      writer.uint32(42).string(message.name);\n    }\n    if (message.symbol !== \"\") {\n      writer.uint32(50).string(message.symbol);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Metadata {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMetadata();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.description = reader.string();\n          break;\n        case 2:\n          message.denomUnits.push(DenomUnit.decode(reader, reader.uint32()));\n          break;\n        case 3:\n          message.base = reader.string();\n          break;\n        case 4:\n          message.display = reader.string();\n          break;\n        case 5:\n          message.name = reader.string();\n          break;\n        case 6:\n          message.symbol = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Metadata {\n    return {\n      description: isSet(object.description) ? String(object.description) : \"\",\n      denomUnits: Array.isArray(object?.denomUnits)\n        ? object.denomUnits.map((e: any) => DenomUnit.fromJSON(e))\n        : [],\n      base: isSet(object.base) ? String(object.base) : \"\",\n      display: isSet(object.display) ? String(object.display) : \"\",\n      name: isSet(object.name) ? String(object.name) : \"\",\n      symbol: isSet(object.symbol) ? String(object.symbol) : \"\",\n    };\n  },\n\n  toJSON(message: Metadata): unknown {\n    const obj: any = {};\n    message.description !== undefined &&\n      (obj.description = message.description);\n    if (message.denomUnits) {\n      obj.denomUnits = message.denomUnits.map((e) =>\n        e ? DenomUnit.toJSON(e) : undefined\n      );\n    } else {\n      obj.denomUnits = [];\n    }\n    message.base !== undefined && (obj.base = message.base);\n    message.display !== undefined && (obj.display = message.display);\n    message.name !== undefined && (obj.name = message.name);\n    message.symbol !== undefined && (obj.symbol = message.symbol);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Metadata>, I>>(object: I): Metadata {\n    const message = createBaseMetadata();\n    message.description = object.description ?? \"\";\n    message.denomUnits =\n      object.denomUnits?.map((e) => DenomUnit.fromPartial(e)) || [];\n    message.base = object.base ?? \"\";\n    message.display = object.display ?? \"\";\n    message.name = object.name ?? \"\";\n    message.symbol = object.symbol ?? \"\";\n    return message;\n  },\n};\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport { grpc } from \"@improbable-eng/grpc-web\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { BrowserHeaders } from \"browser-headers\";\nimport { Coin } from \"../../base/v1beta1/coin\";\nimport { Input, Output } from \"./bank\";\n\nexport const protobufPackage = \"cosmos.bank.v1beta1\";\n\n/** MsgSend represents a message to send coins from one account to another. */\nexport interface MsgSend {\n  fromAddress: string;\n  toAddress: string;\n  amount: Coin[];\n}\n\n/** MsgSendResponse defines the Msg/Send response type. */\nexport interface MsgSendResponse {}\n\n/** MsgMultiSend represents an arbitrary multi-in, multi-out send message. */\nexport interface MsgMultiSend {\n  inputs: Input[];\n  outputs: Output[];\n}\n\n/** MsgMultiSendResponse defines the Msg/MultiSend response type. */\nexport interface MsgMultiSendResponse {}\n\nfunction createBaseMsgSend(): MsgSend {\n  return { fromAddress: \"\", toAddress: \"\", amount: [] };\n}\n\nexport const MsgSend = {\n  encode(\n    message: MsgSend,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.fromAddress !== \"\") {\n      writer.uint32(10).string(message.fromAddress);\n    }\n    if (message.toAddress !== \"\") {\n      writer.uint32(18).string(message.toAddress);\n    }\n    for (const v of message.amount) {\n      Coin.encode(v!, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSend {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgSend();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.fromAddress = reader.string();\n          break;\n        case 2:\n          message.toAddress = reader.string();\n          break;\n        case 3:\n          message.amount.push(Coin.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgSend {\n    return {\n      fromAddress: isSet(object.fromAddress) ? String(object.fromAddress) : \"\",\n      toAddress: isSet(object.toAddress) ? String(object.toAddress) : \"\",\n      amount: Array.isArray(object?.amount)\n        ? object.amount.map((e: any) => Coin.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: MsgSend): unknown {\n    const obj: any = {};\n    message.fromAddress !== undefined &&\n      (obj.fromAddress = message.fromAddress);\n    message.toAddress !== undefined && (obj.toAddress = message.toAddress);\n    if (message.amount) {\n      obj.amount = message.amount.map((e) => (e ? Coin.toJSON(e) : undefined));\n    } else {\n      obj.amount = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgSend>, I>>(object: I): MsgSend {\n    const message = createBaseMsgSend();\n    message.fromAddress = object.fromAddress ?? \"\";\n    message.toAddress = object.toAddress ?? \"\";\n    message.amount = object.amount?.map((e) => Coin.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseMsgSendResponse(): MsgSendResponse {\n  return {};\n}\n\nexport const MsgSendResponse = {\n  encode(\n    _: MsgSendResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSendResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgSendResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgSendResponse {\n    return {};\n  },\n\n  toJSON(_: MsgSendResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgSendResponse>, I>>(\n    _: I\n  ): MsgSendResponse {\n    const message = createBaseMsgSendResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgMultiSend(): MsgMultiSend {\n  return { inputs: [], outputs: [] };\n}\n\nexport const MsgMultiSend = {\n  encode(\n    message: MsgMultiSend,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.inputs) {\n      Input.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    for (const v of message.outputs) {\n      Output.encode(v!, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgMultiSend {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgMultiSend();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.inputs.push(Input.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.outputs.push(Output.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgMultiSend {\n    return {\n      inputs: Array.isArray(object?.inputs)\n        ? object.inputs.map((e: any) => Input.fromJSON(e))\n        : [],\n      outputs: Array.isArray(object?.outputs)\n        ? object.outputs.map((e: any) => Output.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: MsgMultiSend): unknown {\n    const obj: any = {};\n    if (message.inputs) {\n      obj.inputs = message.inputs.map((e) => (e ? Input.toJSON(e) : undefined));\n    } else {\n      obj.inputs = [];\n    }\n    if (message.outputs) {\n      obj.outputs = message.outputs.map((e) =>\n        e ? Output.toJSON(e) : undefined\n      );\n    } else {\n      obj.outputs = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgMultiSend>, I>>(\n    object: I\n  ): MsgMultiSend {\n    const message = createBaseMsgMultiSend();\n    message.inputs = object.inputs?.map((e) => Input.fromPartial(e)) || [];\n    message.outputs = object.outputs?.map((e) => Output.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseMsgMultiSendResponse(): MsgMultiSendResponse {\n  return {};\n}\n\nexport const MsgMultiSendResponse = {\n  encode(\n    _: MsgMultiSendResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgMultiSendResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgMultiSendResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgMultiSendResponse {\n    return {};\n  },\n\n  toJSON(_: MsgMultiSendResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgMultiSendResponse>, I>>(\n    _: I\n  ): MsgMultiSendResponse {\n    const message = createBaseMsgMultiSendResponse();\n    return message;\n  },\n};\n\n/** Msg defines the bank Msg service. */\nexport interface Msg {\n  /** Send defines a method for sending coins from one account to another account. */\n  Send(\n    request: DeepPartial<MsgSend>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgSendResponse>;\n  /** MultiSend defines a method for sending coins from some accounts to other accounts. */\n  MultiSend(\n    request: DeepPartial<MsgMultiSend>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgMultiSendResponse>;\n}\n\nexport class MsgClientImpl implements Msg {\n  private readonly rpc: Rpc;\n\n  constructor(rpc: Rpc) {\n    this.rpc = rpc;\n    this.Send = this.Send.bind(this);\n    this.MultiSend = this.MultiSend.bind(this);\n  }\n\n  Send(\n    request: DeepPartial<MsgSend>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgSendResponse> {\n    return this.rpc.unary(MsgSendDesc, MsgSend.fromPartial(request), metadata);\n  }\n\n  MultiSend(\n    request: DeepPartial<MsgMultiSend>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgMultiSendResponse> {\n    return this.rpc.unary(\n      MsgMultiSendDesc,\n      MsgMultiSend.fromPartial(request),\n      metadata\n    );\n  }\n}\n\nexport const MsgDesc = {\n  serviceName: \"cosmos.bank.v1beta1.Msg\",\n};\n\nexport const MsgSendDesc: UnaryMethodDefinitionish = {\n  methodName: \"Send\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgSend.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgSendResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgMultiSendDesc: UnaryMethodDefinitionish = {\n  methodName: \"MultiSend\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgMultiSend.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgMultiSendResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\ninterface UnaryMethodDefinitionishR\n  extends grpc.UnaryMethodDefinition<any, any> {\n  requestStream: any;\n  responseStream: any;\n}\n\ntype UnaryMethodDefinitionish = UnaryMethodDefinitionishR;\n\ninterface Rpc {\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any>;\n}\n\nexport class GrpcWebImpl {\n  private host: string;\n  private options: {\n    transport?: grpc.TransportFactory;\n\n    debug?: boolean;\n    metadata?: grpc.Metadata;\n  };\n\n  constructor(\n    host: string,\n    options: {\n      transport?: grpc.TransportFactory;\n\n      debug?: boolean;\n      metadata?: grpc.Metadata;\n    }\n  ) {\n    this.host = host;\n    this.options = options;\n  }\n\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    _request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any> {\n    const request = { ..._request, ...methodDesc.requestType };\n    const maybeCombinedMetadata =\n      metadata && this.options.metadata\n        ? new BrowserHeaders({\n            ...this.options?.metadata.headersMap,\n            ...metadata?.headersMap,\n          })\n        : metadata || this.options.metadata;\n    return new Promise((resolve, reject) => {\n      grpc.unary(methodDesc, {\n        request,\n        host: this.host,\n        metadata: maybeCombinedMetadata,\n        transport: this.options.transport,\n        debug: this.options.debug,\n        onEnd: function (response) {\n          if (response.status === grpc.Code.OK) {\n            resolve(response.message);\n          } else {\n            const err = new Error(response.statusMessage) as any;\n            err.code = response.status;\n            err.metadata = response.trailers;\n            reject(err);\n          }\n        },\n      });\n    });\n  }\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","import { BaseMsg } from \"../BaseMsg\";\nimport { EncodeObject } from \"@cosmjs/proto-signing\";\nimport {\n  protobufPackage,\n  MsgSend as MsgSend_pb,\n  MsgMultiSend as MsgMultiSend_pb,\n} from \"../../proto/cosmos/bank/v1beta1/tx\";\n\nexport class MsgSend extends BaseMsg {\n  public protoMsg: MsgSend_pb;\n  constructor(msg: MsgSend_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgSend.typeUrl,\n      value: MsgSend_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgSend {\n  export const typeUrl: string = `/${protobufPackage}.MsgSend`;\n  export const Proto = MsgSend_pb;\n  export interface Proto extends MsgSend_pb {}\n}\n\nexport class MsgMultiSend extends BaseMsg {\n  public protoMsg: MsgMultiSend_pb;\n  constructor(msg: MsgMultiSend_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgMultiSend.typeUrl,\n      value: MsgMultiSend_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgMultiSend {\n  export const typeUrl: string = `/${protobufPackage}.MsgMultiSend`;\n  export const Proto = MsgMultiSend_pb;\n  export interface Proto extends MsgMultiSend_pb {}\n}\n\n\n","/* eslint-disable */\nimport Long from \"long\";\nimport { grpc } from \"@improbable-eng/grpc-web\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { BrowserHeaders } from \"browser-headers\";\n\nexport const protobufPackage = \"cosmos.crisis.v1beta1\";\n\n/** MsgVerifyInvariant represents a message to verify a particular invariance. */\nexport interface MsgVerifyInvariant {\n  sender: string;\n  invariantModuleName: string;\n  invariantRoute: string;\n}\n\n/** MsgVerifyInvariantResponse defines the Msg/VerifyInvariant response type. */\nexport interface MsgVerifyInvariantResponse {}\n\nfunction createBaseMsgVerifyInvariant(): MsgVerifyInvariant {\n  return { sender: \"\", invariantModuleName: \"\", invariantRoute: \"\" };\n}\n\nexport const MsgVerifyInvariant = {\n  encode(\n    message: MsgVerifyInvariant,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.sender !== \"\") {\n      writer.uint32(10).string(message.sender);\n    }\n    if (message.invariantModuleName !== \"\") {\n      writer.uint32(18).string(message.invariantModuleName);\n    }\n    if (message.invariantRoute !== \"\") {\n      writer.uint32(26).string(message.invariantRoute);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgVerifyInvariant {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgVerifyInvariant();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.sender = reader.string();\n          break;\n        case 2:\n          message.invariantModuleName = reader.string();\n          break;\n        case 3:\n          message.invariantRoute = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgVerifyInvariant {\n    return {\n      sender: isSet(object.sender) ? String(object.sender) : \"\",\n      invariantModuleName: isSet(object.invariantModuleName)\n        ? String(object.invariantModuleName)\n        : \"\",\n      invariantRoute: isSet(object.invariantRoute)\n        ? String(object.invariantRoute)\n        : \"\",\n    };\n  },\n\n  toJSON(message: MsgVerifyInvariant): unknown {\n    const obj: any = {};\n    message.sender !== undefined && (obj.sender = message.sender);\n    message.invariantModuleName !== undefined &&\n      (obj.invariantModuleName = message.invariantModuleName);\n    message.invariantRoute !== undefined &&\n      (obj.invariantRoute = message.invariantRoute);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgVerifyInvariant>, I>>(\n    object: I\n  ): MsgVerifyInvariant {\n    const message = createBaseMsgVerifyInvariant();\n    message.sender = object.sender ?? \"\";\n    message.invariantModuleName = object.invariantModuleName ?? \"\";\n    message.invariantRoute = object.invariantRoute ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgVerifyInvariantResponse(): MsgVerifyInvariantResponse {\n  return {};\n}\n\nexport const MsgVerifyInvariantResponse = {\n  encode(\n    _: MsgVerifyInvariantResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgVerifyInvariantResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgVerifyInvariantResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgVerifyInvariantResponse {\n    return {};\n  },\n\n  toJSON(_: MsgVerifyInvariantResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgVerifyInvariantResponse>, I>>(\n    _: I\n  ): MsgVerifyInvariantResponse {\n    const message = createBaseMsgVerifyInvariantResponse();\n    return message;\n  },\n};\n\n/** Msg defines the bank Msg service. */\nexport interface Msg {\n  /** VerifyInvariant defines a method to verify a particular invariance. */\n  VerifyInvariant(\n    request: DeepPartial<MsgVerifyInvariant>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgVerifyInvariantResponse>;\n}\n\nexport class MsgClientImpl implements Msg {\n  private readonly rpc: Rpc;\n\n  constructor(rpc: Rpc) {\n    this.rpc = rpc;\n    this.VerifyInvariant = this.VerifyInvariant.bind(this);\n  }\n\n  VerifyInvariant(\n    request: DeepPartial<MsgVerifyInvariant>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgVerifyInvariantResponse> {\n    return this.rpc.unary(\n      MsgVerifyInvariantDesc,\n      MsgVerifyInvariant.fromPartial(request),\n      metadata\n    );\n  }\n}\n\nexport const MsgDesc = {\n  serviceName: \"cosmos.crisis.v1beta1.Msg\",\n};\n\nexport const MsgVerifyInvariantDesc: UnaryMethodDefinitionish = {\n  methodName: \"VerifyInvariant\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgVerifyInvariant.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgVerifyInvariantResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\ninterface UnaryMethodDefinitionishR\n  extends grpc.UnaryMethodDefinition<any, any> {\n  requestStream: any;\n  responseStream: any;\n}\n\ntype UnaryMethodDefinitionish = UnaryMethodDefinitionishR;\n\ninterface Rpc {\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any>;\n}\n\nexport class GrpcWebImpl {\n  private host: string;\n  private options: {\n    transport?: grpc.TransportFactory;\n\n    debug?: boolean;\n    metadata?: grpc.Metadata;\n  };\n\n  constructor(\n    host: string,\n    options: {\n      transport?: grpc.TransportFactory;\n\n      debug?: boolean;\n      metadata?: grpc.Metadata;\n    }\n  ) {\n    this.host = host;\n    this.options = options;\n  }\n\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    _request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any> {\n    const request = { ..._request, ...methodDesc.requestType };\n    const maybeCombinedMetadata =\n      metadata && this.options.metadata\n        ? new BrowserHeaders({\n            ...this.options?.metadata.headersMap,\n            ...metadata?.headersMap,\n          })\n        : metadata || this.options.metadata;\n    return new Promise((resolve, reject) => {\n      grpc.unary(methodDesc, {\n        request,\n        host: this.host,\n        metadata: maybeCombinedMetadata,\n        transport: this.options.transport,\n        debug: this.options.debug,\n        onEnd: function (response) {\n          if (response.status === grpc.Code.OK) {\n            resolve(response.message);\n          } else {\n            const err = new Error(response.statusMessage) as any;\n            err.code = response.status;\n            err.metadata = response.trailers;\n            reject(err);\n          }\n        },\n      });\n    });\n  }\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","import { BaseMsg } from \"../BaseMsg\";\nimport { EncodeObject } from \"@cosmjs/proto-signing\";\nimport {\n  protobufPackage,\n  MsgVerifyInvariant as MsgVerifyInvariant_pb,\n} from \"../../proto/cosmos/crisis/v1beta1/tx\";\n\nexport class MsgVerifyInvariant extends BaseMsg {\n  public protoMsg: MsgVerifyInvariant_pb;\n  constructor(msg: MsgVerifyInvariant_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgVerifyInvariant.typeUrl,\n      value: MsgVerifyInvariant_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgVerifyInvariant {\n  export const typeUrl: string = `/${protobufPackage}.MsgVerifyInvariant`;\n  export const Proto = MsgVerifyInvariant_pb;\n  export interface Proto extends MsgVerifyInvariant_pb {}\n}\n\n\n","/* eslint-disable */\nimport Long from \"long\";\nimport { grpc } from \"@improbable-eng/grpc-web\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { BrowserHeaders } from \"browser-headers\";\nimport { Coin } from \"../../base/v1beta1/coin\";\n\nexport const protobufPackage = \"cosmos.distribution.v1beta1\";\n\n/**\n * MsgSetWithdrawAddress sets the withdraw address for\n * a delegator (or validator self-delegation).\n */\nexport interface MsgSetWithdrawAddress {\n  delegatorAddress: string;\n  withdrawAddress: string;\n}\n\n/** MsgSetWithdrawAddressResponse defines the Msg/SetWithdrawAddress response type. */\nexport interface MsgSetWithdrawAddressResponse {}\n\n/**\n * MsgWithdrawDelegatorReward represents delegation withdrawal to a delegator\n * from a single validator.\n */\nexport interface MsgWithdrawDelegatorReward {\n  delegatorAddress: string;\n  validatorAddress: string;\n}\n\n/** MsgWithdrawDelegatorRewardResponse defines the Msg/WithdrawDelegatorReward response type. */\nexport interface MsgWithdrawDelegatorRewardResponse {}\n\n/**\n * MsgWithdrawValidatorCommission withdraws the full commission to the validator\n * address.\n */\nexport interface MsgWithdrawValidatorCommission {\n  validatorAddress: string;\n}\n\n/** MsgWithdrawValidatorCommissionResponse defines the Msg/WithdrawValidatorCommission response type. */\nexport interface MsgWithdrawValidatorCommissionResponse {}\n\n/**\n * MsgFundCommunityPool allows an account to directly\n * fund the community pool.\n */\nexport interface MsgFundCommunityPool {\n  amount: Coin[];\n  depositor: string;\n}\n\n/** MsgFundCommunityPoolResponse defines the Msg/FundCommunityPool response type. */\nexport interface MsgFundCommunityPoolResponse {}\n\nfunction createBaseMsgSetWithdrawAddress(): MsgSetWithdrawAddress {\n  return { delegatorAddress: \"\", withdrawAddress: \"\" };\n}\n\nexport const MsgSetWithdrawAddress = {\n  encode(\n    message: MsgSetWithdrawAddress,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.withdrawAddress !== \"\") {\n      writer.uint32(18).string(message.withdrawAddress);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgSetWithdrawAddress {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgSetWithdrawAddress();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.withdrawAddress = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgSetWithdrawAddress {\n    return {\n      delegatorAddress: isSet(object.delegatorAddress)\n        ? String(object.delegatorAddress)\n        : \"\",\n      withdrawAddress: isSet(object.withdrawAddress)\n        ? String(object.withdrawAddress)\n        : \"\",\n    };\n  },\n\n  toJSON(message: MsgSetWithdrawAddress): unknown {\n    const obj: any = {};\n    message.delegatorAddress !== undefined &&\n      (obj.delegatorAddress = message.delegatorAddress);\n    message.withdrawAddress !== undefined &&\n      (obj.withdrawAddress = message.withdrawAddress);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgSetWithdrawAddress>, I>>(\n    object: I\n  ): MsgSetWithdrawAddress {\n    const message = createBaseMsgSetWithdrawAddress();\n    message.delegatorAddress = object.delegatorAddress ?? \"\";\n    message.withdrawAddress = object.withdrawAddress ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgSetWithdrawAddressResponse(): MsgSetWithdrawAddressResponse {\n  return {};\n}\n\nexport const MsgSetWithdrawAddressResponse = {\n  encode(\n    _: MsgSetWithdrawAddressResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgSetWithdrawAddressResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgSetWithdrawAddressResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgSetWithdrawAddressResponse {\n    return {};\n  },\n\n  toJSON(_: MsgSetWithdrawAddressResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgSetWithdrawAddressResponse>, I>>(\n    _: I\n  ): MsgSetWithdrawAddressResponse {\n    const message = createBaseMsgSetWithdrawAddressResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgWithdrawDelegatorReward(): MsgWithdrawDelegatorReward {\n  return { delegatorAddress: \"\", validatorAddress: \"\" };\n}\n\nexport const MsgWithdrawDelegatorReward = {\n  encode(\n    message: MsgWithdrawDelegatorReward,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(18).string(message.validatorAddress);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgWithdrawDelegatorReward {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgWithdrawDelegatorReward();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorAddress = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgWithdrawDelegatorReward {\n    return {\n      delegatorAddress: isSet(object.delegatorAddress)\n        ? String(object.delegatorAddress)\n        : \"\",\n      validatorAddress: isSet(object.validatorAddress)\n        ? String(object.validatorAddress)\n        : \"\",\n    };\n  },\n\n  toJSON(message: MsgWithdrawDelegatorReward): unknown {\n    const obj: any = {};\n    message.delegatorAddress !== undefined &&\n      (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorAddress !== undefined &&\n      (obj.validatorAddress = message.validatorAddress);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgWithdrawDelegatorReward>, I>>(\n    object: I\n  ): MsgWithdrawDelegatorReward {\n    const message = createBaseMsgWithdrawDelegatorReward();\n    message.delegatorAddress = object.delegatorAddress ?? \"\";\n    message.validatorAddress = object.validatorAddress ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgWithdrawDelegatorRewardResponse(): MsgWithdrawDelegatorRewardResponse {\n  return {};\n}\n\nexport const MsgWithdrawDelegatorRewardResponse = {\n  encode(\n    _: MsgWithdrawDelegatorRewardResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgWithdrawDelegatorRewardResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgWithdrawDelegatorRewardResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgWithdrawDelegatorRewardResponse {\n    return {};\n  },\n\n  toJSON(_: MsgWithdrawDelegatorRewardResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<\n    I extends Exact<DeepPartial<MsgWithdrawDelegatorRewardResponse>, I>\n  >(_: I): MsgWithdrawDelegatorRewardResponse {\n    const message = createBaseMsgWithdrawDelegatorRewardResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgWithdrawValidatorCommission(): MsgWithdrawValidatorCommission {\n  return { validatorAddress: \"\" };\n}\n\nexport const MsgWithdrawValidatorCommission = {\n  encode(\n    message: MsgWithdrawValidatorCommission,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(10).string(message.validatorAddress);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgWithdrawValidatorCommission {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgWithdrawValidatorCommission();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.validatorAddress = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgWithdrawValidatorCommission {\n    return {\n      validatorAddress: isSet(object.validatorAddress)\n        ? String(object.validatorAddress)\n        : \"\",\n    };\n  },\n\n  toJSON(message: MsgWithdrawValidatorCommission): unknown {\n    const obj: any = {};\n    message.validatorAddress !== undefined &&\n      (obj.validatorAddress = message.validatorAddress);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgWithdrawValidatorCommission>, I>>(\n    object: I\n  ): MsgWithdrawValidatorCommission {\n    const message = createBaseMsgWithdrawValidatorCommission();\n    message.validatorAddress = object.validatorAddress ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgWithdrawValidatorCommissionResponse(): MsgWithdrawValidatorCommissionResponse {\n  return {};\n}\n\nexport const MsgWithdrawValidatorCommissionResponse = {\n  encode(\n    _: MsgWithdrawValidatorCommissionResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgWithdrawValidatorCommissionResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgWithdrawValidatorCommissionResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgWithdrawValidatorCommissionResponse {\n    return {};\n  },\n\n  toJSON(_: MsgWithdrawValidatorCommissionResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<\n    I extends Exact<DeepPartial<MsgWithdrawValidatorCommissionResponse>, I>\n  >(_: I): MsgWithdrawValidatorCommissionResponse {\n    const message = createBaseMsgWithdrawValidatorCommissionResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgFundCommunityPool(): MsgFundCommunityPool {\n  return { amount: [], depositor: \"\" };\n}\n\nexport const MsgFundCommunityPool = {\n  encode(\n    message: MsgFundCommunityPool,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.amount) {\n      Coin.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.depositor !== \"\") {\n      writer.uint32(18).string(message.depositor);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgFundCommunityPool {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgFundCommunityPool();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.amount.push(Coin.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.depositor = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgFundCommunityPool {\n    return {\n      amount: Array.isArray(object?.amount)\n        ? object.amount.map((e: any) => Coin.fromJSON(e))\n        : [],\n      depositor: isSet(object.depositor) ? String(object.depositor) : \"\",\n    };\n  },\n\n  toJSON(message: MsgFundCommunityPool): unknown {\n    const obj: any = {};\n    if (message.amount) {\n      obj.amount = message.amount.map((e) => (e ? Coin.toJSON(e) : undefined));\n    } else {\n      obj.amount = [];\n    }\n    message.depositor !== undefined && (obj.depositor = message.depositor);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgFundCommunityPool>, I>>(\n    object: I\n  ): MsgFundCommunityPool {\n    const message = createBaseMsgFundCommunityPool();\n    message.amount = object.amount?.map((e) => Coin.fromPartial(e)) || [];\n    message.depositor = object.depositor ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgFundCommunityPoolResponse(): MsgFundCommunityPoolResponse {\n  return {};\n}\n\nexport const MsgFundCommunityPoolResponse = {\n  encode(\n    _: MsgFundCommunityPoolResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgFundCommunityPoolResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgFundCommunityPoolResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgFundCommunityPoolResponse {\n    return {};\n  },\n\n  toJSON(_: MsgFundCommunityPoolResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgFundCommunityPoolResponse>, I>>(\n    _: I\n  ): MsgFundCommunityPoolResponse {\n    const message = createBaseMsgFundCommunityPoolResponse();\n    return message;\n  },\n};\n\n/** Msg defines the distribution Msg service. */\nexport interface Msg {\n  /**\n   * SetWithdrawAddress defines a method to change the withdraw address\n   * for a delegator (or validator self-delegation).\n   */\n  SetWithdrawAddress(\n    request: DeepPartial<MsgSetWithdrawAddress>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgSetWithdrawAddressResponse>;\n  /**\n   * WithdrawDelegatorReward defines a method to withdraw rewards of delegator\n   * from a single validator.\n   */\n  WithdrawDelegatorReward(\n    request: DeepPartial<MsgWithdrawDelegatorReward>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgWithdrawDelegatorRewardResponse>;\n  /**\n   * WithdrawValidatorCommission defines a method to withdraw the\n   * full commission to the validator address.\n   */\n  WithdrawValidatorCommission(\n    request: DeepPartial<MsgWithdrawValidatorCommission>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgWithdrawValidatorCommissionResponse>;\n  /**\n   * FundCommunityPool defines a method to allow an account to directly\n   * fund the community pool.\n   */\n  FundCommunityPool(\n    request: DeepPartial<MsgFundCommunityPool>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgFundCommunityPoolResponse>;\n}\n\nexport class MsgClientImpl implements Msg {\n  private readonly rpc: Rpc;\n\n  constructor(rpc: Rpc) {\n    this.rpc = rpc;\n    this.SetWithdrawAddress = this.SetWithdrawAddress.bind(this);\n    this.WithdrawDelegatorReward = this.WithdrawDelegatorReward.bind(this);\n    this.WithdrawValidatorCommission =\n      this.WithdrawValidatorCommission.bind(this);\n    this.FundCommunityPool = this.FundCommunityPool.bind(this);\n  }\n\n  SetWithdrawAddress(\n    request: DeepPartial<MsgSetWithdrawAddress>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgSetWithdrawAddressResponse> {\n    return this.rpc.unary(\n      MsgSetWithdrawAddressDesc,\n      MsgSetWithdrawAddress.fromPartial(request),\n      metadata\n    );\n  }\n\n  WithdrawDelegatorReward(\n    request: DeepPartial<MsgWithdrawDelegatorReward>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgWithdrawDelegatorRewardResponse> {\n    return this.rpc.unary(\n      MsgWithdrawDelegatorRewardDesc,\n      MsgWithdrawDelegatorReward.fromPartial(request),\n      metadata\n    );\n  }\n\n  WithdrawValidatorCommission(\n    request: DeepPartial<MsgWithdrawValidatorCommission>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgWithdrawValidatorCommissionResponse> {\n    return this.rpc.unary(\n      MsgWithdrawValidatorCommissionDesc,\n      MsgWithdrawValidatorCommission.fromPartial(request),\n      metadata\n    );\n  }\n\n  FundCommunityPool(\n    request: DeepPartial<MsgFundCommunityPool>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgFundCommunityPoolResponse> {\n    return this.rpc.unary(\n      MsgFundCommunityPoolDesc,\n      MsgFundCommunityPool.fromPartial(request),\n      metadata\n    );\n  }\n}\n\nexport const MsgDesc = {\n  serviceName: \"cosmos.distribution.v1beta1.Msg\",\n};\n\nexport const MsgSetWithdrawAddressDesc: UnaryMethodDefinitionish = {\n  methodName: \"SetWithdrawAddress\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgSetWithdrawAddress.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgSetWithdrawAddressResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgWithdrawDelegatorRewardDesc: UnaryMethodDefinitionish = {\n  methodName: \"WithdrawDelegatorReward\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgWithdrawDelegatorReward.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgWithdrawDelegatorRewardResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgWithdrawValidatorCommissionDesc: UnaryMethodDefinitionish = {\n  methodName: \"WithdrawValidatorCommission\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgWithdrawValidatorCommission.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgWithdrawValidatorCommissionResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgFundCommunityPoolDesc: UnaryMethodDefinitionish = {\n  methodName: \"FundCommunityPool\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgFundCommunityPool.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgFundCommunityPoolResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\ninterface UnaryMethodDefinitionishR\n  extends grpc.UnaryMethodDefinition<any, any> {\n  requestStream: any;\n  responseStream: any;\n}\n\ntype UnaryMethodDefinitionish = UnaryMethodDefinitionishR;\n\ninterface Rpc {\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any>;\n}\n\nexport class GrpcWebImpl {\n  private host: string;\n  private options: {\n    transport?: grpc.TransportFactory;\n\n    debug?: boolean;\n    metadata?: grpc.Metadata;\n  };\n\n  constructor(\n    host: string,\n    options: {\n      transport?: grpc.TransportFactory;\n\n      debug?: boolean;\n      metadata?: grpc.Metadata;\n    }\n  ) {\n    this.host = host;\n    this.options = options;\n  }\n\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    _request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any> {\n    const request = { ..._request, ...methodDesc.requestType };\n    const maybeCombinedMetadata =\n      metadata && this.options.metadata\n        ? new BrowserHeaders({\n            ...this.options?.metadata.headersMap,\n            ...metadata?.headersMap,\n          })\n        : metadata || this.options.metadata;\n    return new Promise((resolve, reject) => {\n      grpc.unary(methodDesc, {\n        request,\n        host: this.host,\n        metadata: maybeCombinedMetadata,\n        transport: this.options.transport,\n        debug: this.options.debug,\n        onEnd: function (response) {\n          if (response.status === grpc.Code.OK) {\n            resolve(response.message);\n          } else {\n            const err = new Error(response.statusMessage) as any;\n            err.code = response.status;\n            err.metadata = response.trailers;\n            reject(err);\n          }\n        },\n      });\n    });\n  }\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","import { BaseMsg } from \"../BaseMsg\";\nimport { EncodeObject } from \"@cosmjs/proto-signing\";\nimport {\n  protobufPackage,\n  MsgFundCommunityPool as MsgFundCommunityPool_pb,\n  MsgSetWithdrawAddress as MsgSetWithdrawAddress_pb,\n  MsgWithdrawDelegatorReward as MsgWithdrawDelegatorReward_pb,\n  MsgWithdrawValidatorCommission as MsgWithdrawValidatorCommission_pb\n} from \"../../proto/cosmos/distribution/v1beta1/tx\";\n\nexport class MsgFundCommunityPool extends BaseMsg {\n  public protoMsg: MsgFundCommunityPool_pb;\n  constructor(msg: MsgFundCommunityPool_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgFundCommunityPool.typeUrl,\n      value: MsgFundCommunityPool_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgFundCommunityPool {\n  export const typeUrl: string = `/${protobufPackage}.MsgFundCommunityPool`;\n  export const Proto = MsgFundCommunityPool_pb;\n  export interface Proto extends MsgFundCommunityPool_pb {}\n}\n\nexport class MsgSetWithdrawAddress extends BaseMsg {\n  public protoMsg: MsgSetWithdrawAddress_pb;\n  constructor(msg: MsgSetWithdrawAddress_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgSetWithdrawAddress.typeUrl,\n      value: MsgSetWithdrawAddress_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgSetWithdrawAddress {\n  export const typeUrl: string = `/${protobufPackage}.MsgSetWithdrawAddress`;\n  export const Proto = MsgSetWithdrawAddress_pb;\n  export interface Proto extends MsgSetWithdrawAddress_pb {}\n}\n\nexport class MsgWithdrawDelegatorReward extends BaseMsg {\n  public protoMsg: MsgWithdrawDelegatorReward_pb;\n  constructor(msg: MsgWithdrawDelegatorReward_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgWithdrawDelegatorReward.typeUrl,\n      value: MsgWithdrawDelegatorReward_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgWithdrawDelegatorReward {\n  export const typeUrl: string = `/${protobufPackage}.MsgWithdrawDelegatorReward`;\n  export const Proto = MsgWithdrawDelegatorReward_pb;\n  export interface Proto extends MsgWithdrawDelegatorReward_pb {}\n}\n\nexport class MsgWithdrawValidatorCommission extends BaseMsg {\n  public protoMsg: MsgWithdrawValidatorCommission_pb;\n  constructor(msg: MsgWithdrawValidatorCommission_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgWithdrawValidatorCommission.typeUrl,\n      value: MsgWithdrawValidatorCommission_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgWithdrawValidatorCommission {\n  export const typeUrl: string = `/${protobufPackage}.MsgWithdrawValidatorCommission`;\n  export const Proto = MsgWithdrawValidatorCommission_pb;\n  export interface Proto extends MsgWithdrawValidatorCommission_pb {}\n}\n\n\n","/* eslint-disable */\nimport Long from \"long\";\nimport { grpc } from \"@improbable-eng/grpc-web\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Any } from \"../../../google/protobuf/any\";\nimport { BrowserHeaders } from \"browser-headers\";\n\nexport const protobufPackage = \"cosmos.evidence.v1beta1\";\n\n/**\n * MsgSubmitEvidence represents a message that supports submitting arbitrary\n * Evidence of misbehavior such as equivocation or counterfactual signing.\n */\nexport interface MsgSubmitEvidence {\n  submitter: string;\n  evidence?: Any;\n}\n\n/** MsgSubmitEvidenceResponse defines the Msg/SubmitEvidence response type. */\nexport interface MsgSubmitEvidenceResponse {\n  /** hash defines the hash of the evidence. */\n  hash: Uint8Array;\n}\n\nfunction createBaseMsgSubmitEvidence(): MsgSubmitEvidence {\n  return { submitter: \"\", evidence: undefined };\n}\n\nexport const MsgSubmitEvidence = {\n  encode(\n    message: MsgSubmitEvidence,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.submitter !== \"\") {\n      writer.uint32(10).string(message.submitter);\n    }\n    if (message.evidence !== undefined) {\n      Any.encode(message.evidence, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSubmitEvidence {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgSubmitEvidence();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.submitter = reader.string();\n          break;\n        case 2:\n          message.evidence = Any.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgSubmitEvidence {\n    return {\n      submitter: isSet(object.submitter) ? String(object.submitter) : \"\",\n      evidence: isSet(object.evidence)\n        ? Any.fromJSON(object.evidence)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgSubmitEvidence): unknown {\n    const obj: any = {};\n    message.submitter !== undefined && (obj.submitter = message.submitter);\n    message.evidence !== undefined &&\n      (obj.evidence = message.evidence\n        ? Any.toJSON(message.evidence)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgSubmitEvidence>, I>>(\n    object: I\n  ): MsgSubmitEvidence {\n    const message = createBaseMsgSubmitEvidence();\n    message.submitter = object.submitter ?? \"\";\n    message.evidence =\n      object.evidence !== undefined && object.evidence !== null\n        ? Any.fromPartial(object.evidence)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgSubmitEvidenceResponse(): MsgSubmitEvidenceResponse {\n  return { hash: new Uint8Array() };\n}\n\nexport const MsgSubmitEvidenceResponse = {\n  encode(\n    message: MsgSubmitEvidenceResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.hash.length !== 0) {\n      writer.uint32(34).bytes(message.hash);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgSubmitEvidenceResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgSubmitEvidenceResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 4:\n          message.hash = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgSubmitEvidenceResponse {\n    return {\n      hash: isSet(object.hash)\n        ? bytesFromBase64(object.hash)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: MsgSubmitEvidenceResponse): unknown {\n    const obj: any = {};\n    message.hash !== undefined &&\n      (obj.hash = base64FromBytes(\n        message.hash !== undefined ? message.hash : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgSubmitEvidenceResponse>, I>>(\n    object: I\n  ): MsgSubmitEvidenceResponse {\n    const message = createBaseMsgSubmitEvidenceResponse();\n    message.hash = object.hash ?? new Uint8Array();\n    return message;\n  },\n};\n\n/** Msg defines the evidence Msg service. */\nexport interface Msg {\n  /**\n   * SubmitEvidence submits an arbitrary Evidence of misbehavior such as equivocation or\n   * counterfactual signing.\n   */\n  SubmitEvidence(\n    request: DeepPartial<MsgSubmitEvidence>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgSubmitEvidenceResponse>;\n}\n\nexport class MsgClientImpl implements Msg {\n  private readonly rpc: Rpc;\n\n  constructor(rpc: Rpc) {\n    this.rpc = rpc;\n    this.SubmitEvidence = this.SubmitEvidence.bind(this);\n  }\n\n  SubmitEvidence(\n    request: DeepPartial<MsgSubmitEvidence>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgSubmitEvidenceResponse> {\n    return this.rpc.unary(\n      MsgSubmitEvidenceDesc,\n      MsgSubmitEvidence.fromPartial(request),\n      metadata\n    );\n  }\n}\n\nexport const MsgDesc = {\n  serviceName: \"cosmos.evidence.v1beta1.Msg\",\n};\n\nexport const MsgSubmitEvidenceDesc: UnaryMethodDefinitionish = {\n  methodName: \"SubmitEvidence\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgSubmitEvidence.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgSubmitEvidenceResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\ninterface UnaryMethodDefinitionishR\n  extends grpc.UnaryMethodDefinition<any, any> {\n  requestStream: any;\n  responseStream: any;\n}\n\ntype UnaryMethodDefinitionish = UnaryMethodDefinitionishR;\n\ninterface Rpc {\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any>;\n}\n\nexport class GrpcWebImpl {\n  private host: string;\n  private options: {\n    transport?: grpc.TransportFactory;\n\n    debug?: boolean;\n    metadata?: grpc.Metadata;\n  };\n\n  constructor(\n    host: string,\n    options: {\n      transport?: grpc.TransportFactory;\n\n      debug?: boolean;\n      metadata?: grpc.Metadata;\n    }\n  ) {\n    this.host = host;\n    this.options = options;\n  }\n\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    _request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any> {\n    const request = { ..._request, ...methodDesc.requestType };\n    const maybeCombinedMetadata =\n      metadata && this.options.metadata\n        ? new BrowserHeaders({\n            ...this.options?.metadata.headersMap,\n            ...metadata?.headersMap,\n          })\n        : metadata || this.options.metadata;\n    return new Promise((resolve, reject) => {\n      grpc.unary(methodDesc, {\n        request,\n        host: this.host,\n        metadata: maybeCombinedMetadata,\n        transport: this.options.transport,\n        debug: this.options.debug,\n        onEnd: function (response) {\n          if (response.status === grpc.Code.OK) {\n            resolve(response.message);\n          } else {\n            const err = new Error(response.statusMessage) as any;\n            err.code = response.status;\n            err.metadata = response.trailers;\n            reject(err);\n          }\n        },\n      });\n    });\n  }\n}\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","import { BaseMsg } from \"../BaseMsg\";\nimport { EncodeObject } from \"@cosmjs/proto-signing\";\nimport {\n  protobufPackage,\n  MsgSubmitEvidence as MsgSubmitEvidence_pb,\n} from \"../../proto/cosmos/evidence/v1beta1/tx\";\n\nexport class MsgSubmitEvidence extends BaseMsg {\n  public protoMsg: MsgSubmitEvidence_pb;\n  constructor(msg: MsgSubmitEvidence_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgSubmitEvidence.typeUrl,\n      value: MsgSubmitEvidence_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgSubmitEvidence {\n  export const typeUrl: string = `/${protobufPackage}.MsgSubmitEvidence`;\n  export const Proto = MsgSubmitEvidence_pb;\n  export interface Proto extends MsgSubmitEvidence_pb {}\n}\n\n\n","/* eslint-disable */\nimport Long from \"long\";\nimport { grpc } from \"@improbable-eng/grpc-web\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Any } from \"../../../google/protobuf/any\";\nimport { BrowserHeaders } from \"browser-headers\";\n\nexport const protobufPackage = \"cosmos.feegrant.v1beta1\";\n\n/** Since: cosmos-sdk 0.43 */\n\n/**\n * MsgGrantAllowance adds permission for Grantee to spend up to Allowance\n * of fees from the account of Granter.\n */\nexport interface MsgGrantAllowance {\n  /** granter is the address of the user granting an allowance of their funds. */\n  granter: string;\n  /** grantee is the address of the user being granted an allowance of another user's funds. */\n  grantee: string;\n  /** allowance can be any of basic and filtered fee allowance. */\n  allowance?: Any;\n}\n\n/** MsgGrantAllowanceResponse defines the Msg/GrantAllowanceResponse response type. */\nexport interface MsgGrantAllowanceResponse {}\n\n/** MsgRevokeAllowance removes any existing Allowance from Granter to Grantee. */\nexport interface MsgRevokeAllowance {\n  /** granter is the address of the user granting an allowance of their funds. */\n  granter: string;\n  /** grantee is the address of the user being granted an allowance of another user's funds. */\n  grantee: string;\n}\n\n/** MsgRevokeAllowanceResponse defines the Msg/RevokeAllowanceResponse response type. */\nexport interface MsgRevokeAllowanceResponse {}\n\nfunction createBaseMsgGrantAllowance(): MsgGrantAllowance {\n  return { granter: \"\", grantee: \"\", allowance: undefined };\n}\n\nexport const MsgGrantAllowance = {\n  encode(\n    message: MsgGrantAllowance,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.granter !== \"\") {\n      writer.uint32(10).string(message.granter);\n    }\n    if (message.grantee !== \"\") {\n      writer.uint32(18).string(message.grantee);\n    }\n    if (message.allowance !== undefined) {\n      Any.encode(message.allowance, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgGrantAllowance {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgGrantAllowance();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.granter = reader.string();\n          break;\n        case 2:\n          message.grantee = reader.string();\n          break;\n        case 3:\n          message.allowance = Any.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgGrantAllowance {\n    return {\n      granter: isSet(object.granter) ? String(object.granter) : \"\",\n      grantee: isSet(object.grantee) ? String(object.grantee) : \"\",\n      allowance: isSet(object.allowance)\n        ? Any.fromJSON(object.allowance)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgGrantAllowance): unknown {\n    const obj: any = {};\n    message.granter !== undefined && (obj.granter = message.granter);\n    message.grantee !== undefined && (obj.grantee = message.grantee);\n    message.allowance !== undefined &&\n      (obj.allowance = message.allowance\n        ? Any.toJSON(message.allowance)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgGrantAllowance>, I>>(\n    object: I\n  ): MsgGrantAllowance {\n    const message = createBaseMsgGrantAllowance();\n    message.granter = object.granter ?? \"\";\n    message.grantee = object.grantee ?? \"\";\n    message.allowance =\n      object.allowance !== undefined && object.allowance !== null\n        ? Any.fromPartial(object.allowance)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgGrantAllowanceResponse(): MsgGrantAllowanceResponse {\n  return {};\n}\n\nexport const MsgGrantAllowanceResponse = {\n  encode(\n    _: MsgGrantAllowanceResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgGrantAllowanceResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgGrantAllowanceResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgGrantAllowanceResponse {\n    return {};\n  },\n\n  toJSON(_: MsgGrantAllowanceResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgGrantAllowanceResponse>, I>>(\n    _: I\n  ): MsgGrantAllowanceResponse {\n    const message = createBaseMsgGrantAllowanceResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgRevokeAllowance(): MsgRevokeAllowance {\n  return { granter: \"\", grantee: \"\" };\n}\n\nexport const MsgRevokeAllowance = {\n  encode(\n    message: MsgRevokeAllowance,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.granter !== \"\") {\n      writer.uint32(10).string(message.granter);\n    }\n    if (message.grantee !== \"\") {\n      writer.uint32(18).string(message.grantee);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgRevokeAllowance {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgRevokeAllowance();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.granter = reader.string();\n          break;\n        case 2:\n          message.grantee = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgRevokeAllowance {\n    return {\n      granter: isSet(object.granter) ? String(object.granter) : \"\",\n      grantee: isSet(object.grantee) ? String(object.grantee) : \"\",\n    };\n  },\n\n  toJSON(message: MsgRevokeAllowance): unknown {\n    const obj: any = {};\n    message.granter !== undefined && (obj.granter = message.granter);\n    message.grantee !== undefined && (obj.grantee = message.grantee);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgRevokeAllowance>, I>>(\n    object: I\n  ): MsgRevokeAllowance {\n    const message = createBaseMsgRevokeAllowance();\n    message.granter = object.granter ?? \"\";\n    message.grantee = object.grantee ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgRevokeAllowanceResponse(): MsgRevokeAllowanceResponse {\n  return {};\n}\n\nexport const MsgRevokeAllowanceResponse = {\n  encode(\n    _: MsgRevokeAllowanceResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgRevokeAllowanceResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgRevokeAllowanceResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgRevokeAllowanceResponse {\n    return {};\n  },\n\n  toJSON(_: MsgRevokeAllowanceResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgRevokeAllowanceResponse>, I>>(\n    _: I\n  ): MsgRevokeAllowanceResponse {\n    const message = createBaseMsgRevokeAllowanceResponse();\n    return message;\n  },\n};\n\n/** Msg defines the feegrant msg service. */\nexport interface Msg {\n  /**\n   * GrantAllowance grants fee allowance to the grantee on the granter's\n   * account with the provided expiration time.\n   */\n  GrantAllowance(\n    request: DeepPartial<MsgGrantAllowance>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgGrantAllowanceResponse>;\n  /**\n   * RevokeAllowance revokes any fee allowance of granter's account that\n   * has been granted to the grantee.\n   */\n  RevokeAllowance(\n    request: DeepPartial<MsgRevokeAllowance>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgRevokeAllowanceResponse>;\n}\n\nexport class MsgClientImpl implements Msg {\n  private readonly rpc: Rpc;\n\n  constructor(rpc: Rpc) {\n    this.rpc = rpc;\n    this.GrantAllowance = this.GrantAllowance.bind(this);\n    this.RevokeAllowance = this.RevokeAllowance.bind(this);\n  }\n\n  GrantAllowance(\n    request: DeepPartial<MsgGrantAllowance>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgGrantAllowanceResponse> {\n    return this.rpc.unary(\n      MsgGrantAllowanceDesc,\n      MsgGrantAllowance.fromPartial(request),\n      metadata\n    );\n  }\n\n  RevokeAllowance(\n    request: DeepPartial<MsgRevokeAllowance>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgRevokeAllowanceResponse> {\n    return this.rpc.unary(\n      MsgRevokeAllowanceDesc,\n      MsgRevokeAllowance.fromPartial(request),\n      metadata\n    );\n  }\n}\n\nexport const MsgDesc = {\n  serviceName: \"cosmos.feegrant.v1beta1.Msg\",\n};\n\nexport const MsgGrantAllowanceDesc: UnaryMethodDefinitionish = {\n  methodName: \"GrantAllowance\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgGrantAllowance.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgGrantAllowanceResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgRevokeAllowanceDesc: UnaryMethodDefinitionish = {\n  methodName: \"RevokeAllowance\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgRevokeAllowance.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgRevokeAllowanceResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\ninterface UnaryMethodDefinitionishR\n  extends grpc.UnaryMethodDefinition<any, any> {\n  requestStream: any;\n  responseStream: any;\n}\n\ntype UnaryMethodDefinitionish = UnaryMethodDefinitionishR;\n\ninterface Rpc {\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any>;\n}\n\nexport class GrpcWebImpl {\n  private host: string;\n  private options: {\n    transport?: grpc.TransportFactory;\n\n    debug?: boolean;\n    metadata?: grpc.Metadata;\n  };\n\n  constructor(\n    host: string,\n    options: {\n      transport?: grpc.TransportFactory;\n\n      debug?: boolean;\n      metadata?: grpc.Metadata;\n    }\n  ) {\n    this.host = host;\n    this.options = options;\n  }\n\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    _request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any> {\n    const request = { ..._request, ...methodDesc.requestType };\n    const maybeCombinedMetadata =\n      metadata && this.options.metadata\n        ? new BrowserHeaders({\n            ...this.options?.metadata.headersMap,\n            ...metadata?.headersMap,\n          })\n        : metadata || this.options.metadata;\n    return new Promise((resolve, reject) => {\n      grpc.unary(methodDesc, {\n        request,\n        host: this.host,\n        metadata: maybeCombinedMetadata,\n        transport: this.options.transport,\n        debug: this.options.debug,\n        onEnd: function (response) {\n          if (response.status === grpc.Code.OK) {\n            resolve(response.message);\n          } else {\n            const err = new Error(response.statusMessage) as any;\n            err.code = response.status;\n            err.metadata = response.trailers;\n            reject(err);\n          }\n        },\n      });\n    });\n  }\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","import { BaseMsg } from \"../BaseMsg\";\nimport { EncodeObject } from \"@cosmjs/proto-signing\";\nimport {\n  protobufPackage,\n  MsgGrantAllowance as MsgGrantAllowance_pb,\n  MsgRevokeAllowance as MsgRevokeAllowance_pb\n} from \"../../proto/cosmos/feegrant/v1beta1/tx\";\n\nexport class MsgGrantAllowance extends BaseMsg {\n  public protoMsg: MsgGrantAllowance_pb;\n  constructor(msg: MsgGrantAllowance_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgGrantAllowance.typeUrl,\n      value: MsgGrantAllowance_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgGrantAllowance {\n  export const typeUrl: string = `/${protobufPackage}.MsgGrantAllowance`;\n  export const Proto = MsgGrantAllowance_pb;\n  export interface Proto extends MsgGrantAllowance_pb {}\n}\n\nexport class MsgRevokeAllowance extends BaseMsg {\n  public protoMsg: MsgRevokeAllowance_pb;\n  constructor(msg: MsgRevokeAllowance_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgRevokeAllowance.typeUrl,\n      value: MsgRevokeAllowance_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgRevokeAllowance {\n  export const typeUrl: string = `/${protobufPackage}.MsgRevokeAllowance`;\n  export const Proto = MsgRevokeAllowance_pb;\n  export interface Proto extends MsgRevokeAllowance_pb {}\n}\n\n\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"google.protobuf\";\n\n/**\n * A Duration represents a signed, fixed-length span of time represented\n * as a count of seconds and fractions of seconds at nanosecond\n * resolution. It is independent of any calendar and concepts like \"day\"\n * or \"month\". It is related to Timestamp in that the difference between\n * two Timestamp values is a Duration and it can be added or subtracted\n * from a Timestamp. Range is approximately +-10,000 years.\n *\n * # Examples\n *\n * Example 1: Compute Duration from two Timestamps in pseudo code.\n *\n *     Timestamp start = ...;\n *     Timestamp end = ...;\n *     Duration duration = ...;\n *\n *     duration.seconds = end.seconds - start.seconds;\n *     duration.nanos = end.nanos - start.nanos;\n *\n *     if (duration.seconds < 0 && duration.nanos > 0) {\n *       duration.seconds += 1;\n *       duration.nanos -= 1000000000;\n *     } else if (duration.seconds > 0 && duration.nanos < 0) {\n *       duration.seconds -= 1;\n *       duration.nanos += 1000000000;\n *     }\n *\n * Example 2: Compute Timestamp from Timestamp + Duration in pseudo code.\n *\n *     Timestamp start = ...;\n *     Duration duration = ...;\n *     Timestamp end = ...;\n *\n *     end.seconds = start.seconds + duration.seconds;\n *     end.nanos = start.nanos + duration.nanos;\n *\n *     if (end.nanos < 0) {\n *       end.seconds -= 1;\n *       end.nanos += 1000000000;\n *     } else if (end.nanos >= 1000000000) {\n *       end.seconds += 1;\n *       end.nanos -= 1000000000;\n *     }\n *\n * Example 3: Compute Duration from datetime.timedelta in Python.\n *\n *     td = datetime.timedelta(days=3, minutes=10)\n *     duration = Duration()\n *     duration.FromTimedelta(td)\n *\n * # JSON Mapping\n *\n * In JSON format, the Duration type is encoded as a string rather than an\n * object, where the string ends in the suffix \"s\" (indicating seconds) and\n * is preceded by the number of seconds, with nanoseconds expressed as\n * fractional seconds. For example, 3 seconds with 0 nanoseconds should be\n * encoded in JSON format as \"3s\", while 3 seconds and 1 nanosecond should\n * be expressed in JSON format as \"3.000000001s\", and 3 seconds and 1\n * microsecond should be expressed in JSON format as \"3.000001s\".\n */\nexport interface Duration {\n  /**\n   * Signed seconds of the span of time. Must be from -315,576,000,000\n   * to +315,576,000,000 inclusive. Note: these bounds are computed from:\n   * 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years\n   */\n  seconds: Long;\n  /**\n   * Signed fractions of a second at nanosecond resolution of the span\n   * of time. Durations less than one second are represented with a 0\n   * `seconds` field and a positive or negative `nanos` field. For durations\n   * of one second or more, a non-zero value for the `nanos` field must be\n   * of the same sign as the `seconds` field. Must be from -999,999,999\n   * to +999,999,999 inclusive.\n   */\n  nanos: number;\n}\n\nfunction createBaseDuration(): Duration {\n  return { seconds: Long.ZERO, nanos: 0 };\n}\n\nexport const Duration = {\n  encode(\n    message: Duration,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.seconds.isZero()) {\n      writer.uint32(8).int64(message.seconds);\n    }\n    if (message.nanos !== 0) {\n      writer.uint32(16).int32(message.nanos);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Duration {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDuration();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.seconds = reader.int64() as Long;\n          break;\n        case 2:\n          message.nanos = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Duration {\n    return {\n      seconds: isSet(object.seconds)\n        ? Long.fromValue(object.seconds)\n        : Long.ZERO,\n      nanos: isSet(object.nanos) ? Number(object.nanos) : 0,\n    };\n  },\n\n  toJSON(message: Duration): unknown {\n    const obj: any = {};\n    message.seconds !== undefined &&\n      (obj.seconds = (message.seconds || Long.ZERO).toString());\n    message.nanos !== undefined && (obj.nanos = Math.round(message.nanos));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Duration>, I>>(object: I): Duration {\n    const message = createBaseDuration();\n    message.seconds =\n      object.seconds !== undefined && object.seconds !== null\n        ? Long.fromValue(object.seconds)\n        : Long.ZERO;\n    message.nanos = object.nanos ?? 0;\n    return message;\n  },\n};\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Any } from \"../../../google/protobuf/any\";\nimport { Duration } from \"../../../google/protobuf/duration\";\nimport { Timestamp } from \"../../../google/protobuf/timestamp\";\nimport { Coin } from \"../../base/v1beta1/coin\";\n\nexport const protobufPackage = \"cosmos.gov.v1beta1\";\n\n/** VoteOption enumerates the valid vote options for a given governance proposal. */\nexport enum VoteOption {\n  /** VOTE_OPTION_UNSPECIFIED - VOTE_OPTION_UNSPECIFIED defines a no-op vote option. */\n  VOTE_OPTION_UNSPECIFIED = 0,\n  /** VOTE_OPTION_YES - VOTE_OPTION_YES defines a yes vote option. */\n  VOTE_OPTION_YES = 1,\n  /** VOTE_OPTION_ABSTAIN - VOTE_OPTION_ABSTAIN defines an abstain vote option. */\n  VOTE_OPTION_ABSTAIN = 2,\n  /** VOTE_OPTION_NO - VOTE_OPTION_NO defines a no vote option. */\n  VOTE_OPTION_NO = 3,\n  /** VOTE_OPTION_NO_WITH_VETO - VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option. */\n  VOTE_OPTION_NO_WITH_VETO = 4,\n  UNRECOGNIZED = -1,\n}\n\nexport function voteOptionFromJSON(object: any): VoteOption {\n  switch (object) {\n    case 0:\n    case \"VOTE_OPTION_UNSPECIFIED\":\n      return VoteOption.VOTE_OPTION_UNSPECIFIED;\n    case 1:\n    case \"VOTE_OPTION_YES\":\n      return VoteOption.VOTE_OPTION_YES;\n    case 2:\n    case \"VOTE_OPTION_ABSTAIN\":\n      return VoteOption.VOTE_OPTION_ABSTAIN;\n    case 3:\n    case \"VOTE_OPTION_NO\":\n      return VoteOption.VOTE_OPTION_NO;\n    case 4:\n    case \"VOTE_OPTION_NO_WITH_VETO\":\n      return VoteOption.VOTE_OPTION_NO_WITH_VETO;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return VoteOption.UNRECOGNIZED;\n  }\n}\n\nexport function voteOptionToJSON(object: VoteOption): string {\n  switch (object) {\n    case VoteOption.VOTE_OPTION_UNSPECIFIED:\n      return \"VOTE_OPTION_UNSPECIFIED\";\n    case VoteOption.VOTE_OPTION_YES:\n      return \"VOTE_OPTION_YES\";\n    case VoteOption.VOTE_OPTION_ABSTAIN:\n      return \"VOTE_OPTION_ABSTAIN\";\n    case VoteOption.VOTE_OPTION_NO:\n      return \"VOTE_OPTION_NO\";\n    case VoteOption.VOTE_OPTION_NO_WITH_VETO:\n      return \"VOTE_OPTION_NO_WITH_VETO\";\n    case VoteOption.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n\n/** ProposalStatus enumerates the valid statuses of a proposal. */\nexport enum ProposalStatus {\n  /** PROPOSAL_STATUS_UNSPECIFIED - PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status. */\n  PROPOSAL_STATUS_UNSPECIFIED = 0,\n  /**\n   * PROPOSAL_STATUS_DEPOSIT_PERIOD - PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\n   * period.\n   */\n  PROPOSAL_STATUS_DEPOSIT_PERIOD = 1,\n  /**\n   * PROPOSAL_STATUS_VOTING_PERIOD - PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\n   * period.\n   */\n  PROPOSAL_STATUS_VOTING_PERIOD = 2,\n  /**\n   * PROPOSAL_STATUS_PASSED - PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\n   * passed.\n   */\n  PROPOSAL_STATUS_PASSED = 3,\n  /**\n   * PROPOSAL_STATUS_REJECTED - PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\n   * been rejected.\n   */\n  PROPOSAL_STATUS_REJECTED = 4,\n  /**\n   * PROPOSAL_STATUS_FAILED - PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\n   * failed.\n   */\n  PROPOSAL_STATUS_FAILED = 5,\n  UNRECOGNIZED = -1,\n}\n\nexport function proposalStatusFromJSON(object: any): ProposalStatus {\n  switch (object) {\n    case 0:\n    case \"PROPOSAL_STATUS_UNSPECIFIED\":\n      return ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED;\n    case 1:\n    case \"PROPOSAL_STATUS_DEPOSIT_PERIOD\":\n      return ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD;\n    case 2:\n    case \"PROPOSAL_STATUS_VOTING_PERIOD\":\n      return ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD;\n    case 3:\n    case \"PROPOSAL_STATUS_PASSED\":\n      return ProposalStatus.PROPOSAL_STATUS_PASSED;\n    case 4:\n    case \"PROPOSAL_STATUS_REJECTED\":\n      return ProposalStatus.PROPOSAL_STATUS_REJECTED;\n    case 5:\n    case \"PROPOSAL_STATUS_FAILED\":\n      return ProposalStatus.PROPOSAL_STATUS_FAILED;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return ProposalStatus.UNRECOGNIZED;\n  }\n}\n\nexport function proposalStatusToJSON(object: ProposalStatus): string {\n  switch (object) {\n    case ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED:\n      return \"PROPOSAL_STATUS_UNSPECIFIED\";\n    case ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD:\n      return \"PROPOSAL_STATUS_DEPOSIT_PERIOD\";\n    case ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD:\n      return \"PROPOSAL_STATUS_VOTING_PERIOD\";\n    case ProposalStatus.PROPOSAL_STATUS_PASSED:\n      return \"PROPOSAL_STATUS_PASSED\";\n    case ProposalStatus.PROPOSAL_STATUS_REJECTED:\n      return \"PROPOSAL_STATUS_REJECTED\";\n    case ProposalStatus.PROPOSAL_STATUS_FAILED:\n      return \"PROPOSAL_STATUS_FAILED\";\n    case ProposalStatus.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n\n/**\n * WeightedVoteOption defines a unit of vote for vote split.\n *\n * Since: cosmos-sdk 0.43\n */\nexport interface WeightedVoteOption {\n  option: VoteOption;\n  weight: string;\n}\n\n/**\n * TextProposal defines a standard text proposal whose changes need to be\n * manually updated in case of approval.\n */\nexport interface TextProposal {\n  title: string;\n  description: string;\n}\n\n/**\n * Deposit defines an amount deposited by an account address to an active\n * proposal.\n */\nexport interface Deposit {\n  proposalId: Long;\n  depositor: string;\n  amount: Coin[];\n}\n\n/** Proposal defines the core field members of a governance proposal. */\nexport interface Proposal {\n  proposalId: Long;\n  content?: Any;\n  status: ProposalStatus;\n  finalTallyResult?: TallyResult;\n  submitTime?: Date;\n  depositEndTime?: Date;\n  totalDeposit: Coin[];\n  votingStartTime?: Date;\n  votingEndTime?: Date;\n}\n\n/** TallyResult defines a standard tally for a governance proposal. */\nexport interface TallyResult {\n  yes: string;\n  abstain: string;\n  no: string;\n  noWithVeto: string;\n}\n\n/**\n * Vote defines a vote on a governance proposal.\n * A Vote consists of a proposal ID, the voter, and the vote option.\n */\nexport interface Vote {\n  proposalId: Long;\n  voter: string;\n  /**\n   * Deprecated: Prefer to use `options` instead. This field is set in queries\n   * if and only if `len(options) == 1` and that option has weight 1. In all\n   * other cases, this field will default to VOTE_OPTION_UNSPECIFIED.\n   *\n   * @deprecated\n   */\n  option: VoteOption;\n  /** Since: cosmos-sdk 0.43 */\n  options: WeightedVoteOption[];\n}\n\n/** DepositParams defines the params for deposits on governance proposals. */\nexport interface DepositParams {\n  /** Minimum deposit for a proposal to enter voting period. */\n  minDeposit: Coin[];\n  /**\n   * Maximum period for Atom holders to deposit on a proposal. Initial value: 2\n   *  months.\n   */\n  maxDepositPeriod?: Duration;\n}\n\n/** VotingParams defines the params for voting on governance proposals. */\nexport interface VotingParams {\n  /** Length of the voting period. */\n  votingPeriod?: Duration;\n}\n\n/** TallyParams defines the params for tallying votes on governance proposals. */\nexport interface TallyParams {\n  /**\n   * Minimum percentage of total stake needed to vote for a result to be\n   *  considered valid.\n   */\n  quorum: Uint8Array;\n  /** Minimum proportion of Yes votes for proposal to pass. Default value: 0.5. */\n  threshold: Uint8Array;\n  /**\n   * Minimum value of Veto votes to Total votes ratio for proposal to be\n   *  vetoed. Default value: 1/3.\n   */\n  vetoThreshold: Uint8Array;\n}\n\nfunction createBaseWeightedVoteOption(): WeightedVoteOption {\n  return { option: 0, weight: \"\" };\n}\n\nexport const WeightedVoteOption = {\n  encode(\n    message: WeightedVoteOption,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.option !== 0) {\n      writer.uint32(8).int32(message.option);\n    }\n    if (message.weight !== \"\") {\n      writer.uint32(18).string(message.weight);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): WeightedVoteOption {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseWeightedVoteOption();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.option = reader.int32() as any;\n          break;\n        case 2:\n          message.weight = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): WeightedVoteOption {\n    return {\n      option: isSet(object.option) ? voteOptionFromJSON(object.option) : 0,\n      weight: isSet(object.weight) ? String(object.weight) : \"\",\n    };\n  },\n\n  toJSON(message: WeightedVoteOption): unknown {\n    const obj: any = {};\n    message.option !== undefined &&\n      (obj.option = voteOptionToJSON(message.option));\n    message.weight !== undefined && (obj.weight = message.weight);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<WeightedVoteOption>, I>>(\n    object: I\n  ): WeightedVoteOption {\n    const message = createBaseWeightedVoteOption();\n    message.option = object.option ?? 0;\n    message.weight = object.weight ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseTextProposal(): TextProposal {\n  return { title: \"\", description: \"\" };\n}\n\nexport const TextProposal = {\n  encode(\n    message: TextProposal,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.title !== \"\") {\n      writer.uint32(10).string(message.title);\n    }\n    if (message.description !== \"\") {\n      writer.uint32(18).string(message.description);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): TextProposal {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTextProposal();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.title = reader.string();\n          break;\n        case 2:\n          message.description = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): TextProposal {\n    return {\n      title: isSet(object.title) ? String(object.title) : \"\",\n      description: isSet(object.description) ? String(object.description) : \"\",\n    };\n  },\n\n  toJSON(message: TextProposal): unknown {\n    const obj: any = {};\n    message.title !== undefined && (obj.title = message.title);\n    message.description !== undefined &&\n      (obj.description = message.description);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<TextProposal>, I>>(\n    object: I\n  ): TextProposal {\n    const message = createBaseTextProposal();\n    message.title = object.title ?? \"\";\n    message.description = object.description ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseDeposit(): Deposit {\n  return { proposalId: Long.UZERO, depositor: \"\", amount: [] };\n}\n\nexport const Deposit = {\n  encode(\n    message: Deposit,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.proposalId.isZero()) {\n      writer.uint32(8).uint64(message.proposalId);\n    }\n    if (message.depositor !== \"\") {\n      writer.uint32(18).string(message.depositor);\n    }\n    for (const v of message.amount) {\n      Coin.encode(v!, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Deposit {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDeposit();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.proposalId = reader.uint64() as Long;\n          break;\n        case 2:\n          message.depositor = reader.string();\n          break;\n        case 3:\n          message.amount.push(Coin.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Deposit {\n    return {\n      proposalId: isSet(object.proposalId)\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO,\n      depositor: isSet(object.depositor) ? String(object.depositor) : \"\",\n      amount: Array.isArray(object?.amount)\n        ? object.amount.map((e: any) => Coin.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: Deposit): unknown {\n    const obj: any = {};\n    message.proposalId !== undefined &&\n      (obj.proposalId = (message.proposalId || Long.UZERO).toString());\n    message.depositor !== undefined && (obj.depositor = message.depositor);\n    if (message.amount) {\n      obj.amount = message.amount.map((e) => (e ? Coin.toJSON(e) : undefined));\n    } else {\n      obj.amount = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Deposit>, I>>(object: I): Deposit {\n    const message = createBaseDeposit();\n    message.proposalId =\n      object.proposalId !== undefined && object.proposalId !== null\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO;\n    message.depositor = object.depositor ?? \"\";\n    message.amount = object.amount?.map((e) => Coin.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseProposal(): Proposal {\n  return {\n    proposalId: Long.UZERO,\n    content: undefined,\n    status: 0,\n    finalTallyResult: undefined,\n    submitTime: undefined,\n    depositEndTime: undefined,\n    totalDeposit: [],\n    votingStartTime: undefined,\n    votingEndTime: undefined,\n  };\n}\n\nexport const Proposal = {\n  encode(\n    message: Proposal,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.proposalId.isZero()) {\n      writer.uint32(8).uint64(message.proposalId);\n    }\n    if (message.content !== undefined) {\n      Any.encode(message.content, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.status !== 0) {\n      writer.uint32(24).int32(message.status);\n    }\n    if (message.finalTallyResult !== undefined) {\n      TallyResult.encode(\n        message.finalTallyResult,\n        writer.uint32(34).fork()\n      ).ldelim();\n    }\n    if (message.submitTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.submitTime),\n        writer.uint32(42).fork()\n      ).ldelim();\n    }\n    if (message.depositEndTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.depositEndTime),\n        writer.uint32(50).fork()\n      ).ldelim();\n    }\n    for (const v of message.totalDeposit) {\n      Coin.encode(v!, writer.uint32(58).fork()).ldelim();\n    }\n    if (message.votingStartTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.votingStartTime),\n        writer.uint32(66).fork()\n      ).ldelim();\n    }\n    if (message.votingEndTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.votingEndTime),\n        writer.uint32(74).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Proposal {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseProposal();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.proposalId = reader.uint64() as Long;\n          break;\n        case 2:\n          message.content = Any.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.status = reader.int32() as any;\n          break;\n        case 4:\n          message.finalTallyResult = TallyResult.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n        case 5:\n          message.submitTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        case 6:\n          message.depositEndTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        case 7:\n          message.totalDeposit.push(Coin.decode(reader, reader.uint32()));\n          break;\n        case 8:\n          message.votingStartTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        case 9:\n          message.votingEndTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Proposal {\n    return {\n      proposalId: isSet(object.proposalId)\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO,\n      content: isSet(object.content) ? Any.fromJSON(object.content) : undefined,\n      status: isSet(object.status) ? proposalStatusFromJSON(object.status) : 0,\n      finalTallyResult: isSet(object.finalTallyResult)\n        ? TallyResult.fromJSON(object.finalTallyResult)\n        : undefined,\n      submitTime: isSet(object.submitTime)\n        ? fromJsonTimestamp(object.submitTime)\n        : undefined,\n      depositEndTime: isSet(object.depositEndTime)\n        ? fromJsonTimestamp(object.depositEndTime)\n        : undefined,\n      totalDeposit: Array.isArray(object?.totalDeposit)\n        ? object.totalDeposit.map((e: any) => Coin.fromJSON(e))\n        : [],\n      votingStartTime: isSet(object.votingStartTime)\n        ? fromJsonTimestamp(object.votingStartTime)\n        : undefined,\n      votingEndTime: isSet(object.votingEndTime)\n        ? fromJsonTimestamp(object.votingEndTime)\n        : undefined,\n    };\n  },\n\n  toJSON(message: Proposal): unknown {\n    const obj: any = {};\n    message.proposalId !== undefined &&\n      (obj.proposalId = (message.proposalId || Long.UZERO).toString());\n    message.content !== undefined &&\n      (obj.content = message.content ? Any.toJSON(message.content) : undefined);\n    message.status !== undefined &&\n      (obj.status = proposalStatusToJSON(message.status));\n    message.finalTallyResult !== undefined &&\n      (obj.finalTallyResult = message.finalTallyResult\n        ? TallyResult.toJSON(message.finalTallyResult)\n        : undefined);\n    message.submitTime !== undefined &&\n      (obj.submitTime = message.submitTime.toISOString());\n    message.depositEndTime !== undefined &&\n      (obj.depositEndTime = message.depositEndTime.toISOString());\n    if (message.totalDeposit) {\n      obj.totalDeposit = message.totalDeposit.map((e) =>\n        e ? Coin.toJSON(e) : undefined\n      );\n    } else {\n      obj.totalDeposit = [];\n    }\n    message.votingStartTime !== undefined &&\n      (obj.votingStartTime = message.votingStartTime.toISOString());\n    message.votingEndTime !== undefined &&\n      (obj.votingEndTime = message.votingEndTime.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Proposal>, I>>(object: I): Proposal {\n    const message = createBaseProposal();\n    message.proposalId =\n      object.proposalId !== undefined && object.proposalId !== null\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO;\n    message.content =\n      object.content !== undefined && object.content !== null\n        ? Any.fromPartial(object.content)\n        : undefined;\n    message.status = object.status ?? 0;\n    message.finalTallyResult =\n      object.finalTallyResult !== undefined && object.finalTallyResult !== null\n        ? TallyResult.fromPartial(object.finalTallyResult)\n        : undefined;\n    message.submitTime = object.submitTime ?? undefined;\n    message.depositEndTime = object.depositEndTime ?? undefined;\n    message.totalDeposit =\n      object.totalDeposit?.map((e) => Coin.fromPartial(e)) || [];\n    message.votingStartTime = object.votingStartTime ?? undefined;\n    message.votingEndTime = object.votingEndTime ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseTallyResult(): TallyResult {\n  return { yes: \"\", abstain: \"\", no: \"\", noWithVeto: \"\" };\n}\n\nexport const TallyResult = {\n  encode(\n    message: TallyResult,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.yes !== \"\") {\n      writer.uint32(10).string(message.yes);\n    }\n    if (message.abstain !== \"\") {\n      writer.uint32(18).string(message.abstain);\n    }\n    if (message.no !== \"\") {\n      writer.uint32(26).string(message.no);\n    }\n    if (message.noWithVeto !== \"\") {\n      writer.uint32(34).string(message.noWithVeto);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): TallyResult {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTallyResult();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.yes = reader.string();\n          break;\n        case 2:\n          message.abstain = reader.string();\n          break;\n        case 3:\n          message.no = reader.string();\n          break;\n        case 4:\n          message.noWithVeto = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): TallyResult {\n    return {\n      yes: isSet(object.yes) ? String(object.yes) : \"\",\n      abstain: isSet(object.abstain) ? String(object.abstain) : \"\",\n      no: isSet(object.no) ? String(object.no) : \"\",\n      noWithVeto: isSet(object.noWithVeto) ? String(object.noWithVeto) : \"\",\n    };\n  },\n\n  toJSON(message: TallyResult): unknown {\n    const obj: any = {};\n    message.yes !== undefined && (obj.yes = message.yes);\n    message.abstain !== undefined && (obj.abstain = message.abstain);\n    message.no !== undefined && (obj.no = message.no);\n    message.noWithVeto !== undefined && (obj.noWithVeto = message.noWithVeto);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<TallyResult>, I>>(\n    object: I\n  ): TallyResult {\n    const message = createBaseTallyResult();\n    message.yes = object.yes ?? \"\";\n    message.abstain = object.abstain ?? \"\";\n    message.no = object.no ?? \"\";\n    message.noWithVeto = object.noWithVeto ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseVote(): Vote {\n  return { proposalId: Long.UZERO, voter: \"\", option: 0, options: [] };\n}\n\nexport const Vote = {\n  encode(message: Vote, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (!message.proposalId.isZero()) {\n      writer.uint32(8).uint64(message.proposalId);\n    }\n    if (message.voter !== \"\") {\n      writer.uint32(18).string(message.voter);\n    }\n    if (message.option !== 0) {\n      writer.uint32(24).int32(message.option);\n    }\n    for (const v of message.options) {\n      WeightedVoteOption.encode(v!, writer.uint32(34).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Vote {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseVote();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.proposalId = reader.uint64() as Long;\n          break;\n        case 2:\n          message.voter = reader.string();\n          break;\n        case 3:\n          message.option = reader.int32() as any;\n          break;\n        case 4:\n          message.options.push(\n            WeightedVoteOption.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Vote {\n    return {\n      proposalId: isSet(object.proposalId)\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO,\n      voter: isSet(object.voter) ? String(object.voter) : \"\",\n      option: isSet(object.option) ? voteOptionFromJSON(object.option) : 0,\n      options: Array.isArray(object?.options)\n        ? object.options.map((e: any) => WeightedVoteOption.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: Vote): unknown {\n    const obj: any = {};\n    message.proposalId !== undefined &&\n      (obj.proposalId = (message.proposalId || Long.UZERO).toString());\n    message.voter !== undefined && (obj.voter = message.voter);\n    message.option !== undefined &&\n      (obj.option = voteOptionToJSON(message.option));\n    if (message.options) {\n      obj.options = message.options.map((e) =>\n        e ? WeightedVoteOption.toJSON(e) : undefined\n      );\n    } else {\n      obj.options = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Vote>, I>>(object: I): Vote {\n    const message = createBaseVote();\n    message.proposalId =\n      object.proposalId !== undefined && object.proposalId !== null\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO;\n    message.voter = object.voter ?? \"\";\n    message.option = object.option ?? 0;\n    message.options =\n      object.options?.map((e) => WeightedVoteOption.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseDepositParams(): DepositParams {\n  return { minDeposit: [], maxDepositPeriod: undefined };\n}\n\nexport const DepositParams = {\n  encode(\n    message: DepositParams,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.minDeposit) {\n      Coin.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.maxDepositPeriod !== undefined) {\n      Duration.encode(\n        message.maxDepositPeriod,\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): DepositParams {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDepositParams();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.minDeposit.push(Coin.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.maxDepositPeriod = Duration.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): DepositParams {\n    return {\n      minDeposit: Array.isArray(object?.minDeposit)\n        ? object.minDeposit.map((e: any) => Coin.fromJSON(e))\n        : [],\n      maxDepositPeriod: isSet(object.maxDepositPeriod)\n        ? Duration.fromJSON(object.maxDepositPeriod)\n        : undefined,\n    };\n  },\n\n  toJSON(message: DepositParams): unknown {\n    const obj: any = {};\n    if (message.minDeposit) {\n      obj.minDeposit = message.minDeposit.map((e) =>\n        e ? Coin.toJSON(e) : undefined\n      );\n    } else {\n      obj.minDeposit = [];\n    }\n    message.maxDepositPeriod !== undefined &&\n      (obj.maxDepositPeriod = message.maxDepositPeriod\n        ? Duration.toJSON(message.maxDepositPeriod)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<DepositParams>, I>>(\n    object: I\n  ): DepositParams {\n    const message = createBaseDepositParams();\n    message.minDeposit =\n      object.minDeposit?.map((e) => Coin.fromPartial(e)) || [];\n    message.maxDepositPeriod =\n      object.maxDepositPeriod !== undefined && object.maxDepositPeriod !== null\n        ? Duration.fromPartial(object.maxDepositPeriod)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseVotingParams(): VotingParams {\n  return { votingPeriod: undefined };\n}\n\nexport const VotingParams = {\n  encode(\n    message: VotingParams,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.votingPeriod !== undefined) {\n      Duration.encode(message.votingPeriod, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): VotingParams {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseVotingParams();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.votingPeriod = Duration.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): VotingParams {\n    return {\n      votingPeriod: isSet(object.votingPeriod)\n        ? Duration.fromJSON(object.votingPeriod)\n        : undefined,\n    };\n  },\n\n  toJSON(message: VotingParams): unknown {\n    const obj: any = {};\n    message.votingPeriod !== undefined &&\n      (obj.votingPeriod = message.votingPeriod\n        ? Duration.toJSON(message.votingPeriod)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<VotingParams>, I>>(\n    object: I\n  ): VotingParams {\n    const message = createBaseVotingParams();\n    message.votingPeriod =\n      object.votingPeriod !== undefined && object.votingPeriod !== null\n        ? Duration.fromPartial(object.votingPeriod)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseTallyParams(): TallyParams {\n  return {\n    quorum: new Uint8Array(),\n    threshold: new Uint8Array(),\n    vetoThreshold: new Uint8Array(),\n  };\n}\n\nexport const TallyParams = {\n  encode(\n    message: TallyParams,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.quorum.length !== 0) {\n      writer.uint32(10).bytes(message.quorum);\n    }\n    if (message.threshold.length !== 0) {\n      writer.uint32(18).bytes(message.threshold);\n    }\n    if (message.vetoThreshold.length !== 0) {\n      writer.uint32(26).bytes(message.vetoThreshold);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): TallyParams {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTallyParams();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.quorum = reader.bytes();\n          break;\n        case 2:\n          message.threshold = reader.bytes();\n          break;\n        case 3:\n          message.vetoThreshold = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): TallyParams {\n    return {\n      quorum: isSet(object.quorum)\n        ? bytesFromBase64(object.quorum)\n        : new Uint8Array(),\n      threshold: isSet(object.threshold)\n        ? bytesFromBase64(object.threshold)\n        : new Uint8Array(),\n      vetoThreshold: isSet(object.vetoThreshold)\n        ? bytesFromBase64(object.vetoThreshold)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: TallyParams): unknown {\n    const obj: any = {};\n    message.quorum !== undefined &&\n      (obj.quorum = base64FromBytes(\n        message.quorum !== undefined ? message.quorum : new Uint8Array()\n      ));\n    message.threshold !== undefined &&\n      (obj.threshold = base64FromBytes(\n        message.threshold !== undefined ? message.threshold : new Uint8Array()\n      ));\n    message.vetoThreshold !== undefined &&\n      (obj.vetoThreshold = base64FromBytes(\n        message.vetoThreshold !== undefined\n          ? message.vetoThreshold\n          : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<TallyParams>, I>>(\n    object: I\n  ): TallyParams {\n    const message = createBaseTallyParams();\n    message.quorum = object.quorum ?? new Uint8Array();\n    message.threshold = object.threshold ?? new Uint8Array();\n    message.vetoThreshold = object.vetoThreshold ?? new Uint8Array();\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nfunction toTimestamp(date: Date): Timestamp {\n  const seconds = numberToLong(date.getTime() / 1_000);\n  const nanos = (date.getTime() % 1_000) * 1_000_000;\n  return { seconds, nanos };\n}\n\nfunction fromTimestamp(t: Timestamp): Date {\n  let millis = t.seconds.toNumber() * 1_000;\n  millis += t.nanos / 1_000_000;\n  return new Date(millis);\n}\n\nfunction fromJsonTimestamp(o: any): Date {\n  if (o instanceof Date) {\n    return o;\n  } else if (typeof o === \"string\") {\n    return new Date(o);\n  } else {\n    return fromTimestamp(Timestamp.fromJSON(o));\n  }\n}\n\nfunction numberToLong(number: number) {\n  return Long.fromNumber(number);\n}\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport { grpc } from \"@improbable-eng/grpc-web\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Any } from \"../../../google/protobuf/any\";\nimport {\n  VoteOption,\n  WeightedVoteOption,\n  voteOptionFromJSON,\n  voteOptionToJSON,\n} from \"./gov\";\nimport { BrowserHeaders } from \"browser-headers\";\nimport { Coin } from \"../../base/v1beta1/coin\";\n\nexport const protobufPackage = \"cosmos.gov.v1beta1\";\n\n/**\n * MsgSubmitProposal defines an sdk.Msg type that supports submitting arbitrary\n * proposal Content.\n */\nexport interface MsgSubmitProposal {\n  content?: Any;\n  initialDeposit: Coin[];\n  proposer: string;\n}\n\n/** MsgSubmitProposalResponse defines the Msg/SubmitProposal response type. */\nexport interface MsgSubmitProposalResponse {\n  proposalId: Long;\n}\n\n/** MsgVote defines a message to cast a vote. */\nexport interface MsgVote {\n  proposalId: Long;\n  voter: string;\n  option: VoteOption;\n}\n\n/** MsgVoteResponse defines the Msg/Vote response type. */\nexport interface MsgVoteResponse {}\n\n/**\n * MsgVoteWeighted defines a message to cast a vote.\n *\n * Since: cosmos-sdk 0.43\n */\nexport interface MsgVoteWeighted {\n  proposalId: Long;\n  voter: string;\n  options: WeightedVoteOption[];\n}\n\n/**\n * MsgVoteWeightedResponse defines the Msg/VoteWeighted response type.\n *\n * Since: cosmos-sdk 0.43\n */\nexport interface MsgVoteWeightedResponse {}\n\n/** MsgDeposit defines a message to submit a deposit to an existing proposal. */\nexport interface MsgDeposit {\n  proposalId: Long;\n  depositor: string;\n  amount: Coin[];\n}\n\n/** MsgDepositResponse defines the Msg/Deposit response type. */\nexport interface MsgDepositResponse {}\n\nfunction createBaseMsgSubmitProposal(): MsgSubmitProposal {\n  return { content: undefined, initialDeposit: [], proposer: \"\" };\n}\n\nexport const MsgSubmitProposal = {\n  encode(\n    message: MsgSubmitProposal,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.content !== undefined) {\n      Any.encode(message.content, writer.uint32(10).fork()).ldelim();\n    }\n    for (const v of message.initialDeposit) {\n      Coin.encode(v!, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.proposer !== \"\") {\n      writer.uint32(26).string(message.proposer);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSubmitProposal {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgSubmitProposal();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.content = Any.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.initialDeposit.push(Coin.decode(reader, reader.uint32()));\n          break;\n        case 3:\n          message.proposer = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgSubmitProposal {\n    return {\n      content: isSet(object.content) ? Any.fromJSON(object.content) : undefined,\n      initialDeposit: Array.isArray(object?.initialDeposit)\n        ? object.initialDeposit.map((e: any) => Coin.fromJSON(e))\n        : [],\n      proposer: isSet(object.proposer) ? String(object.proposer) : \"\",\n    };\n  },\n\n  toJSON(message: MsgSubmitProposal): unknown {\n    const obj: any = {};\n    message.content !== undefined &&\n      (obj.content = message.content ? Any.toJSON(message.content) : undefined);\n    if (message.initialDeposit) {\n      obj.initialDeposit = message.initialDeposit.map((e) =>\n        e ? Coin.toJSON(e) : undefined\n      );\n    } else {\n      obj.initialDeposit = [];\n    }\n    message.proposer !== undefined && (obj.proposer = message.proposer);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgSubmitProposal>, I>>(\n    object: I\n  ): MsgSubmitProposal {\n    const message = createBaseMsgSubmitProposal();\n    message.content =\n      object.content !== undefined && object.content !== null\n        ? Any.fromPartial(object.content)\n        : undefined;\n    message.initialDeposit =\n      object.initialDeposit?.map((e) => Coin.fromPartial(e)) || [];\n    message.proposer = object.proposer ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgSubmitProposalResponse(): MsgSubmitProposalResponse {\n  return { proposalId: Long.UZERO };\n}\n\nexport const MsgSubmitProposalResponse = {\n  encode(\n    message: MsgSubmitProposalResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.proposalId.isZero()) {\n      writer.uint32(8).uint64(message.proposalId);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgSubmitProposalResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgSubmitProposalResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.proposalId = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgSubmitProposalResponse {\n    return {\n      proposalId: isSet(object.proposalId)\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO,\n    };\n  },\n\n  toJSON(message: MsgSubmitProposalResponse): unknown {\n    const obj: any = {};\n    message.proposalId !== undefined &&\n      (obj.proposalId = (message.proposalId || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgSubmitProposalResponse>, I>>(\n    object: I\n  ): MsgSubmitProposalResponse {\n    const message = createBaseMsgSubmitProposalResponse();\n    message.proposalId =\n      object.proposalId !== undefined && object.proposalId !== null\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseMsgVote(): MsgVote {\n  return { proposalId: Long.UZERO, voter: \"\", option: 0 };\n}\n\nexport const MsgVote = {\n  encode(\n    message: MsgVote,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.proposalId.isZero()) {\n      writer.uint32(8).uint64(message.proposalId);\n    }\n    if (message.voter !== \"\") {\n      writer.uint32(18).string(message.voter);\n    }\n    if (message.option !== 0) {\n      writer.uint32(24).int32(message.option);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgVote {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgVote();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.proposalId = reader.uint64() as Long;\n          break;\n        case 2:\n          message.voter = reader.string();\n          break;\n        case 3:\n          message.option = reader.int32() as any;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgVote {\n    return {\n      proposalId: isSet(object.proposalId)\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO,\n      voter: isSet(object.voter) ? String(object.voter) : \"\",\n      option: isSet(object.option) ? voteOptionFromJSON(object.option) : 0,\n    };\n  },\n\n  toJSON(message: MsgVote): unknown {\n    const obj: any = {};\n    message.proposalId !== undefined &&\n      (obj.proposalId = (message.proposalId || Long.UZERO).toString());\n    message.voter !== undefined && (obj.voter = message.voter);\n    message.option !== undefined &&\n      (obj.option = voteOptionToJSON(message.option));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgVote>, I>>(object: I): MsgVote {\n    const message = createBaseMsgVote();\n    message.proposalId =\n      object.proposalId !== undefined && object.proposalId !== null\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO;\n    message.voter = object.voter ?? \"\";\n    message.option = object.option ?? 0;\n    return message;\n  },\n};\n\nfunction createBaseMsgVoteResponse(): MsgVoteResponse {\n  return {};\n}\n\nexport const MsgVoteResponse = {\n  encode(\n    _: MsgVoteResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgVoteResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgVoteResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgVoteResponse {\n    return {};\n  },\n\n  toJSON(_: MsgVoteResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgVoteResponse>, I>>(\n    _: I\n  ): MsgVoteResponse {\n    const message = createBaseMsgVoteResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgVoteWeighted(): MsgVoteWeighted {\n  return { proposalId: Long.UZERO, voter: \"\", options: [] };\n}\n\nexport const MsgVoteWeighted = {\n  encode(\n    message: MsgVoteWeighted,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.proposalId.isZero()) {\n      writer.uint32(8).uint64(message.proposalId);\n    }\n    if (message.voter !== \"\") {\n      writer.uint32(18).string(message.voter);\n    }\n    for (const v of message.options) {\n      WeightedVoteOption.encode(v!, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgVoteWeighted {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgVoteWeighted();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.proposalId = reader.uint64() as Long;\n          break;\n        case 2:\n          message.voter = reader.string();\n          break;\n        case 3:\n          message.options.push(\n            WeightedVoteOption.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgVoteWeighted {\n    return {\n      proposalId: isSet(object.proposalId)\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO,\n      voter: isSet(object.voter) ? String(object.voter) : \"\",\n      options: Array.isArray(object?.options)\n        ? object.options.map((e: any) => WeightedVoteOption.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: MsgVoteWeighted): unknown {\n    const obj: any = {};\n    message.proposalId !== undefined &&\n      (obj.proposalId = (message.proposalId || Long.UZERO).toString());\n    message.voter !== undefined && (obj.voter = message.voter);\n    if (message.options) {\n      obj.options = message.options.map((e) =>\n        e ? WeightedVoteOption.toJSON(e) : undefined\n      );\n    } else {\n      obj.options = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgVoteWeighted>, I>>(\n    object: I\n  ): MsgVoteWeighted {\n    const message = createBaseMsgVoteWeighted();\n    message.proposalId =\n      object.proposalId !== undefined && object.proposalId !== null\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO;\n    message.voter = object.voter ?? \"\";\n    message.options =\n      object.options?.map((e) => WeightedVoteOption.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseMsgVoteWeightedResponse(): MsgVoteWeightedResponse {\n  return {};\n}\n\nexport const MsgVoteWeightedResponse = {\n  encode(\n    _: MsgVoteWeightedResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgVoteWeightedResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgVoteWeightedResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgVoteWeightedResponse {\n    return {};\n  },\n\n  toJSON(_: MsgVoteWeightedResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgVoteWeightedResponse>, I>>(\n    _: I\n  ): MsgVoteWeightedResponse {\n    const message = createBaseMsgVoteWeightedResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgDeposit(): MsgDeposit {\n  return { proposalId: Long.UZERO, depositor: \"\", amount: [] };\n}\n\nexport const MsgDeposit = {\n  encode(\n    message: MsgDeposit,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.proposalId.isZero()) {\n      writer.uint32(8).uint64(message.proposalId);\n    }\n    if (message.depositor !== \"\") {\n      writer.uint32(18).string(message.depositor);\n    }\n    for (const v of message.amount) {\n      Coin.encode(v!, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgDeposit {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgDeposit();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.proposalId = reader.uint64() as Long;\n          break;\n        case 2:\n          message.depositor = reader.string();\n          break;\n        case 3:\n          message.amount.push(Coin.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgDeposit {\n    return {\n      proposalId: isSet(object.proposalId)\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO,\n      depositor: isSet(object.depositor) ? String(object.depositor) : \"\",\n      amount: Array.isArray(object?.amount)\n        ? object.amount.map((e: any) => Coin.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: MsgDeposit): unknown {\n    const obj: any = {};\n    message.proposalId !== undefined &&\n      (obj.proposalId = (message.proposalId || Long.UZERO).toString());\n    message.depositor !== undefined && (obj.depositor = message.depositor);\n    if (message.amount) {\n      obj.amount = message.amount.map((e) => (e ? Coin.toJSON(e) : undefined));\n    } else {\n      obj.amount = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgDeposit>, I>>(\n    object: I\n  ): MsgDeposit {\n    const message = createBaseMsgDeposit();\n    message.proposalId =\n      object.proposalId !== undefined && object.proposalId !== null\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO;\n    message.depositor = object.depositor ?? \"\";\n    message.amount = object.amount?.map((e) => Coin.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseMsgDepositResponse(): MsgDepositResponse {\n  return {};\n}\n\nexport const MsgDepositResponse = {\n  encode(\n    _: MsgDepositResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgDepositResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgDepositResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgDepositResponse {\n    return {};\n  },\n\n  toJSON(_: MsgDepositResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgDepositResponse>, I>>(\n    _: I\n  ): MsgDepositResponse {\n    const message = createBaseMsgDepositResponse();\n    return message;\n  },\n};\n\n/** Msg defines the bank Msg service. */\nexport interface Msg {\n  /** SubmitProposal defines a method to create new proposal given a content. */\n  SubmitProposal(\n    request: DeepPartial<MsgSubmitProposal>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgSubmitProposalResponse>;\n  /** Vote defines a method to add a vote on a specific proposal. */\n  Vote(\n    request: DeepPartial<MsgVote>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgVoteResponse>;\n  /**\n   * VoteWeighted defines a method to add a weighted vote on a specific proposal.\n   *\n   * Since: cosmos-sdk 0.43\n   */\n  VoteWeighted(\n    request: DeepPartial<MsgVoteWeighted>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgVoteWeightedResponse>;\n  /** Deposit defines a method to add deposit on a specific proposal. */\n  Deposit(\n    request: DeepPartial<MsgDeposit>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgDepositResponse>;\n}\n\nexport class MsgClientImpl implements Msg {\n  private readonly rpc: Rpc;\n\n  constructor(rpc: Rpc) {\n    this.rpc = rpc;\n    this.SubmitProposal = this.SubmitProposal.bind(this);\n    this.Vote = this.Vote.bind(this);\n    this.VoteWeighted = this.VoteWeighted.bind(this);\n    this.Deposit = this.Deposit.bind(this);\n  }\n\n  SubmitProposal(\n    request: DeepPartial<MsgSubmitProposal>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgSubmitProposalResponse> {\n    return this.rpc.unary(\n      MsgSubmitProposalDesc,\n      MsgSubmitProposal.fromPartial(request),\n      metadata\n    );\n  }\n\n  Vote(\n    request: DeepPartial<MsgVote>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgVoteResponse> {\n    return this.rpc.unary(MsgVoteDesc, MsgVote.fromPartial(request), metadata);\n  }\n\n  VoteWeighted(\n    request: DeepPartial<MsgVoteWeighted>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgVoteWeightedResponse> {\n    return this.rpc.unary(\n      MsgVoteWeightedDesc,\n      MsgVoteWeighted.fromPartial(request),\n      metadata\n    );\n  }\n\n  Deposit(\n    request: DeepPartial<MsgDeposit>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgDepositResponse> {\n    return this.rpc.unary(\n      MsgDepositDesc,\n      MsgDeposit.fromPartial(request),\n      metadata\n    );\n  }\n}\n\nexport const MsgDesc = {\n  serviceName: \"cosmos.gov.v1beta1.Msg\",\n};\n\nexport const MsgSubmitProposalDesc: UnaryMethodDefinitionish = {\n  methodName: \"SubmitProposal\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgSubmitProposal.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgSubmitProposalResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgVoteDesc: UnaryMethodDefinitionish = {\n  methodName: \"Vote\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgVote.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgVoteResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgVoteWeightedDesc: UnaryMethodDefinitionish = {\n  methodName: \"VoteWeighted\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgVoteWeighted.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgVoteWeightedResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgDepositDesc: UnaryMethodDefinitionish = {\n  methodName: \"Deposit\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgDeposit.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgDepositResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\ninterface UnaryMethodDefinitionishR\n  extends grpc.UnaryMethodDefinition<any, any> {\n  requestStream: any;\n  responseStream: any;\n}\n\ntype UnaryMethodDefinitionish = UnaryMethodDefinitionishR;\n\ninterface Rpc {\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any>;\n}\n\nexport class GrpcWebImpl {\n  private host: string;\n  private options: {\n    transport?: grpc.TransportFactory;\n\n    debug?: boolean;\n    metadata?: grpc.Metadata;\n  };\n\n  constructor(\n    host: string,\n    options: {\n      transport?: grpc.TransportFactory;\n\n      debug?: boolean;\n      metadata?: grpc.Metadata;\n    }\n  ) {\n    this.host = host;\n    this.options = options;\n  }\n\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    _request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any> {\n    const request = { ..._request, ...methodDesc.requestType };\n    const maybeCombinedMetadata =\n      metadata && this.options.metadata\n        ? new BrowserHeaders({\n            ...this.options?.metadata.headersMap,\n            ...metadata?.headersMap,\n          })\n        : metadata || this.options.metadata;\n    return new Promise((resolve, reject) => {\n      grpc.unary(methodDesc, {\n        request,\n        host: this.host,\n        metadata: maybeCombinedMetadata,\n        transport: this.options.transport,\n        debug: this.options.debug,\n        onEnd: function (response) {\n          if (response.status === grpc.Code.OK) {\n            resolve(response.message);\n          } else {\n            const err = new Error(response.statusMessage) as any;\n            err.code = response.status;\n            err.metadata = response.trailers;\n            reject(err);\n          }\n        },\n      });\n    });\n  }\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","import { BaseMsg } from '../BaseMsg';\nimport {\n  protobufPackage,\n  MsgSubmitProposal as MsgSubmitProposal_pb,\n  MsgVote as MsgVote_pb,\n  MsgVoteWeighted as MsgVoteWeighted_pb,\n  MsgDeposit as MsgDeposit_pb,\n} from \"../../proto/cosmos/gov/v1beta1/tx\";\nimport {EncodeObject} from \"@cosmjs/proto-signing\";\n\nexport class MsgSubmitProposal extends BaseMsg {\n  public protoMsg: MsgSubmitProposal_pb;\n  constructor(msg: MsgSubmitProposal_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgSubmitProposal.typeUrl,\n      value: MsgSubmitProposal_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgSubmitProposal {\n  export const typeUrl: string = `/${protobufPackage}.MsgSubmitProposal`;\n  export const Proto = MsgSubmitProposal_pb;\n  export interface Proto extends MsgSubmitProposal_pb {}\n}\n\nexport class MsgDeposit extends BaseMsg {\n  public protoMsg: MsgDeposit_pb;\n  constructor(msg: MsgDeposit_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgDeposit.typeUrl,\n      value: MsgDeposit_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgDeposit {\n  export const typeUrl: string = `/${protobufPackage}.MsgDeposit`;\n  export const Proto = MsgDeposit_pb;\n  export interface Proto extends MsgDeposit_pb {}\n}\n\nexport class MsgVote extends BaseMsg {\n  public protoMsg: MsgVote_pb;\n  constructor(msg: MsgVote_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgVote.typeUrl,\n      value: MsgVote_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgVote {\n  export const typeUrl: string = `/${protobufPackage}.MsgVote`;\n  export const Proto = MsgVote_pb;\n  export interface Proto extends MsgVote_pb {}\n}\n\nexport class MsgVoteWeighted extends BaseMsg {\n  public protoMsg: MsgVoteWeighted_pb;\n  constructor(msg: MsgVoteWeighted_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgVoteWeighted.typeUrl,\n      value: MsgVoteWeighted_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgVoteWeighted {\n  export const typeUrl: string = `/${protobufPackage}.MsgVoteWeighted`;\n  export const Proto = MsgVoteWeighted_pb;\n  export interface Proto extends MsgVoteWeighted_pb {}\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport { grpc } from \"@improbable-eng/grpc-web\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { BrowserHeaders } from \"browser-headers\";\nimport { Coin } from \"../../base/v1beta1/coin\";\n\nexport const protobufPackage = \"cosmos.vesting.v1beta1\";\n\n/**\n * MsgCreateVestingAccount defines a message that enables creating a vesting\n * account.\n */\nexport interface MsgCreateVestingAccount {\n  fromAddress: string;\n  toAddress: string;\n  amount: Coin[];\n  endTime: Long;\n  delayed: boolean;\n}\n\n/** MsgCreateVestingAccountResponse defines the Msg/CreateVestingAccount response type. */\nexport interface MsgCreateVestingAccountResponse {}\n\nfunction createBaseMsgCreateVestingAccount(): MsgCreateVestingAccount {\n  return {\n    fromAddress: \"\",\n    toAddress: \"\",\n    amount: [],\n    endTime: Long.ZERO,\n    delayed: false,\n  };\n}\n\nexport const MsgCreateVestingAccount = {\n  encode(\n    message: MsgCreateVestingAccount,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.fromAddress !== \"\") {\n      writer.uint32(10).string(message.fromAddress);\n    }\n    if (message.toAddress !== \"\") {\n      writer.uint32(18).string(message.toAddress);\n    }\n    for (const v of message.amount) {\n      Coin.encode(v!, writer.uint32(26).fork()).ldelim();\n    }\n    if (!message.endTime.isZero()) {\n      writer.uint32(32).int64(message.endTime);\n    }\n    if (message.delayed === true) {\n      writer.uint32(40).bool(message.delayed);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCreateVestingAccount {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCreateVestingAccount();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.fromAddress = reader.string();\n          break;\n        case 2:\n          message.toAddress = reader.string();\n          break;\n        case 3:\n          message.amount.push(Coin.decode(reader, reader.uint32()));\n          break;\n        case 4:\n          message.endTime = reader.int64() as Long;\n          break;\n        case 5:\n          message.delayed = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCreateVestingAccount {\n    return {\n      fromAddress: isSet(object.fromAddress) ? String(object.fromAddress) : \"\",\n      toAddress: isSet(object.toAddress) ? String(object.toAddress) : \"\",\n      amount: Array.isArray(object?.amount)\n        ? object.amount.map((e: any) => Coin.fromJSON(e))\n        : [],\n      endTime: isSet(object.endTime)\n        ? Long.fromValue(object.endTime)\n        : Long.ZERO,\n      delayed: isSet(object.delayed) ? Boolean(object.delayed) : false,\n    };\n  },\n\n  toJSON(message: MsgCreateVestingAccount): unknown {\n    const obj: any = {};\n    message.fromAddress !== undefined &&\n      (obj.fromAddress = message.fromAddress);\n    message.toAddress !== undefined && (obj.toAddress = message.toAddress);\n    if (message.amount) {\n      obj.amount = message.amount.map((e) => (e ? Coin.toJSON(e) : undefined));\n    } else {\n      obj.amount = [];\n    }\n    message.endTime !== undefined &&\n      (obj.endTime = (message.endTime || Long.ZERO).toString());\n    message.delayed !== undefined && (obj.delayed = message.delayed);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCreateVestingAccount>, I>>(\n    object: I\n  ): MsgCreateVestingAccount {\n    const message = createBaseMsgCreateVestingAccount();\n    message.fromAddress = object.fromAddress ?? \"\";\n    message.toAddress = object.toAddress ?? \"\";\n    message.amount = object.amount?.map((e) => Coin.fromPartial(e)) || [];\n    message.endTime =\n      object.endTime !== undefined && object.endTime !== null\n        ? Long.fromValue(object.endTime)\n        : Long.ZERO;\n    message.delayed = object.delayed ?? false;\n    return message;\n  },\n};\n\nfunction createBaseMsgCreateVestingAccountResponse(): MsgCreateVestingAccountResponse {\n  return {};\n}\n\nexport const MsgCreateVestingAccountResponse = {\n  encode(\n    _: MsgCreateVestingAccountResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCreateVestingAccountResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCreateVestingAccountResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCreateVestingAccountResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCreateVestingAccountResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCreateVestingAccountResponse>, I>>(\n    _: I\n  ): MsgCreateVestingAccountResponse {\n    const message = createBaseMsgCreateVestingAccountResponse();\n    return message;\n  },\n};\n\n/** Msg defines the bank Msg service. */\nexport interface Msg {\n  /**\n   * CreateVestingAccount defines a method that enables creating a vesting\n   * account.\n   */\n  CreateVestingAccount(\n    request: DeepPartial<MsgCreateVestingAccount>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCreateVestingAccountResponse>;\n}\n\nexport class MsgClientImpl implements Msg {\n  private readonly rpc: Rpc;\n\n  constructor(rpc: Rpc) {\n    this.rpc = rpc;\n    this.CreateVestingAccount = this.CreateVestingAccount.bind(this);\n  }\n\n  CreateVestingAccount(\n    request: DeepPartial<MsgCreateVestingAccount>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCreateVestingAccountResponse> {\n    return this.rpc.unary(\n      MsgCreateVestingAccountDesc,\n      MsgCreateVestingAccount.fromPartial(request),\n      metadata\n    );\n  }\n}\n\nexport const MsgDesc = {\n  serviceName: \"cosmos.vesting.v1beta1.Msg\",\n};\n\nexport const MsgCreateVestingAccountDesc: UnaryMethodDefinitionish = {\n  methodName: \"CreateVestingAccount\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCreateVestingAccount.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCreateVestingAccountResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\ninterface UnaryMethodDefinitionishR\n  extends grpc.UnaryMethodDefinition<any, any> {\n  requestStream: any;\n  responseStream: any;\n}\n\ntype UnaryMethodDefinitionish = UnaryMethodDefinitionishR;\n\ninterface Rpc {\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any>;\n}\n\nexport class GrpcWebImpl {\n  private host: string;\n  private options: {\n    transport?: grpc.TransportFactory;\n\n    debug?: boolean;\n    metadata?: grpc.Metadata;\n  };\n\n  constructor(\n    host: string,\n    options: {\n      transport?: grpc.TransportFactory;\n\n      debug?: boolean;\n      metadata?: grpc.Metadata;\n    }\n  ) {\n    this.host = host;\n    this.options = options;\n  }\n\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    _request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any> {\n    const request = { ..._request, ...methodDesc.requestType };\n    const maybeCombinedMetadata =\n      metadata && this.options.metadata\n        ? new BrowserHeaders({\n            ...this.options?.metadata.headersMap,\n            ...metadata?.headersMap,\n          })\n        : metadata || this.options.metadata;\n    return new Promise((resolve, reject) => {\n      grpc.unary(methodDesc, {\n        request,\n        host: this.host,\n        metadata: maybeCombinedMetadata,\n        transport: this.options.transport,\n        debug: this.options.debug,\n        onEnd: function (response) {\n          if (response.status === grpc.Code.OK) {\n            resolve(response.message);\n          } else {\n            const err = new Error(response.statusMessage) as any;\n            err.code = response.status;\n            err.metadata = response.trailers;\n            reject(err);\n          }\n        },\n      });\n    });\n  }\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","import { BaseMsg } from \"../BaseMsg\";\nimport { EncodeObject } from \"@cosmjs/proto-signing\";\nimport {\n  protobufPackage,\n  MsgCreateVestingAccount as MsgCreateVestingAccount_pb,\n} from \"../../proto/cosmos/vesting/v1beta1/tx\";\n\nexport class MsgCreateVestingAccount extends BaseMsg {\n  public protoMsg: MsgCreateVestingAccount_pb;\n  constructor(msg: MsgCreateVestingAccount_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgCreateVestingAccount.typeUrl,\n      value: MsgCreateVestingAccount_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgCreateVestingAccount {\n  export const typeUrl: string = `/${protobufPackage}.MsgCreateVestingAccount`;\n  export const Proto = MsgCreateVestingAccount_pb;\n  export interface Proto extends MsgCreateVestingAccount_pb {}\n}\n\n\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"metaoslabs.metaos.deflation\";\n\nexport interface Repurchase {\n  denom: string;\n  sellMinAmount: string;\n  sellMaxAmount: string;\n  denoms: string[];\n  fees: number[];\n}\n\nfunction createBaseRepurchase(): Repurchase {\n  return {\n    denom: \"\",\n    sellMinAmount: \"\",\n    sellMaxAmount: \"\",\n    denoms: [],\n    fees: [],\n  };\n}\n\nexport const Repurchase = {\n  encode(\n    message: Repurchase,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.denom !== \"\") {\n      writer.uint32(10).string(message.denom);\n    }\n    if (message.sellMinAmount !== \"\") {\n      writer.uint32(18).string(message.sellMinAmount);\n    }\n    if (message.sellMaxAmount !== \"\") {\n      writer.uint32(26).string(message.sellMaxAmount);\n    }\n    for (const v of message.denoms) {\n      writer.uint32(34).string(v!);\n    }\n    writer.uint32(42).fork();\n    for (const v of message.fees) {\n      writer.int32(v);\n    }\n    writer.ldelim();\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Repurchase {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRepurchase();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.denom = reader.string();\n          break;\n        case 2:\n          message.sellMinAmount = reader.string();\n          break;\n        case 3:\n          message.sellMaxAmount = reader.string();\n          break;\n        case 4:\n          message.denoms.push(reader.string());\n          break;\n        case 5:\n          if ((tag & 7) === 2) {\n            const end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.fees.push(reader.int32());\n            }\n          } else {\n            message.fees.push(reader.int32());\n          }\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Repurchase {\n    return {\n      denom: isSet(object.denom) ? String(object.denom) : \"\",\n      sellMinAmount: isSet(object.sellMinAmount)\n        ? String(object.sellMinAmount)\n        : \"\",\n      sellMaxAmount: isSet(object.sellMaxAmount)\n        ? String(object.sellMaxAmount)\n        : \"\",\n      denoms: Array.isArray(object?.denoms)\n        ? object.denoms.map((e: any) => String(e))\n        : [],\n      fees: Array.isArray(object?.fees)\n        ? object.fees.map((e: any) => Number(e))\n        : [],\n    };\n  },\n\n  toJSON(message: Repurchase): unknown {\n    const obj: any = {};\n    message.denom !== undefined && (obj.denom = message.denom);\n    message.sellMinAmount !== undefined &&\n      (obj.sellMinAmount = message.sellMinAmount);\n    message.sellMaxAmount !== undefined &&\n      (obj.sellMaxAmount = message.sellMaxAmount);\n    if (message.denoms) {\n      obj.denoms = message.denoms.map((e) => e);\n    } else {\n      obj.denoms = [];\n    }\n    if (message.fees) {\n      obj.fees = message.fees.map((e) => Math.round(e));\n    } else {\n      obj.fees = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Repurchase>, I>>(\n    object: I\n  ): Repurchase {\n    const message = createBaseRepurchase();\n    message.denom = object.denom ?? \"\";\n    message.sellMinAmount = object.sellMinAmount ?? \"\";\n    message.sellMaxAmount = object.sellMaxAmount ?? \"\";\n    message.denoms = object.denoms?.map((e) => e) || [];\n    message.fees = object.fees?.map((e) => e) || [];\n    return message;\n  },\n};\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport { grpc } from \"@improbable-eng/grpc-web\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Repurchase } from \"./repurchase\";\nimport { BrowserHeaders } from \"browser-headers\";\n\nexport const protobufPackage = \"metaoslabs.metaos.deflation\";\n\nexport interface MsgGovRepurchase {\n  creator: string;\n  repurchase?: Repurchase;\n}\n\nexport interface MsgGovRepurchaseResponse {}\n\nfunction createBaseMsgGovRepurchase(): MsgGovRepurchase {\n  return { creator: \"\", repurchase: undefined };\n}\n\nexport const MsgGovRepurchase = {\n  encode(\n    message: MsgGovRepurchase,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.repurchase !== undefined) {\n      Repurchase.encode(message.repurchase, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgGovRepurchase {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgGovRepurchase();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.repurchase = Repurchase.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgGovRepurchase {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      repurchase: isSet(object.repurchase)\n        ? Repurchase.fromJSON(object.repurchase)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgGovRepurchase): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.repurchase !== undefined &&\n      (obj.repurchase = message.repurchase\n        ? Repurchase.toJSON(message.repurchase)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgGovRepurchase>, I>>(\n    object: I\n  ): MsgGovRepurchase {\n    const message = createBaseMsgGovRepurchase();\n    message.creator = object.creator ?? \"\";\n    message.repurchase =\n      object.repurchase !== undefined && object.repurchase !== null\n        ? Repurchase.fromPartial(object.repurchase)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgGovRepurchaseResponse(): MsgGovRepurchaseResponse {\n  return {};\n}\n\nexport const MsgGovRepurchaseResponse = {\n  encode(\n    _: MsgGovRepurchaseResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgGovRepurchaseResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgGovRepurchaseResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgGovRepurchaseResponse {\n    return {};\n  },\n\n  toJSON(_: MsgGovRepurchaseResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgGovRepurchaseResponse>, I>>(\n    _: I\n  ): MsgGovRepurchaseResponse {\n    const message = createBaseMsgGovRepurchaseResponse();\n    return message;\n  },\n};\n\n/** Msg defines the Msg service. */\nexport interface Msg {\n  /** this line is used by starport scaffolding # proto/tx/rpc */\n  GovRepurchase(\n    request: DeepPartial<MsgGovRepurchase>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgGovRepurchaseResponse>;\n}\n\nexport class MsgClientImpl implements Msg {\n  private readonly rpc: Rpc;\n\n  constructor(rpc: Rpc) {\n    this.rpc = rpc;\n    this.GovRepurchase = this.GovRepurchase.bind(this);\n  }\n\n  GovRepurchase(\n    request: DeepPartial<MsgGovRepurchase>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgGovRepurchaseResponse> {\n    return this.rpc.unary(\n      MsgGovRepurchaseDesc,\n      MsgGovRepurchase.fromPartial(request),\n      metadata\n    );\n  }\n}\n\nexport const MsgDesc = {\n  serviceName: \"metaoslabs.metaos.deflation.Msg\",\n};\n\nexport const MsgGovRepurchaseDesc: UnaryMethodDefinitionish = {\n  methodName: \"GovRepurchase\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgGovRepurchase.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgGovRepurchaseResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\ninterface UnaryMethodDefinitionishR\n  extends grpc.UnaryMethodDefinition<any, any> {\n  requestStream: any;\n  responseStream: any;\n}\n\ntype UnaryMethodDefinitionish = UnaryMethodDefinitionishR;\n\ninterface Rpc {\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any>;\n}\n\nexport class GrpcWebImpl {\n  private host: string;\n  private options: {\n    transport?: grpc.TransportFactory;\n\n    debug?: boolean;\n    metadata?: grpc.Metadata;\n  };\n\n  constructor(\n    host: string,\n    options: {\n      transport?: grpc.TransportFactory;\n\n      debug?: boolean;\n      metadata?: grpc.Metadata;\n    }\n  ) {\n    this.host = host;\n    this.options = options;\n  }\n\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    _request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any> {\n    const request = { ..._request, ...methodDesc.requestType };\n    const maybeCombinedMetadata =\n      metadata && this.options.metadata\n        ? new BrowserHeaders({\n            ...this.options?.metadata.headersMap,\n            ...metadata?.headersMap,\n          })\n        : metadata || this.options.metadata;\n    return new Promise((resolve, reject) => {\n      grpc.unary(methodDesc, {\n        request,\n        host: this.host,\n        metadata: maybeCombinedMetadata,\n        transport: this.options.transport,\n        debug: this.options.debug,\n        onEnd: function (response) {\n          if (response.status === grpc.Code.OK) {\n            resolve(response.message);\n          } else {\n            const err = new Error(response.statusMessage) as any;\n            err.code = response.status;\n            err.metadata = response.trailers;\n            reject(err);\n          }\n        },\n      });\n    });\n  }\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","import { BaseMsg } from \"./BaseMsg\";\nimport { EncodeObject } from \"@cosmjs/proto-signing\";\nimport {\n  protobufPackage,\n  MsgGovRepurchase as MsgGovRepurchase_pb,\n} from \"../proto/deflation/tx\";\n\nexport class MsgGovRepurchase extends BaseMsg {\n  public protoMsg: MsgGovRepurchase_pb;\n  constructor(msg: MsgGovRepurchase_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgGovRepurchase.typeUrl,\n      value: MsgGovRepurchase_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgGovRepurchase {\n  export const typeUrl: string = `/${protobufPackage}.MsgGovRepurchase`;\n  export const Proto = MsgGovRepurchase_pb;\n  export interface Proto extends MsgGovRepurchase_pb {}\n}\n\n\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"ethermint.evm.v1\";\n\n/** Params defines the EVM module parameters */\nexport interface Params {\n  /**\n   * evm denom represents the token denomination used to run the EVM state\n   * transitions.\n   */\n  evmDenom: string;\n  /** enable create toggles state transitions that use the vm.Create function */\n  enableCreate: boolean;\n  /** enable call toggles state transitions that use the vm.Call function */\n  enableCall: boolean;\n  /** extra eips defines the additional EIPs for the vm.Config */\n  extraEips: Long[];\n  /** chain config defines the EVM chain configuration parameters */\n  chainConfig?: ChainConfig;\n}\n\n/**\n * ChainConfig defines the Ethereum ChainConfig parameters using *sdk.Int values\n * instead of *big.Int.\n */\nexport interface ChainConfig {\n  /** Homestead switch block (nil no fork, 0 = already homestead) */\n  homesteadBlock: string;\n  /** TheDAO hard-fork switch block (nil no fork) */\n  daoForkBlock: string;\n  /** Whether the nodes supports or opposes the DAO hard-fork */\n  daoForkSupport: boolean;\n  /**\n   * EIP150 implements the Gas price changes\n   * (https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)\n   */\n  eip150Block: string;\n  /** EIP150 HF hash (needed for header only clients as only gas pricing changed) */\n  eip150Hash: string;\n  /** EIP155Block HF block */\n  eip155Block: string;\n  /** EIP158 HF block */\n  eip158Block: string;\n  /** Byzantium switch block (nil no fork, 0 = already on byzantium) */\n  byzantiumBlock: string;\n  /** Constantinople switch block (nil no fork, 0 = already activated) */\n  constantinopleBlock: string;\n  /** Petersburg switch block (nil same as Constantinople) */\n  petersburgBlock: string;\n  /** Istanbul switch block (nil no fork, 0 = already on istanbul) */\n  istanbulBlock: string;\n  /** Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated) */\n  muirGlacierBlock: string;\n  /** Berlin switch block (nil = no fork, 0 = already on berlin) */\n  berlinBlock: string;\n  /** London switch block (nil = no fork, 0 = already on london) */\n  londonBlock: string;\n  /** Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated) */\n  arrowGlacierBlock: string;\n  /** EIP-3675 (TheMerge) switch block (nil = no fork, 0 = already in merge proceedings) */\n  mergeForkBlock: string;\n}\n\n/** State represents a single Storage key value pair item. */\nexport interface State {\n  key: string;\n  value: string;\n}\n\n/**\n * TransactionLogs define the logs generated from a transaction execution\n * with a given hash. It it used for import/export data as transactions are not\n * persisted on blockchain state after an upgrade.\n */\nexport interface TransactionLogs {\n  hash: string;\n  logs: Log[];\n}\n\n/**\n * Log represents an protobuf compatible Ethereum Log that defines a contract\n * log event. These events are generated by the LOG opcode and stored/indexed by\n * the node.\n */\nexport interface Log {\n  /** address of the contract that generated the event */\n  address: string;\n  /** list of topics provided by the contract. */\n  topics: string[];\n  /** supplied by the contract, usually ABI-encoded */\n  data: Uint8Array;\n  /** block in which the transaction was included */\n  blockNumber: Long;\n  /** hash of the transaction */\n  txHash: string;\n  /** index of the transaction in the block */\n  txIndex: Long;\n  /** hash of the block in which the transaction was included */\n  blockHash: string;\n  /** index of the log in the block */\n  index: Long;\n  /**\n   * The Removed field is true if this log was reverted due to a chain\n   * reorganisation. You must pay attention to this field if you receive logs\n   * through a filter query.\n   */\n  removed: boolean;\n}\n\n/** TxResult stores results of Tx execution. */\nexport interface TxResult {\n  /**\n   * contract_address contains the ethereum address of the created contract (if\n   * any). If the state transition is an evm.Call, the contract address will be\n   * empty.\n   */\n  contractAddress: string;\n  /** bloom represents the bloom filter bytes */\n  bloom: Uint8Array;\n  /**\n   * tx_logs contains the transaction hash and the proto-compatible ethereum\n   * logs.\n   */\n  txLogs?: TransactionLogs;\n  /** ret defines the bytes from the execution. */\n  ret: Uint8Array;\n  /** reverted flag is set to true when the call has been reverted */\n  reverted: boolean;\n  /** gas_used notes the amount of gas consumed while execution */\n  gasUsed: Long;\n}\n\n/** AccessTuple is the element type of an access list. */\nexport interface AccessTuple {\n  /** hex formatted ethereum address */\n  address: string;\n  /** hex formatted hashes of the storage keys */\n  storageKeys: string[];\n}\n\n/** TraceConfig holds extra parameters to trace functions. */\nexport interface TraceConfig {\n  /** custom javascript tracer */\n  tracer: string;\n  /**\n   * overrides the default timeout of 5 seconds for JavaScript-based tracing\n   * calls\n   */\n  timeout: string;\n  /** number of blocks the tracer is willing to go back */\n  reexec: Long;\n  /** disable stack capture */\n  disableStack: boolean;\n  /** disable storage capture */\n  disableStorage: boolean;\n  /** print output during capture end */\n  debug: boolean;\n  /** maximum length of output, but zero means unlimited */\n  limit: number;\n  /** Chain overrides, can be used to execute a trace using future fork rules */\n  overrides?: ChainConfig;\n  /** enable memory capture */\n  enableMemory: boolean;\n  /** enable return data capture */\n  enableReturnData: boolean;\n}\n\nfunction createBaseParams(): Params {\n  return {\n    evmDenom: \"\",\n    enableCreate: false,\n    enableCall: false,\n    extraEips: [],\n    chainConfig: undefined,\n  };\n}\n\nexport const Params = {\n  encode(\n    message: Params,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.evmDenom !== \"\") {\n      writer.uint32(10).string(message.evmDenom);\n    }\n    if (message.enableCreate === true) {\n      writer.uint32(16).bool(message.enableCreate);\n    }\n    if (message.enableCall === true) {\n      writer.uint32(24).bool(message.enableCall);\n    }\n    writer.uint32(34).fork();\n    for (const v of message.extraEips) {\n      writer.int64(v);\n    }\n    writer.ldelim();\n    if (message.chainConfig !== undefined) {\n      ChainConfig.encode(\n        message.chainConfig,\n        writer.uint32(42).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Params {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseParams();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.evmDenom = reader.string();\n          break;\n        case 2:\n          message.enableCreate = reader.bool();\n          break;\n        case 3:\n          message.enableCall = reader.bool();\n          break;\n        case 4:\n          if ((tag & 7) === 2) {\n            const end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.extraEips.push(reader.int64() as Long);\n            }\n          } else {\n            message.extraEips.push(reader.int64() as Long);\n          }\n          break;\n        case 5:\n          message.chainConfig = ChainConfig.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Params {\n    return {\n      evmDenom: isSet(object.evmDenom) ? String(object.evmDenom) : \"\",\n      enableCreate: isSet(object.enableCreate)\n        ? Boolean(object.enableCreate)\n        : false,\n      enableCall: isSet(object.enableCall) ? Boolean(object.enableCall) : false,\n      extraEips: Array.isArray(object?.extraEips)\n        ? object.extraEips.map((e: any) => Long.fromValue(e))\n        : [],\n      chainConfig: isSet(object.chainConfig)\n        ? ChainConfig.fromJSON(object.chainConfig)\n        : undefined,\n    };\n  },\n\n  toJSON(message: Params): unknown {\n    const obj: any = {};\n    message.evmDenom !== undefined && (obj.evmDenom = message.evmDenom);\n    message.enableCreate !== undefined &&\n      (obj.enableCreate = message.enableCreate);\n    message.enableCall !== undefined && (obj.enableCall = message.enableCall);\n    if (message.extraEips) {\n      obj.extraEips = message.extraEips.map((e) => (e || Long.ZERO).toString());\n    } else {\n      obj.extraEips = [];\n    }\n    message.chainConfig !== undefined &&\n      (obj.chainConfig = message.chainConfig\n        ? ChainConfig.toJSON(message.chainConfig)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Params>, I>>(object: I): Params {\n    const message = createBaseParams();\n    message.evmDenom = object.evmDenom ?? \"\";\n    message.enableCreate = object.enableCreate ?? false;\n    message.enableCall = object.enableCall ?? false;\n    message.extraEips = object.extraEips?.map((e) => Long.fromValue(e)) || [];\n    message.chainConfig =\n      object.chainConfig !== undefined && object.chainConfig !== null\n        ? ChainConfig.fromPartial(object.chainConfig)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseChainConfig(): ChainConfig {\n  return {\n    homesteadBlock: \"\",\n    daoForkBlock: \"\",\n    daoForkSupport: false,\n    eip150Block: \"\",\n    eip150Hash: \"\",\n    eip155Block: \"\",\n    eip158Block: \"\",\n    byzantiumBlock: \"\",\n    constantinopleBlock: \"\",\n    petersburgBlock: \"\",\n    istanbulBlock: \"\",\n    muirGlacierBlock: \"\",\n    berlinBlock: \"\",\n    londonBlock: \"\",\n    arrowGlacierBlock: \"\",\n    mergeForkBlock: \"\",\n  };\n}\n\nexport const ChainConfig = {\n  encode(\n    message: ChainConfig,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.homesteadBlock !== \"\") {\n      writer.uint32(10).string(message.homesteadBlock);\n    }\n    if (message.daoForkBlock !== \"\") {\n      writer.uint32(18).string(message.daoForkBlock);\n    }\n    if (message.daoForkSupport === true) {\n      writer.uint32(24).bool(message.daoForkSupport);\n    }\n    if (message.eip150Block !== \"\") {\n      writer.uint32(34).string(message.eip150Block);\n    }\n    if (message.eip150Hash !== \"\") {\n      writer.uint32(42).string(message.eip150Hash);\n    }\n    if (message.eip155Block !== \"\") {\n      writer.uint32(50).string(message.eip155Block);\n    }\n    if (message.eip158Block !== \"\") {\n      writer.uint32(58).string(message.eip158Block);\n    }\n    if (message.byzantiumBlock !== \"\") {\n      writer.uint32(66).string(message.byzantiumBlock);\n    }\n    if (message.constantinopleBlock !== \"\") {\n      writer.uint32(74).string(message.constantinopleBlock);\n    }\n    if (message.petersburgBlock !== \"\") {\n      writer.uint32(82).string(message.petersburgBlock);\n    }\n    if (message.istanbulBlock !== \"\") {\n      writer.uint32(90).string(message.istanbulBlock);\n    }\n    if (message.muirGlacierBlock !== \"\") {\n      writer.uint32(98).string(message.muirGlacierBlock);\n    }\n    if (message.berlinBlock !== \"\") {\n      writer.uint32(106).string(message.berlinBlock);\n    }\n    if (message.londonBlock !== \"\") {\n      writer.uint32(138).string(message.londonBlock);\n    }\n    if (message.arrowGlacierBlock !== \"\") {\n      writer.uint32(146).string(message.arrowGlacierBlock);\n    }\n    if (message.mergeForkBlock !== \"\") {\n      writer.uint32(154).string(message.mergeForkBlock);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): ChainConfig {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseChainConfig();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.homesteadBlock = reader.string();\n          break;\n        case 2:\n          message.daoForkBlock = reader.string();\n          break;\n        case 3:\n          message.daoForkSupport = reader.bool();\n          break;\n        case 4:\n          message.eip150Block = reader.string();\n          break;\n        case 5:\n          message.eip150Hash = reader.string();\n          break;\n        case 6:\n          message.eip155Block = reader.string();\n          break;\n        case 7:\n          message.eip158Block = reader.string();\n          break;\n        case 8:\n          message.byzantiumBlock = reader.string();\n          break;\n        case 9:\n          message.constantinopleBlock = reader.string();\n          break;\n        case 10:\n          message.petersburgBlock = reader.string();\n          break;\n        case 11:\n          message.istanbulBlock = reader.string();\n          break;\n        case 12:\n          message.muirGlacierBlock = reader.string();\n          break;\n        case 13:\n          message.berlinBlock = reader.string();\n          break;\n        case 17:\n          message.londonBlock = reader.string();\n          break;\n        case 18:\n          message.arrowGlacierBlock = reader.string();\n          break;\n        case 19:\n          message.mergeForkBlock = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ChainConfig {\n    return {\n      homesteadBlock: isSet(object.homesteadBlock)\n        ? String(object.homesteadBlock)\n        : \"\",\n      daoForkBlock: isSet(object.daoForkBlock)\n        ? String(object.daoForkBlock)\n        : \"\",\n      daoForkSupport: isSet(object.daoForkSupport)\n        ? Boolean(object.daoForkSupport)\n        : false,\n      eip150Block: isSet(object.eip150Block) ? String(object.eip150Block) : \"\",\n      eip150Hash: isSet(object.eip150Hash) ? String(object.eip150Hash) : \"\",\n      eip155Block: isSet(object.eip155Block) ? String(object.eip155Block) : \"\",\n      eip158Block: isSet(object.eip158Block) ? String(object.eip158Block) : \"\",\n      byzantiumBlock: isSet(object.byzantiumBlock)\n        ? String(object.byzantiumBlock)\n        : \"\",\n      constantinopleBlock: isSet(object.constantinopleBlock)\n        ? String(object.constantinopleBlock)\n        : \"\",\n      petersburgBlock: isSet(object.petersburgBlock)\n        ? String(object.petersburgBlock)\n        : \"\",\n      istanbulBlock: isSet(object.istanbulBlock)\n        ? String(object.istanbulBlock)\n        : \"\",\n      muirGlacierBlock: isSet(object.muirGlacierBlock)\n        ? String(object.muirGlacierBlock)\n        : \"\",\n      berlinBlock: isSet(object.berlinBlock) ? String(object.berlinBlock) : \"\",\n      londonBlock: isSet(object.londonBlock) ? String(object.londonBlock) : \"\",\n      arrowGlacierBlock: isSet(object.arrowGlacierBlock)\n        ? String(object.arrowGlacierBlock)\n        : \"\",\n      mergeForkBlock: isSet(object.mergeForkBlock)\n        ? String(object.mergeForkBlock)\n        : \"\",\n    };\n  },\n\n  toJSON(message: ChainConfig): unknown {\n    const obj: any = {};\n    message.homesteadBlock !== undefined &&\n      (obj.homesteadBlock = message.homesteadBlock);\n    message.daoForkBlock !== undefined &&\n      (obj.daoForkBlock = message.daoForkBlock);\n    message.daoForkSupport !== undefined &&\n      (obj.daoForkSupport = message.daoForkSupport);\n    message.eip150Block !== undefined &&\n      (obj.eip150Block = message.eip150Block);\n    message.eip150Hash !== undefined && (obj.eip150Hash = message.eip150Hash);\n    message.eip155Block !== undefined &&\n      (obj.eip155Block = message.eip155Block);\n    message.eip158Block !== undefined &&\n      (obj.eip158Block = message.eip158Block);\n    message.byzantiumBlock !== undefined &&\n      (obj.byzantiumBlock = message.byzantiumBlock);\n    message.constantinopleBlock !== undefined &&\n      (obj.constantinopleBlock = message.constantinopleBlock);\n    message.petersburgBlock !== undefined &&\n      (obj.petersburgBlock = message.petersburgBlock);\n    message.istanbulBlock !== undefined &&\n      (obj.istanbulBlock = message.istanbulBlock);\n    message.muirGlacierBlock !== undefined &&\n      (obj.muirGlacierBlock = message.muirGlacierBlock);\n    message.berlinBlock !== undefined &&\n      (obj.berlinBlock = message.berlinBlock);\n    message.londonBlock !== undefined &&\n      (obj.londonBlock = message.londonBlock);\n    message.arrowGlacierBlock !== undefined &&\n      (obj.arrowGlacierBlock = message.arrowGlacierBlock);\n    message.mergeForkBlock !== undefined &&\n      (obj.mergeForkBlock = message.mergeForkBlock);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<ChainConfig>, I>>(\n    object: I\n  ): ChainConfig {\n    const message = createBaseChainConfig();\n    message.homesteadBlock = object.homesteadBlock ?? \"\";\n    message.daoForkBlock = object.daoForkBlock ?? \"\";\n    message.daoForkSupport = object.daoForkSupport ?? false;\n    message.eip150Block = object.eip150Block ?? \"\";\n    message.eip150Hash = object.eip150Hash ?? \"\";\n    message.eip155Block = object.eip155Block ?? \"\";\n    message.eip158Block = object.eip158Block ?? \"\";\n    message.byzantiumBlock = object.byzantiumBlock ?? \"\";\n    message.constantinopleBlock = object.constantinopleBlock ?? \"\";\n    message.petersburgBlock = object.petersburgBlock ?? \"\";\n    message.istanbulBlock = object.istanbulBlock ?? \"\";\n    message.muirGlacierBlock = object.muirGlacierBlock ?? \"\";\n    message.berlinBlock = object.berlinBlock ?? \"\";\n    message.londonBlock = object.londonBlock ?? \"\";\n    message.arrowGlacierBlock = object.arrowGlacierBlock ?? \"\";\n    message.mergeForkBlock = object.mergeForkBlock ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseState(): State {\n  return { key: \"\", value: \"\" };\n}\n\nexport const State = {\n  encode(message: State, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (message.key !== \"\") {\n      writer.uint32(10).string(message.key);\n    }\n    if (message.value !== \"\") {\n      writer.uint32(18).string(message.value);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): State {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseState();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.string();\n          break;\n        case 2:\n          message.value = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): State {\n    return {\n      key: isSet(object.key) ? String(object.key) : \"\",\n      value: isSet(object.value) ? String(object.value) : \"\",\n    };\n  },\n\n  toJSON(message: State): unknown {\n    const obj: any = {};\n    message.key !== undefined && (obj.key = message.key);\n    message.value !== undefined && (obj.value = message.value);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<State>, I>>(object: I): State {\n    const message = createBaseState();\n    message.key = object.key ?? \"\";\n    message.value = object.value ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseTransactionLogs(): TransactionLogs {\n  return { hash: \"\", logs: [] };\n}\n\nexport const TransactionLogs = {\n  encode(\n    message: TransactionLogs,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.hash !== \"\") {\n      writer.uint32(10).string(message.hash);\n    }\n    for (const v of message.logs) {\n      Log.encode(v!, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionLogs {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTransactionLogs();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.hash = reader.string();\n          break;\n        case 2:\n          message.logs.push(Log.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): TransactionLogs {\n    return {\n      hash: isSet(object.hash) ? String(object.hash) : \"\",\n      logs: Array.isArray(object?.logs)\n        ? object.logs.map((e: any) => Log.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: TransactionLogs): unknown {\n    const obj: any = {};\n    message.hash !== undefined && (obj.hash = message.hash);\n    if (message.logs) {\n      obj.logs = message.logs.map((e) => (e ? Log.toJSON(e) : undefined));\n    } else {\n      obj.logs = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<TransactionLogs>, I>>(\n    object: I\n  ): TransactionLogs {\n    const message = createBaseTransactionLogs();\n    message.hash = object.hash ?? \"\";\n    message.logs = object.logs?.map((e) => Log.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseLog(): Log {\n  return {\n    address: \"\",\n    topics: [],\n    data: new Uint8Array(),\n    blockNumber: Long.UZERO,\n    txHash: \"\",\n    txIndex: Long.UZERO,\n    blockHash: \"\",\n    index: Long.UZERO,\n    removed: false,\n  };\n}\n\nexport const Log = {\n  encode(message: Log, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (message.address !== \"\") {\n      writer.uint32(10).string(message.address);\n    }\n    for (const v of message.topics) {\n      writer.uint32(18).string(v!);\n    }\n    if (message.data.length !== 0) {\n      writer.uint32(26).bytes(message.data);\n    }\n    if (!message.blockNumber.isZero()) {\n      writer.uint32(32).uint64(message.blockNumber);\n    }\n    if (message.txHash !== \"\") {\n      writer.uint32(42).string(message.txHash);\n    }\n    if (!message.txIndex.isZero()) {\n      writer.uint32(48).uint64(message.txIndex);\n    }\n    if (message.blockHash !== \"\") {\n      writer.uint32(58).string(message.blockHash);\n    }\n    if (!message.index.isZero()) {\n      writer.uint32(64).uint64(message.index);\n    }\n    if (message.removed === true) {\n      writer.uint32(72).bool(message.removed);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Log {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseLog();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.address = reader.string();\n          break;\n        case 2:\n          message.topics.push(reader.string());\n          break;\n        case 3:\n          message.data = reader.bytes();\n          break;\n        case 4:\n          message.blockNumber = reader.uint64() as Long;\n          break;\n        case 5:\n          message.txHash = reader.string();\n          break;\n        case 6:\n          message.txIndex = reader.uint64() as Long;\n          break;\n        case 7:\n          message.blockHash = reader.string();\n          break;\n        case 8:\n          message.index = reader.uint64() as Long;\n          break;\n        case 9:\n          message.removed = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Log {\n    return {\n      address: isSet(object.address) ? String(object.address) : \"\",\n      topics: Array.isArray(object?.topics)\n        ? object.topics.map((e: any) => String(e))\n        : [],\n      data: isSet(object.data)\n        ? bytesFromBase64(object.data)\n        : new Uint8Array(),\n      blockNumber: isSet(object.blockNumber)\n        ? Long.fromValue(object.blockNumber)\n        : Long.UZERO,\n      txHash: isSet(object.txHash) ? String(object.txHash) : \"\",\n      txIndex: isSet(object.txIndex)\n        ? Long.fromValue(object.txIndex)\n        : Long.UZERO,\n      blockHash: isSet(object.blockHash) ? String(object.blockHash) : \"\",\n      index: isSet(object.index) ? Long.fromValue(object.index) : Long.UZERO,\n      removed: isSet(object.removed) ? Boolean(object.removed) : false,\n    };\n  },\n\n  toJSON(message: Log): unknown {\n    const obj: any = {};\n    message.address !== undefined && (obj.address = message.address);\n    if (message.topics) {\n      obj.topics = message.topics.map((e) => e);\n    } else {\n      obj.topics = [];\n    }\n    message.data !== undefined &&\n      (obj.data = base64FromBytes(\n        message.data !== undefined ? message.data : new Uint8Array()\n      ));\n    message.blockNumber !== undefined &&\n      (obj.blockNumber = (message.blockNumber || Long.UZERO).toString());\n    message.txHash !== undefined && (obj.txHash = message.txHash);\n    message.txIndex !== undefined &&\n      (obj.txIndex = (message.txIndex || Long.UZERO).toString());\n    message.blockHash !== undefined && (obj.blockHash = message.blockHash);\n    message.index !== undefined &&\n      (obj.index = (message.index || Long.UZERO).toString());\n    message.removed !== undefined && (obj.removed = message.removed);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Log>, I>>(object: I): Log {\n    const message = createBaseLog();\n    message.address = object.address ?? \"\";\n    message.topics = object.topics?.map((e) => e) || [];\n    message.data = object.data ?? new Uint8Array();\n    message.blockNumber =\n      object.blockNumber !== undefined && object.blockNumber !== null\n        ? Long.fromValue(object.blockNumber)\n        : Long.UZERO;\n    message.txHash = object.txHash ?? \"\";\n    message.txIndex =\n      object.txIndex !== undefined && object.txIndex !== null\n        ? Long.fromValue(object.txIndex)\n        : Long.UZERO;\n    message.blockHash = object.blockHash ?? \"\";\n    message.index =\n      object.index !== undefined && object.index !== null\n        ? Long.fromValue(object.index)\n        : Long.UZERO;\n    message.removed = object.removed ?? false;\n    return message;\n  },\n};\n\nfunction createBaseTxResult(): TxResult {\n  return {\n    contractAddress: \"\",\n    bloom: new Uint8Array(),\n    txLogs: undefined,\n    ret: new Uint8Array(),\n    reverted: false,\n    gasUsed: Long.UZERO,\n  };\n}\n\nexport const TxResult = {\n  encode(\n    message: TxResult,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.contractAddress !== \"\") {\n      writer.uint32(10).string(message.contractAddress);\n    }\n    if (message.bloom.length !== 0) {\n      writer.uint32(18).bytes(message.bloom);\n    }\n    if (message.txLogs !== undefined) {\n      TransactionLogs.encode(message.txLogs, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.ret.length !== 0) {\n      writer.uint32(34).bytes(message.ret);\n    }\n    if (message.reverted === true) {\n      writer.uint32(40).bool(message.reverted);\n    }\n    if (!message.gasUsed.isZero()) {\n      writer.uint32(48).uint64(message.gasUsed);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): TxResult {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTxResult();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.contractAddress = reader.string();\n          break;\n        case 2:\n          message.bloom = reader.bytes();\n          break;\n        case 3:\n          message.txLogs = TransactionLogs.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.ret = reader.bytes();\n          break;\n        case 5:\n          message.reverted = reader.bool();\n          break;\n        case 6:\n          message.gasUsed = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): TxResult {\n    return {\n      contractAddress: isSet(object.contractAddress)\n        ? String(object.contractAddress)\n        : \"\",\n      bloom: isSet(object.bloom)\n        ? bytesFromBase64(object.bloom)\n        : new Uint8Array(),\n      txLogs: isSet(object.txLogs)\n        ? TransactionLogs.fromJSON(object.txLogs)\n        : undefined,\n      ret: isSet(object.ret) ? bytesFromBase64(object.ret) : new Uint8Array(),\n      reverted: isSet(object.reverted) ? Boolean(object.reverted) : false,\n      gasUsed: isSet(object.gasUsed)\n        ? Long.fromValue(object.gasUsed)\n        : Long.UZERO,\n    };\n  },\n\n  toJSON(message: TxResult): unknown {\n    const obj: any = {};\n    message.contractAddress !== undefined &&\n      (obj.contractAddress = message.contractAddress);\n    message.bloom !== undefined &&\n      (obj.bloom = base64FromBytes(\n        message.bloom !== undefined ? message.bloom : new Uint8Array()\n      ));\n    message.txLogs !== undefined &&\n      (obj.txLogs = message.txLogs\n        ? TransactionLogs.toJSON(message.txLogs)\n        : undefined);\n    message.ret !== undefined &&\n      (obj.ret = base64FromBytes(\n        message.ret !== undefined ? message.ret : new Uint8Array()\n      ));\n    message.reverted !== undefined && (obj.reverted = message.reverted);\n    message.gasUsed !== undefined &&\n      (obj.gasUsed = (message.gasUsed || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<TxResult>, I>>(object: I): TxResult {\n    const message = createBaseTxResult();\n    message.contractAddress = object.contractAddress ?? \"\";\n    message.bloom = object.bloom ?? new Uint8Array();\n    message.txLogs =\n      object.txLogs !== undefined && object.txLogs !== null\n        ? TransactionLogs.fromPartial(object.txLogs)\n        : undefined;\n    message.ret = object.ret ?? new Uint8Array();\n    message.reverted = object.reverted ?? false;\n    message.gasUsed =\n      object.gasUsed !== undefined && object.gasUsed !== null\n        ? Long.fromValue(object.gasUsed)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseAccessTuple(): AccessTuple {\n  return { address: \"\", storageKeys: [] };\n}\n\nexport const AccessTuple = {\n  encode(\n    message: AccessTuple,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.address !== \"\") {\n      writer.uint32(10).string(message.address);\n    }\n    for (const v of message.storageKeys) {\n      writer.uint32(18).string(v!);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): AccessTuple {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseAccessTuple();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.address = reader.string();\n          break;\n        case 2:\n          message.storageKeys.push(reader.string());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): AccessTuple {\n    return {\n      address: isSet(object.address) ? String(object.address) : \"\",\n      storageKeys: Array.isArray(object?.storageKeys)\n        ? object.storageKeys.map((e: any) => String(e))\n        : [],\n    };\n  },\n\n  toJSON(message: AccessTuple): unknown {\n    const obj: any = {};\n    message.address !== undefined && (obj.address = message.address);\n    if (message.storageKeys) {\n      obj.storageKeys = message.storageKeys.map((e) => e);\n    } else {\n      obj.storageKeys = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<AccessTuple>, I>>(\n    object: I\n  ): AccessTuple {\n    const message = createBaseAccessTuple();\n    message.address = object.address ?? \"\";\n    message.storageKeys = object.storageKeys?.map((e) => e) || [];\n    return message;\n  },\n};\n\nfunction createBaseTraceConfig(): TraceConfig {\n  return {\n    tracer: \"\",\n    timeout: \"\",\n    reexec: Long.UZERO,\n    disableStack: false,\n    disableStorage: false,\n    debug: false,\n    limit: 0,\n    overrides: undefined,\n    enableMemory: false,\n    enableReturnData: false,\n  };\n}\n\nexport const TraceConfig = {\n  encode(\n    message: TraceConfig,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.tracer !== \"\") {\n      writer.uint32(10).string(message.tracer);\n    }\n    if (message.timeout !== \"\") {\n      writer.uint32(18).string(message.timeout);\n    }\n    if (!message.reexec.isZero()) {\n      writer.uint32(24).uint64(message.reexec);\n    }\n    if (message.disableStack === true) {\n      writer.uint32(40).bool(message.disableStack);\n    }\n    if (message.disableStorage === true) {\n      writer.uint32(48).bool(message.disableStorage);\n    }\n    if (message.debug === true) {\n      writer.uint32(64).bool(message.debug);\n    }\n    if (message.limit !== 0) {\n      writer.uint32(72).int32(message.limit);\n    }\n    if (message.overrides !== undefined) {\n      ChainConfig.encode(message.overrides, writer.uint32(82).fork()).ldelim();\n    }\n    if (message.enableMemory === true) {\n      writer.uint32(88).bool(message.enableMemory);\n    }\n    if (message.enableReturnData === true) {\n      writer.uint32(96).bool(message.enableReturnData);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): TraceConfig {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTraceConfig();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.tracer = reader.string();\n          break;\n        case 2:\n          message.timeout = reader.string();\n          break;\n        case 3:\n          message.reexec = reader.uint64() as Long;\n          break;\n        case 5:\n          message.disableStack = reader.bool();\n          break;\n        case 6:\n          message.disableStorage = reader.bool();\n          break;\n        case 8:\n          message.debug = reader.bool();\n          break;\n        case 9:\n          message.limit = reader.int32();\n          break;\n        case 10:\n          message.overrides = ChainConfig.decode(reader, reader.uint32());\n          break;\n        case 11:\n          message.enableMemory = reader.bool();\n          break;\n        case 12:\n          message.enableReturnData = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): TraceConfig {\n    return {\n      tracer: isSet(object.tracer) ? String(object.tracer) : \"\",\n      timeout: isSet(object.timeout) ? String(object.timeout) : \"\",\n      reexec: isSet(object.reexec) ? Long.fromValue(object.reexec) : Long.UZERO,\n      disableStack: isSet(object.disableStack)\n        ? Boolean(object.disableStack)\n        : false,\n      disableStorage: isSet(object.disableStorage)\n        ? Boolean(object.disableStorage)\n        : false,\n      debug: isSet(object.debug) ? Boolean(object.debug) : false,\n      limit: isSet(object.limit) ? Number(object.limit) : 0,\n      overrides: isSet(object.overrides)\n        ? ChainConfig.fromJSON(object.overrides)\n        : undefined,\n      enableMemory: isSet(object.enableMemory)\n        ? Boolean(object.enableMemory)\n        : false,\n      enableReturnData: isSet(object.enableReturnData)\n        ? Boolean(object.enableReturnData)\n        : false,\n    };\n  },\n\n  toJSON(message: TraceConfig): unknown {\n    const obj: any = {};\n    message.tracer !== undefined && (obj.tracer = message.tracer);\n    message.timeout !== undefined && (obj.timeout = message.timeout);\n    message.reexec !== undefined &&\n      (obj.reexec = (message.reexec || Long.UZERO).toString());\n    message.disableStack !== undefined &&\n      (obj.disableStack = message.disableStack);\n    message.disableStorage !== undefined &&\n      (obj.disableStorage = message.disableStorage);\n    message.debug !== undefined && (obj.debug = message.debug);\n    message.limit !== undefined && (obj.limit = Math.round(message.limit));\n    message.overrides !== undefined &&\n      (obj.overrides = message.overrides\n        ? ChainConfig.toJSON(message.overrides)\n        : undefined);\n    message.enableMemory !== undefined &&\n      (obj.enableMemory = message.enableMemory);\n    message.enableReturnData !== undefined &&\n      (obj.enableReturnData = message.enableReturnData);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<TraceConfig>, I>>(\n    object: I\n  ): TraceConfig {\n    const message = createBaseTraceConfig();\n    message.tracer = object.tracer ?? \"\";\n    message.timeout = object.timeout ?? \"\";\n    message.reexec =\n      object.reexec !== undefined && object.reexec !== null\n        ? Long.fromValue(object.reexec)\n        : Long.UZERO;\n    message.disableStack = object.disableStack ?? false;\n    message.disableStorage = object.disableStorage ?? false;\n    message.debug = object.debug ?? false;\n    message.limit = object.limit ?? 0;\n    message.overrides =\n      object.overrides !== undefined && object.overrides !== null\n        ? ChainConfig.fromPartial(object.overrides)\n        : undefined;\n    message.enableMemory = object.enableMemory ?? false;\n    message.enableReturnData = object.enableReturnData ?? false;\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport { grpc } from \"@improbable-eng/grpc-web\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Any } from \"../../../google/protobuf/any\";\nimport { BrowserHeaders } from \"browser-headers\";\nimport { AccessTuple, Log } from \"./evm\";\n\nexport const protobufPackage = \"ethermint.evm.v1\";\n\n/** MsgEthereumTx encapsulates an Ethereum transaction as an SDK message. */\nexport interface MsgEthereumTx {\n  /** inner transaction data */\n  data?: Any;\n  /** encoded storage size of the transaction */\n  size: number;\n  /** transaction hash in hex format */\n  hash: string;\n  /**\n   * ethereum signer address in hex format. This address value is checked\n   * against the address derived from the signature (V, R, S) using the\n   * secp256k1 elliptic curve\n   */\n  from: string;\n}\n\n/** LegacyTx is the transaction data of regular Ethereum transactions. */\nexport interface LegacyTx {\n  /** nonce corresponds to the account nonce (transaction sequence). */\n  nonce: Long;\n  /** gas price defines the value for each gas unit */\n  gasPrice: string;\n  /** gas defines the gas limit defined for the transaction. */\n  gas: Long;\n  /** hex formatted address of the recipient */\n  to: string;\n  /** value defines the unsigned integer value of the transaction amount. */\n  value: string;\n  /** input defines the data payload bytes of the transaction. */\n  data: Uint8Array;\n  /** v defines the signature value */\n  v: Uint8Array;\n  /** r defines the signature value */\n  r: Uint8Array;\n  /** s define the signature value */\n  s: Uint8Array;\n}\n\n/** AccessListTx is the data of EIP-2930 access list transactions. */\nexport interface AccessListTx {\n  /** destination EVM chain ID */\n  chainId: string;\n  /** nonce corresponds to the account nonce (transaction sequence). */\n  nonce: Long;\n  /** gas price defines the value for each gas unit */\n  gasPrice: string;\n  /** gas defines the gas limit defined for the transaction. */\n  gas: Long;\n  /** hex formatted address of the recipient */\n  to: string;\n  /** value defines the unsigned integer value of the transaction amount. */\n  value: string;\n  /** input defines the data payload bytes of the transaction. */\n  data: Uint8Array;\n  accesses: AccessTuple[];\n  /** v defines the signature value */\n  v: Uint8Array;\n  /** r defines the signature value */\n  r: Uint8Array;\n  /** s define the signature value */\n  s: Uint8Array;\n}\n\n/** DynamicFeeTx is the data of EIP-1559 dinamic fee transactions. */\nexport interface DynamicFeeTx {\n  /** destination EVM chain ID */\n  chainId: string;\n  /** nonce corresponds to the account nonce (transaction sequence). */\n  nonce: Long;\n  /** gas tip cap defines the max value for the gas tip */\n  gasTipCap: string;\n  /** gas fee cap defines the max value for the gas fee */\n  gasFeeCap: string;\n  /** gas defines the gas limit defined for the transaction. */\n  gas: Long;\n  /** hex formatted address of the recipient */\n  to: string;\n  /** value defines the the transaction amount. */\n  value: string;\n  /** input defines the data payload bytes of the transaction. */\n  data: Uint8Array;\n  accesses: AccessTuple[];\n  /** v defines the signature value */\n  v: Uint8Array;\n  /** r defines the signature value */\n  r: Uint8Array;\n  /** s define the signature value */\n  s: Uint8Array;\n}\n\nexport interface ExtensionOptionsEthereumTx {}\n\n/** MsgEthereumTxResponse defines the Msg/EthereumTx response type. */\nexport interface MsgEthereumTxResponse {\n  /**\n   * ethereum transaction hash in hex format. This hash differs from the\n   * Tendermint sha256 hash of the transaction bytes. See\n   * https://github.com/tendermint/tendermint/issues/6539 for reference\n   */\n  hash: string;\n  /**\n   * logs contains the transaction hash and the proto-compatible ethereum\n   * logs.\n   */\n  logs: Log[];\n  /**\n   * returned data from evm function (result or data supplied with revert\n   * opcode)\n   */\n  ret: Uint8Array;\n  /** vm error is the error returned by vm execution */\n  vmError: string;\n  /** gas consumed by the transaction */\n  gasUsed: Long;\n}\n\nfunction createBaseMsgEthereumTx(): MsgEthereumTx {\n  return { data: undefined, size: 0, hash: \"\", from: \"\" };\n}\n\nexport const MsgEthereumTx = {\n  encode(\n    message: MsgEthereumTx,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.data !== undefined) {\n      Any.encode(message.data, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.size !== 0) {\n      writer.uint32(17).double(message.size);\n    }\n    if (message.hash !== \"\") {\n      writer.uint32(26).string(message.hash);\n    }\n    if (message.from !== \"\") {\n      writer.uint32(34).string(message.from);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgEthereumTx {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgEthereumTx();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.data = Any.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.size = reader.double();\n          break;\n        case 3:\n          message.hash = reader.string();\n          break;\n        case 4:\n          message.from = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgEthereumTx {\n    return {\n      data: isSet(object.data) ? Any.fromJSON(object.data) : undefined,\n      size: isSet(object.size) ? Number(object.size) : 0,\n      hash: isSet(object.hash) ? String(object.hash) : \"\",\n      from: isSet(object.from) ? String(object.from) : \"\",\n    };\n  },\n\n  toJSON(message: MsgEthereumTx): unknown {\n    const obj: any = {};\n    message.data !== undefined &&\n      (obj.data = message.data ? Any.toJSON(message.data) : undefined);\n    message.size !== undefined && (obj.size = message.size);\n    message.hash !== undefined && (obj.hash = message.hash);\n    message.from !== undefined && (obj.from = message.from);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgEthereumTx>, I>>(\n    object: I\n  ): MsgEthereumTx {\n    const message = createBaseMsgEthereumTx();\n    message.data =\n      object.data !== undefined && object.data !== null\n        ? Any.fromPartial(object.data)\n        : undefined;\n    message.size = object.size ?? 0;\n    message.hash = object.hash ?? \"\";\n    message.from = object.from ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseLegacyTx(): LegacyTx {\n  return {\n    nonce: Long.UZERO,\n    gasPrice: \"\",\n    gas: Long.UZERO,\n    to: \"\",\n    value: \"\",\n    data: new Uint8Array(),\n    v: new Uint8Array(),\n    r: new Uint8Array(),\n    s: new Uint8Array(),\n  };\n}\n\nexport const LegacyTx = {\n  encode(\n    message: LegacyTx,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.nonce.isZero()) {\n      writer.uint32(8).uint64(message.nonce);\n    }\n    if (message.gasPrice !== \"\") {\n      writer.uint32(18).string(message.gasPrice);\n    }\n    if (!message.gas.isZero()) {\n      writer.uint32(24).uint64(message.gas);\n    }\n    if (message.to !== \"\") {\n      writer.uint32(34).string(message.to);\n    }\n    if (message.value !== \"\") {\n      writer.uint32(42).string(message.value);\n    }\n    if (message.data.length !== 0) {\n      writer.uint32(50).bytes(message.data);\n    }\n    if (message.v.length !== 0) {\n      writer.uint32(58).bytes(message.v);\n    }\n    if (message.r.length !== 0) {\n      writer.uint32(66).bytes(message.r);\n    }\n    if (message.s.length !== 0) {\n      writer.uint32(74).bytes(message.s);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): LegacyTx {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseLegacyTx();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.nonce = reader.uint64() as Long;\n          break;\n        case 2:\n          message.gasPrice = reader.string();\n          break;\n        case 3:\n          message.gas = reader.uint64() as Long;\n          break;\n        case 4:\n          message.to = reader.string();\n          break;\n        case 5:\n          message.value = reader.string();\n          break;\n        case 6:\n          message.data = reader.bytes();\n          break;\n        case 7:\n          message.v = reader.bytes();\n          break;\n        case 8:\n          message.r = reader.bytes();\n          break;\n        case 9:\n          message.s = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): LegacyTx {\n    return {\n      nonce: isSet(object.nonce) ? Long.fromValue(object.nonce) : Long.UZERO,\n      gasPrice: isSet(object.gasPrice) ? String(object.gasPrice) : \"\",\n      gas: isSet(object.gas) ? Long.fromValue(object.gas) : Long.UZERO,\n      to: isSet(object.to) ? String(object.to) : \"\",\n      value: isSet(object.value) ? String(object.value) : \"\",\n      data: isSet(object.data)\n        ? bytesFromBase64(object.data)\n        : new Uint8Array(),\n      v: isSet(object.v) ? bytesFromBase64(object.v) : new Uint8Array(),\n      r: isSet(object.r) ? bytesFromBase64(object.r) : new Uint8Array(),\n      s: isSet(object.s) ? bytesFromBase64(object.s) : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: LegacyTx): unknown {\n    const obj: any = {};\n    message.nonce !== undefined &&\n      (obj.nonce = (message.nonce || Long.UZERO).toString());\n    message.gasPrice !== undefined && (obj.gasPrice = message.gasPrice);\n    message.gas !== undefined &&\n      (obj.gas = (message.gas || Long.UZERO).toString());\n    message.to !== undefined && (obj.to = message.to);\n    message.value !== undefined && (obj.value = message.value);\n    message.data !== undefined &&\n      (obj.data = base64FromBytes(\n        message.data !== undefined ? message.data : new Uint8Array()\n      ));\n    message.v !== undefined &&\n      (obj.v = base64FromBytes(\n        message.v !== undefined ? message.v : new Uint8Array()\n      ));\n    message.r !== undefined &&\n      (obj.r = base64FromBytes(\n        message.r !== undefined ? message.r : new Uint8Array()\n      ));\n    message.s !== undefined &&\n      (obj.s = base64FromBytes(\n        message.s !== undefined ? message.s : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<LegacyTx>, I>>(object: I): LegacyTx {\n    const message = createBaseLegacyTx();\n    message.nonce =\n      object.nonce !== undefined && object.nonce !== null\n        ? Long.fromValue(object.nonce)\n        : Long.UZERO;\n    message.gasPrice = object.gasPrice ?? \"\";\n    message.gas =\n      object.gas !== undefined && object.gas !== null\n        ? Long.fromValue(object.gas)\n        : Long.UZERO;\n    message.to = object.to ?? \"\";\n    message.value = object.value ?? \"\";\n    message.data = object.data ?? new Uint8Array();\n    message.v = object.v ?? new Uint8Array();\n    message.r = object.r ?? new Uint8Array();\n    message.s = object.s ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBaseAccessListTx(): AccessListTx {\n  return {\n    chainId: \"\",\n    nonce: Long.UZERO,\n    gasPrice: \"\",\n    gas: Long.UZERO,\n    to: \"\",\n    value: \"\",\n    data: new Uint8Array(),\n    accesses: [],\n    v: new Uint8Array(),\n    r: new Uint8Array(),\n    s: new Uint8Array(),\n  };\n}\n\nexport const AccessListTx = {\n  encode(\n    message: AccessListTx,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.chainId !== \"\") {\n      writer.uint32(10).string(message.chainId);\n    }\n    if (!message.nonce.isZero()) {\n      writer.uint32(16).uint64(message.nonce);\n    }\n    if (message.gasPrice !== \"\") {\n      writer.uint32(26).string(message.gasPrice);\n    }\n    if (!message.gas.isZero()) {\n      writer.uint32(32).uint64(message.gas);\n    }\n    if (message.to !== \"\") {\n      writer.uint32(42).string(message.to);\n    }\n    if (message.value !== \"\") {\n      writer.uint32(50).string(message.value);\n    }\n    if (message.data.length !== 0) {\n      writer.uint32(58).bytes(message.data);\n    }\n    for (const v of message.accesses) {\n      AccessTuple.encode(v!, writer.uint32(66).fork()).ldelim();\n    }\n    if (message.v.length !== 0) {\n      writer.uint32(74).bytes(message.v);\n    }\n    if (message.r.length !== 0) {\n      writer.uint32(82).bytes(message.r);\n    }\n    if (message.s.length !== 0) {\n      writer.uint32(90).bytes(message.s);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): AccessListTx {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseAccessListTx();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.chainId = reader.string();\n          break;\n        case 2:\n          message.nonce = reader.uint64() as Long;\n          break;\n        case 3:\n          message.gasPrice = reader.string();\n          break;\n        case 4:\n          message.gas = reader.uint64() as Long;\n          break;\n        case 5:\n          message.to = reader.string();\n          break;\n        case 6:\n          message.value = reader.string();\n          break;\n        case 7:\n          message.data = reader.bytes();\n          break;\n        case 8:\n          message.accesses.push(AccessTuple.decode(reader, reader.uint32()));\n          break;\n        case 9:\n          message.v = reader.bytes();\n          break;\n        case 10:\n          message.r = reader.bytes();\n          break;\n        case 11:\n          message.s = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): AccessListTx {\n    return {\n      chainId: isSet(object.chainId) ? String(object.chainId) : \"\",\n      nonce: isSet(object.nonce) ? Long.fromValue(object.nonce) : Long.UZERO,\n      gasPrice: isSet(object.gasPrice) ? String(object.gasPrice) : \"\",\n      gas: isSet(object.gas) ? Long.fromValue(object.gas) : Long.UZERO,\n      to: isSet(object.to) ? String(object.to) : \"\",\n      value: isSet(object.value) ? String(object.value) : \"\",\n      data: isSet(object.data)\n        ? bytesFromBase64(object.data)\n        : new Uint8Array(),\n      accesses: Array.isArray(object?.accesses)\n        ? object.accesses.map((e: any) => AccessTuple.fromJSON(e))\n        : [],\n      v: isSet(object.v) ? bytesFromBase64(object.v) : new Uint8Array(),\n      r: isSet(object.r) ? bytesFromBase64(object.r) : new Uint8Array(),\n      s: isSet(object.s) ? bytesFromBase64(object.s) : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: AccessListTx): unknown {\n    const obj: any = {};\n    message.chainId !== undefined && (obj.chainId = message.chainId);\n    message.nonce !== undefined &&\n      (obj.nonce = (message.nonce || Long.UZERO).toString());\n    message.gasPrice !== undefined && (obj.gasPrice = message.gasPrice);\n    message.gas !== undefined &&\n      (obj.gas = (message.gas || Long.UZERO).toString());\n    message.to !== undefined && (obj.to = message.to);\n    message.value !== undefined && (obj.value = message.value);\n    message.data !== undefined &&\n      (obj.data = base64FromBytes(\n        message.data !== undefined ? message.data : new Uint8Array()\n      ));\n    if (message.accesses) {\n      obj.accesses = message.accesses.map((e) =>\n        e ? AccessTuple.toJSON(e) : undefined\n      );\n    } else {\n      obj.accesses = [];\n    }\n    message.v !== undefined &&\n      (obj.v = base64FromBytes(\n        message.v !== undefined ? message.v : new Uint8Array()\n      ));\n    message.r !== undefined &&\n      (obj.r = base64FromBytes(\n        message.r !== undefined ? message.r : new Uint8Array()\n      ));\n    message.s !== undefined &&\n      (obj.s = base64FromBytes(\n        message.s !== undefined ? message.s : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<AccessListTx>, I>>(\n    object: I\n  ): AccessListTx {\n    const message = createBaseAccessListTx();\n    message.chainId = object.chainId ?? \"\";\n    message.nonce =\n      object.nonce !== undefined && object.nonce !== null\n        ? Long.fromValue(object.nonce)\n        : Long.UZERO;\n    message.gasPrice = object.gasPrice ?? \"\";\n    message.gas =\n      object.gas !== undefined && object.gas !== null\n        ? Long.fromValue(object.gas)\n        : Long.UZERO;\n    message.to = object.to ?? \"\";\n    message.value = object.value ?? \"\";\n    message.data = object.data ?? new Uint8Array();\n    message.accesses =\n      object.accesses?.map((e) => AccessTuple.fromPartial(e)) || [];\n    message.v = object.v ?? new Uint8Array();\n    message.r = object.r ?? new Uint8Array();\n    message.s = object.s ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBaseDynamicFeeTx(): DynamicFeeTx {\n  return {\n    chainId: \"\",\n    nonce: Long.UZERO,\n    gasTipCap: \"\",\n    gasFeeCap: \"\",\n    gas: Long.UZERO,\n    to: \"\",\n    value: \"\",\n    data: new Uint8Array(),\n    accesses: [],\n    v: new Uint8Array(),\n    r: new Uint8Array(),\n    s: new Uint8Array(),\n  };\n}\n\nexport const DynamicFeeTx = {\n  encode(\n    message: DynamicFeeTx,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.chainId !== \"\") {\n      writer.uint32(10).string(message.chainId);\n    }\n    if (!message.nonce.isZero()) {\n      writer.uint32(16).uint64(message.nonce);\n    }\n    if (message.gasTipCap !== \"\") {\n      writer.uint32(26).string(message.gasTipCap);\n    }\n    if (message.gasFeeCap !== \"\") {\n      writer.uint32(34).string(message.gasFeeCap);\n    }\n    if (!message.gas.isZero()) {\n      writer.uint32(40).uint64(message.gas);\n    }\n    if (message.to !== \"\") {\n      writer.uint32(50).string(message.to);\n    }\n    if (message.value !== \"\") {\n      writer.uint32(58).string(message.value);\n    }\n    if (message.data.length !== 0) {\n      writer.uint32(66).bytes(message.data);\n    }\n    for (const v of message.accesses) {\n      AccessTuple.encode(v!, writer.uint32(74).fork()).ldelim();\n    }\n    if (message.v.length !== 0) {\n      writer.uint32(82).bytes(message.v);\n    }\n    if (message.r.length !== 0) {\n      writer.uint32(90).bytes(message.r);\n    }\n    if (message.s.length !== 0) {\n      writer.uint32(98).bytes(message.s);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): DynamicFeeTx {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDynamicFeeTx();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.chainId = reader.string();\n          break;\n        case 2:\n          message.nonce = reader.uint64() as Long;\n          break;\n        case 3:\n          message.gasTipCap = reader.string();\n          break;\n        case 4:\n          message.gasFeeCap = reader.string();\n          break;\n        case 5:\n          message.gas = reader.uint64() as Long;\n          break;\n        case 6:\n          message.to = reader.string();\n          break;\n        case 7:\n          message.value = reader.string();\n          break;\n        case 8:\n          message.data = reader.bytes();\n          break;\n        case 9:\n          message.accesses.push(AccessTuple.decode(reader, reader.uint32()));\n          break;\n        case 10:\n          message.v = reader.bytes();\n          break;\n        case 11:\n          message.r = reader.bytes();\n          break;\n        case 12:\n          message.s = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): DynamicFeeTx {\n    return {\n      chainId: isSet(object.chainId) ? String(object.chainId) : \"\",\n      nonce: isSet(object.nonce) ? Long.fromValue(object.nonce) : Long.UZERO,\n      gasTipCap: isSet(object.gasTipCap) ? String(object.gasTipCap) : \"\",\n      gasFeeCap: isSet(object.gasFeeCap) ? String(object.gasFeeCap) : \"\",\n      gas: isSet(object.gas) ? Long.fromValue(object.gas) : Long.UZERO,\n      to: isSet(object.to) ? String(object.to) : \"\",\n      value: isSet(object.value) ? String(object.value) : \"\",\n      data: isSet(object.data)\n        ? bytesFromBase64(object.data)\n        : new Uint8Array(),\n      accesses: Array.isArray(object?.accesses)\n        ? object.accesses.map((e: any) => AccessTuple.fromJSON(e))\n        : [],\n      v: isSet(object.v) ? bytesFromBase64(object.v) : new Uint8Array(),\n      r: isSet(object.r) ? bytesFromBase64(object.r) : new Uint8Array(),\n      s: isSet(object.s) ? bytesFromBase64(object.s) : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: DynamicFeeTx): unknown {\n    const obj: any = {};\n    message.chainId !== undefined && (obj.chainId = message.chainId);\n    message.nonce !== undefined &&\n      (obj.nonce = (message.nonce || Long.UZERO).toString());\n    message.gasTipCap !== undefined && (obj.gasTipCap = message.gasTipCap);\n    message.gasFeeCap !== undefined && (obj.gasFeeCap = message.gasFeeCap);\n    message.gas !== undefined &&\n      (obj.gas = (message.gas || Long.UZERO).toString());\n    message.to !== undefined && (obj.to = message.to);\n    message.value !== undefined && (obj.value = message.value);\n    message.data !== undefined &&\n      (obj.data = base64FromBytes(\n        message.data !== undefined ? message.data : new Uint8Array()\n      ));\n    if (message.accesses) {\n      obj.accesses = message.accesses.map((e) =>\n        e ? AccessTuple.toJSON(e) : undefined\n      );\n    } else {\n      obj.accesses = [];\n    }\n    message.v !== undefined &&\n      (obj.v = base64FromBytes(\n        message.v !== undefined ? message.v : new Uint8Array()\n      ));\n    message.r !== undefined &&\n      (obj.r = base64FromBytes(\n        message.r !== undefined ? message.r : new Uint8Array()\n      ));\n    message.s !== undefined &&\n      (obj.s = base64FromBytes(\n        message.s !== undefined ? message.s : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<DynamicFeeTx>, I>>(\n    object: I\n  ): DynamicFeeTx {\n    const message = createBaseDynamicFeeTx();\n    message.chainId = object.chainId ?? \"\";\n    message.nonce =\n      object.nonce !== undefined && object.nonce !== null\n        ? Long.fromValue(object.nonce)\n        : Long.UZERO;\n    message.gasTipCap = object.gasTipCap ?? \"\";\n    message.gasFeeCap = object.gasFeeCap ?? \"\";\n    message.gas =\n      object.gas !== undefined && object.gas !== null\n        ? Long.fromValue(object.gas)\n        : Long.UZERO;\n    message.to = object.to ?? \"\";\n    message.value = object.value ?? \"\";\n    message.data = object.data ?? new Uint8Array();\n    message.accesses =\n      object.accesses?.map((e) => AccessTuple.fromPartial(e)) || [];\n    message.v = object.v ?? new Uint8Array();\n    message.r = object.r ?? new Uint8Array();\n    message.s = object.s ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBaseExtensionOptionsEthereumTx(): ExtensionOptionsEthereumTx {\n  return {};\n}\n\nexport const ExtensionOptionsEthereumTx = {\n  encode(\n    _: ExtensionOptionsEthereumTx,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): ExtensionOptionsEthereumTx {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseExtensionOptionsEthereumTx();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): ExtensionOptionsEthereumTx {\n    return {};\n  },\n\n  toJSON(_: ExtensionOptionsEthereumTx): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<ExtensionOptionsEthereumTx>, I>>(\n    _: I\n  ): ExtensionOptionsEthereumTx {\n    const message = createBaseExtensionOptionsEthereumTx();\n    return message;\n  },\n};\n\nfunction createBaseMsgEthereumTxResponse(): MsgEthereumTxResponse {\n  return {\n    hash: \"\",\n    logs: [],\n    ret: new Uint8Array(),\n    vmError: \"\",\n    gasUsed: Long.UZERO,\n  };\n}\n\nexport const MsgEthereumTxResponse = {\n  encode(\n    message: MsgEthereumTxResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.hash !== \"\") {\n      writer.uint32(10).string(message.hash);\n    }\n    for (const v of message.logs) {\n      Log.encode(v!, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.ret.length !== 0) {\n      writer.uint32(26).bytes(message.ret);\n    }\n    if (message.vmError !== \"\") {\n      writer.uint32(34).string(message.vmError);\n    }\n    if (!message.gasUsed.isZero()) {\n      writer.uint32(40).uint64(message.gasUsed);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgEthereumTxResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgEthereumTxResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.hash = reader.string();\n          break;\n        case 2:\n          message.logs.push(Log.decode(reader, reader.uint32()));\n          break;\n        case 3:\n          message.ret = reader.bytes();\n          break;\n        case 4:\n          message.vmError = reader.string();\n          break;\n        case 5:\n          message.gasUsed = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgEthereumTxResponse {\n    return {\n      hash: isSet(object.hash) ? String(object.hash) : \"\",\n      logs: Array.isArray(object?.logs)\n        ? object.logs.map((e: any) => Log.fromJSON(e))\n        : [],\n      ret: isSet(object.ret) ? bytesFromBase64(object.ret) : new Uint8Array(),\n      vmError: isSet(object.vmError) ? String(object.vmError) : \"\",\n      gasUsed: isSet(object.gasUsed)\n        ? Long.fromValue(object.gasUsed)\n        : Long.UZERO,\n    };\n  },\n\n  toJSON(message: MsgEthereumTxResponse): unknown {\n    const obj: any = {};\n    message.hash !== undefined && (obj.hash = message.hash);\n    if (message.logs) {\n      obj.logs = message.logs.map((e) => (e ? Log.toJSON(e) : undefined));\n    } else {\n      obj.logs = [];\n    }\n    message.ret !== undefined &&\n      (obj.ret = base64FromBytes(\n        message.ret !== undefined ? message.ret : new Uint8Array()\n      ));\n    message.vmError !== undefined && (obj.vmError = message.vmError);\n    message.gasUsed !== undefined &&\n      (obj.gasUsed = (message.gasUsed || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgEthereumTxResponse>, I>>(\n    object: I\n  ): MsgEthereumTxResponse {\n    const message = createBaseMsgEthereumTxResponse();\n    message.hash = object.hash ?? \"\";\n    message.logs = object.logs?.map((e) => Log.fromPartial(e)) || [];\n    message.ret = object.ret ?? new Uint8Array();\n    message.vmError = object.vmError ?? \"\";\n    message.gasUsed =\n      object.gasUsed !== undefined && object.gasUsed !== null\n        ? Long.fromValue(object.gasUsed)\n        : Long.UZERO;\n    return message;\n  },\n};\n\n/** Msg defines the evm Msg service. */\nexport interface Msg {\n  /** EthereumTx defines a method submitting Ethereum transactions. */\n  EthereumTx(\n    request: DeepPartial<MsgEthereumTx>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgEthereumTxResponse>;\n}\n\nexport class MsgClientImpl implements Msg {\n  private readonly rpc: Rpc;\n\n  constructor(rpc: Rpc) {\n    this.rpc = rpc;\n    this.EthereumTx = this.EthereumTx.bind(this);\n  }\n\n  EthereumTx(\n    request: DeepPartial<MsgEthereumTx>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgEthereumTxResponse> {\n    return this.rpc.unary(\n      MsgEthereumTxDesc,\n      MsgEthereumTx.fromPartial(request),\n      metadata\n    );\n  }\n}\n\nexport const MsgDesc = {\n  serviceName: \"ethermint.evm.v1.Msg\",\n};\n\nexport const MsgEthereumTxDesc: UnaryMethodDefinitionish = {\n  methodName: \"EthereumTx\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgEthereumTx.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgEthereumTxResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\ninterface UnaryMethodDefinitionishR\n  extends grpc.UnaryMethodDefinition<any, any> {\n  requestStream: any;\n  responseStream: any;\n}\n\ntype UnaryMethodDefinitionish = UnaryMethodDefinitionishR;\n\ninterface Rpc {\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any>;\n}\n\nexport class GrpcWebImpl {\n  private host: string;\n  private options: {\n    transport?: grpc.TransportFactory;\n\n    debug?: boolean;\n    metadata?: grpc.Metadata;\n  };\n\n  constructor(\n    host: string,\n    options: {\n      transport?: grpc.TransportFactory;\n\n      debug?: boolean;\n      metadata?: grpc.Metadata;\n    }\n  ) {\n    this.host = host;\n    this.options = options;\n  }\n\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    _request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any> {\n    const request = { ..._request, ...methodDesc.requestType };\n    const maybeCombinedMetadata =\n      metadata && this.options.metadata\n        ? new BrowserHeaders({\n            ...this.options?.metadata.headersMap,\n            ...metadata?.headersMap,\n          })\n        : metadata || this.options.metadata;\n    return new Promise((resolve, reject) => {\n      grpc.unary(methodDesc, {\n        request,\n        host: this.host,\n        metadata: maybeCombinedMetadata,\n        transport: this.options.transport,\n        debug: this.options.debug,\n        onEnd: function (response) {\n          if (response.status === grpc.Code.OK) {\n            resolve(response.message);\n          } else {\n            const err = new Error(response.statusMessage) as any;\n            err.code = response.status;\n            err.metadata = response.trailers;\n            reject(err);\n          }\n        },\n      });\n    });\n  }\n}\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","import { BaseMsg } from \"./BaseMsg\";\nimport { EncodeObject } from \"@cosmjs/proto-signing\";\nimport {\n  protobufPackage,\n  MsgEthereumTx as MsgEthereumTx_pb\n} from \"../proto/ethermint/evm/v1/tx\";\n\nexport class MsgEthereumTx extends BaseMsg {\n  public protoMsg: MsgEthereumTx_pb;\n  constructor(msg: MsgEthereumTx_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgEthereumTx.typeUrl,\n      value: MsgEthereumTx_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgEthereumTx {\n  export const typeUrl: string = `/${protobufPackage}.MsgEthereumTx`;\n  export const Proto = MsgEthereumTx_pb;\n  export interface Proto extends MsgEthereumTx_pb {}\n}\n\n\n","/* eslint-disable */\nimport Long from \"long\";\nimport { grpc } from \"@improbable-eng/grpc-web\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { BrowserHeaders } from \"browser-headers\";\n\nexport const protobufPackage = \"metaoslabs.metaos.nft\";\n\n/** MsgSend represents a message to send a nft from one account to another account. */\nexport interface MsgSend {\n  /** class_id defines the unique identifier of the nft classification, similar to the contract address of ERC721 */\n  classId: string;\n  /** id defines the unique identification of nft */\n  id: string;\n  /** sender is the address of the owner of nft */\n  sender: string;\n  /** receiver is the receiver address of nft */\n  receiver: string;\n}\n\n/** MsgSendResponse defines the Msg/Send response type. */\nexport interface MsgSendResponse {}\n\nfunction createBaseMsgSend(): MsgSend {\n  return { classId: \"\", id: \"\", sender: \"\", receiver: \"\" };\n}\n\nexport const MsgSend = {\n  encode(\n    message: MsgSend,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.classId !== \"\") {\n      writer.uint32(10).string(message.classId);\n    }\n    if (message.id !== \"\") {\n      writer.uint32(18).string(message.id);\n    }\n    if (message.sender !== \"\") {\n      writer.uint32(26).string(message.sender);\n    }\n    if (message.receiver !== \"\") {\n      writer.uint32(34).string(message.receiver);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSend {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgSend();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.classId = reader.string();\n          break;\n        case 2:\n          message.id = reader.string();\n          break;\n        case 3:\n          message.sender = reader.string();\n          break;\n        case 4:\n          message.receiver = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgSend {\n    return {\n      classId: isSet(object.classId) ? String(object.classId) : \"\",\n      id: isSet(object.id) ? String(object.id) : \"\",\n      sender: isSet(object.sender) ? String(object.sender) : \"\",\n      receiver: isSet(object.receiver) ? String(object.receiver) : \"\",\n    };\n  },\n\n  toJSON(message: MsgSend): unknown {\n    const obj: any = {};\n    message.classId !== undefined && (obj.classId = message.classId);\n    message.id !== undefined && (obj.id = message.id);\n    message.sender !== undefined && (obj.sender = message.sender);\n    message.receiver !== undefined && (obj.receiver = message.receiver);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgSend>, I>>(object: I): MsgSend {\n    const message = createBaseMsgSend();\n    message.classId = object.classId ?? \"\";\n    message.id = object.id ?? \"\";\n    message.sender = object.sender ?? \"\";\n    message.receiver = object.receiver ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgSendResponse(): MsgSendResponse {\n  return {};\n}\n\nexport const MsgSendResponse = {\n  encode(\n    _: MsgSendResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSendResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgSendResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgSendResponse {\n    return {};\n  },\n\n  toJSON(_: MsgSendResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgSendResponse>, I>>(\n    _: I\n  ): MsgSendResponse {\n    const message = createBaseMsgSendResponse();\n    return message;\n  },\n};\n\n/** Msg defines the Msg service. */\nexport interface Msg {\n  /** this line is used by starport scaffolding # proto/tx/rpc */\n  Send(\n    request: DeepPartial<MsgSend>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgSendResponse>;\n}\n\nexport class MsgClientImpl implements Msg {\n  private readonly rpc: Rpc;\n\n  constructor(rpc: Rpc) {\n    this.rpc = rpc;\n    this.Send = this.Send.bind(this);\n  }\n\n  Send(\n    request: DeepPartial<MsgSend>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgSendResponse> {\n    return this.rpc.unary(MsgSendDesc, MsgSend.fromPartial(request), metadata);\n  }\n}\n\nexport const MsgDesc = {\n  serviceName: \"metaoslabs.metaos.nft.Msg\",\n};\n\nexport const MsgSendDesc: UnaryMethodDefinitionish = {\n  methodName: \"Send\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgSend.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgSendResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\ninterface UnaryMethodDefinitionishR\n  extends grpc.UnaryMethodDefinition<any, any> {\n  requestStream: any;\n  responseStream: any;\n}\n\ntype UnaryMethodDefinitionish = UnaryMethodDefinitionishR;\n\ninterface Rpc {\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any>;\n}\n\nexport class GrpcWebImpl {\n  private host: string;\n  private options: {\n    transport?: grpc.TransportFactory;\n\n    debug?: boolean;\n    metadata?: grpc.Metadata;\n  };\n\n  constructor(\n    host: string,\n    options: {\n      transport?: grpc.TransportFactory;\n\n      debug?: boolean;\n      metadata?: grpc.Metadata;\n    }\n  ) {\n    this.host = host;\n    this.options = options;\n  }\n\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    _request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any> {\n    const request = { ..._request, ...methodDesc.requestType };\n    const maybeCombinedMetadata =\n      metadata && this.options.metadata\n        ? new BrowserHeaders({\n            ...this.options?.metadata.headersMap,\n            ...metadata?.headersMap,\n          })\n        : metadata || this.options.metadata;\n    return new Promise((resolve, reject) => {\n      grpc.unary(methodDesc, {\n        request,\n        host: this.host,\n        metadata: maybeCombinedMetadata,\n        transport: this.options.transport,\n        debug: this.options.debug,\n        onEnd: function (response) {\n          if (response.status === grpc.Code.OK) {\n            resolve(response.message);\n          } else {\n            const err = new Error(response.statusMessage) as any;\n            err.code = response.status;\n            err.metadata = response.trailers;\n            reject(err);\n          }\n        },\n      });\n    });\n  }\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","import { BaseMsg } from \"./BaseMsg\";\nimport { EncodeObject } from \"@cosmjs/proto-signing\";\nimport {\n  protobufPackage,\n  MsgSend as MsgSend_pb,\n} from \"../proto/nft/tx\";\n\nexport class MsgSendNft extends BaseMsg {\n  public protoMsg: MsgSend_pb;\n  constructor(msg: MsgSend_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgSendNft.typeUrl,\n      value: MsgSend_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgSendNft {\n  export const typeUrl: string = `/${protobufPackage}.MsgSend`;\n  export const Proto = MsgSend_pb;\n  export interface Proto extends MsgSend_pb {}\n}\n\n\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Duration } from \"../google/protobuf/duration\";\n\nexport const protobufPackage = \"metaoslabs.metaos.poolincentives\";\n\nexport interface RandSwapRewardSubConfig {\n  title: string;\n  /** the total reward of weight in hundredths of a bip, i.e. 1e-6 */\n  weight: number;\n  numberOfReveal: number;\n}\n\nexport interface RandSwapRewardConfig {\n  id: Long;\n  enabled: boolean;\n  intervalPeriod?: Duration;\n  mintable: boolean;\n  owner: string;\n  denom: string;\n  decimal: number;\n  totalReward: string;\n  subConfigs: RandSwapRewardSubConfig[];\n  pools: string[];\n}\n\nexport interface RandSwapRewardDenom {\n  denom: string;\n  configId: Long;\n}\n\nexport interface RandSwapRewardRound {\n  configId: Long;\n  round: Long;\n}\n\nexport interface RandSwapRewardRoundWithConfig {\n  configId: Long;\n  round: Long;\n  rewardConfig?: RandSwapRewardConfig;\n}\n\nexport interface RandSwapRewardRoundSequencer {\n  configId: Long;\n  round: Long;\n  sequence: Long;\n}\n\nexport interface RandSwapRewardRoundSequence {\n  configId: Long;\n  round: Long;\n  sequence: Long;\n  address: string;\n}\n\nexport interface RandSwapPoolReward {\n  address: string;\n  configIds: Long[];\n}\n\nexport interface RandSwapRewardReveal {\n  configId: Long;\n  round: Long;\n  config?: RandSwapRewardConfig;\n  subConfigEachReward: string[];\n  winnerSequences: Long[];\n}\n\nexport interface RandSwapAccountReward {\n  account: string;\n  denom: string;\n  amount: string;\n}\n\nexport interface RandSwapSequenceClear {\n  configId: Long;\n  round: Long;\n}\n\nfunction createBaseRandSwapRewardSubConfig(): RandSwapRewardSubConfig {\n  return { title: \"\", weight: 0, numberOfReveal: 0 };\n}\n\nexport const RandSwapRewardSubConfig = {\n  encode(\n    message: RandSwapRewardSubConfig,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.title !== \"\") {\n      writer.uint32(10).string(message.title);\n    }\n    if (message.weight !== 0) {\n      writer.uint32(16).int32(message.weight);\n    }\n    if (message.numberOfReveal !== 0) {\n      writer.uint32(24).uint32(message.numberOfReveal);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): RandSwapRewardSubConfig {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRandSwapRewardSubConfig();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.title = reader.string();\n          break;\n        case 2:\n          message.weight = reader.int32();\n          break;\n        case 3:\n          message.numberOfReveal = reader.uint32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): RandSwapRewardSubConfig {\n    return {\n      title: isSet(object.title) ? String(object.title) : \"\",\n      weight: isSet(object.weight) ? Number(object.weight) : 0,\n      numberOfReveal: isSet(object.numberOfReveal)\n        ? Number(object.numberOfReveal)\n        : 0,\n    };\n  },\n\n  toJSON(message: RandSwapRewardSubConfig): unknown {\n    const obj: any = {};\n    message.title !== undefined && (obj.title = message.title);\n    message.weight !== undefined && (obj.weight = Math.round(message.weight));\n    message.numberOfReveal !== undefined &&\n      (obj.numberOfReveal = Math.round(message.numberOfReveal));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<RandSwapRewardSubConfig>, I>>(\n    object: I\n  ): RandSwapRewardSubConfig {\n    const message = createBaseRandSwapRewardSubConfig();\n    message.title = object.title ?? \"\";\n    message.weight = object.weight ?? 0;\n    message.numberOfReveal = object.numberOfReveal ?? 0;\n    return message;\n  },\n};\n\nfunction createBaseRandSwapRewardConfig(): RandSwapRewardConfig {\n  return {\n    id: Long.UZERO,\n    enabled: false,\n    intervalPeriod: undefined,\n    mintable: false,\n    owner: \"\",\n    denom: \"\",\n    decimal: 0,\n    totalReward: \"\",\n    subConfigs: [],\n    pools: [],\n  };\n}\n\nexport const RandSwapRewardConfig = {\n  encode(\n    message: RandSwapRewardConfig,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.id.isZero()) {\n      writer.uint32(8).uint64(message.id);\n    }\n    if (message.enabled === true) {\n      writer.uint32(16).bool(message.enabled);\n    }\n    if (message.intervalPeriod !== undefined) {\n      Duration.encode(\n        message.intervalPeriod,\n        writer.uint32(26).fork()\n      ).ldelim();\n    }\n    if (message.mintable === true) {\n      writer.uint32(32).bool(message.mintable);\n    }\n    if (message.owner !== \"\") {\n      writer.uint32(42).string(message.owner);\n    }\n    if (message.denom !== \"\") {\n      writer.uint32(50).string(message.denom);\n    }\n    if (message.decimal !== 0) {\n      writer.uint32(56).int32(message.decimal);\n    }\n    if (message.totalReward !== \"\") {\n      writer.uint32(66).string(message.totalReward);\n    }\n    for (const v of message.subConfigs) {\n      RandSwapRewardSubConfig.encode(v!, writer.uint32(74).fork()).ldelim();\n    }\n    for (const v of message.pools) {\n      writer.uint32(82).string(v!);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): RandSwapRewardConfig {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRandSwapRewardConfig();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.uint64() as Long;\n          break;\n        case 2:\n          message.enabled = reader.bool();\n          break;\n        case 3:\n          message.intervalPeriod = Duration.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.mintable = reader.bool();\n          break;\n        case 5:\n          message.owner = reader.string();\n          break;\n        case 6:\n          message.denom = reader.string();\n          break;\n        case 7:\n          message.decimal = reader.int32();\n          break;\n        case 8:\n          message.totalReward = reader.string();\n          break;\n        case 9:\n          message.subConfigs.push(\n            RandSwapRewardSubConfig.decode(reader, reader.uint32())\n          );\n          break;\n        case 10:\n          message.pools.push(reader.string());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): RandSwapRewardConfig {\n    return {\n      id: isSet(object.id) ? Long.fromValue(object.id) : Long.UZERO,\n      enabled: isSet(object.enabled) ? Boolean(object.enabled) : false,\n      intervalPeriod: isSet(object.intervalPeriod)\n        ? Duration.fromJSON(object.intervalPeriod)\n        : undefined,\n      mintable: isSet(object.mintable) ? Boolean(object.mintable) : false,\n      owner: isSet(object.owner) ? String(object.owner) : \"\",\n      denom: isSet(object.denom) ? String(object.denom) : \"\",\n      decimal: isSet(object.decimal) ? Number(object.decimal) : 0,\n      totalReward: isSet(object.totalReward) ? String(object.totalReward) : \"\",\n      subConfigs: Array.isArray(object?.subConfigs)\n        ? object.subConfigs.map((e: any) => RandSwapRewardSubConfig.fromJSON(e))\n        : [],\n      pools: Array.isArray(object?.pools)\n        ? object.pools.map((e: any) => String(e))\n        : [],\n    };\n  },\n\n  toJSON(message: RandSwapRewardConfig): unknown {\n    const obj: any = {};\n    message.id !== undefined &&\n      (obj.id = (message.id || Long.UZERO).toString());\n    message.enabled !== undefined && (obj.enabled = message.enabled);\n    message.intervalPeriod !== undefined &&\n      (obj.intervalPeriod = message.intervalPeriod\n        ? Duration.toJSON(message.intervalPeriod)\n        : undefined);\n    message.mintable !== undefined && (obj.mintable = message.mintable);\n    message.owner !== undefined && (obj.owner = message.owner);\n    message.denom !== undefined && (obj.denom = message.denom);\n    message.decimal !== undefined &&\n      (obj.decimal = Math.round(message.decimal));\n    message.totalReward !== undefined &&\n      (obj.totalReward = message.totalReward);\n    if (message.subConfigs) {\n      obj.subConfigs = message.subConfigs.map((e) =>\n        e ? RandSwapRewardSubConfig.toJSON(e) : undefined\n      );\n    } else {\n      obj.subConfigs = [];\n    }\n    if (message.pools) {\n      obj.pools = message.pools.map((e) => e);\n    } else {\n      obj.pools = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<RandSwapRewardConfig>, I>>(\n    object: I\n  ): RandSwapRewardConfig {\n    const message = createBaseRandSwapRewardConfig();\n    message.id =\n      object.id !== undefined && object.id !== null\n        ? Long.fromValue(object.id)\n        : Long.UZERO;\n    message.enabled = object.enabled ?? false;\n    message.intervalPeriod =\n      object.intervalPeriod !== undefined && object.intervalPeriod !== null\n        ? Duration.fromPartial(object.intervalPeriod)\n        : undefined;\n    message.mintable = object.mintable ?? false;\n    message.owner = object.owner ?? \"\";\n    message.denom = object.denom ?? \"\";\n    message.decimal = object.decimal ?? 0;\n    message.totalReward = object.totalReward ?? \"\";\n    message.subConfigs =\n      object.subConfigs?.map((e) => RandSwapRewardSubConfig.fromPartial(e)) ||\n      [];\n    message.pools = object.pools?.map((e) => e) || [];\n    return message;\n  },\n};\n\nfunction createBaseRandSwapRewardDenom(): RandSwapRewardDenom {\n  return { denom: \"\", configId: Long.UZERO };\n}\n\nexport const RandSwapRewardDenom = {\n  encode(\n    message: RandSwapRewardDenom,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.denom !== \"\") {\n      writer.uint32(10).string(message.denom);\n    }\n    if (!message.configId.isZero()) {\n      writer.uint32(16).uint64(message.configId);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): RandSwapRewardDenom {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRandSwapRewardDenom();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.denom = reader.string();\n          break;\n        case 2:\n          message.configId = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): RandSwapRewardDenom {\n    return {\n      denom: isSet(object.denom) ? String(object.denom) : \"\",\n      configId: isSet(object.configId)\n        ? Long.fromValue(object.configId)\n        : Long.UZERO,\n    };\n  },\n\n  toJSON(message: RandSwapRewardDenom): unknown {\n    const obj: any = {};\n    message.denom !== undefined && (obj.denom = message.denom);\n    message.configId !== undefined &&\n      (obj.configId = (message.configId || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<RandSwapRewardDenom>, I>>(\n    object: I\n  ): RandSwapRewardDenom {\n    const message = createBaseRandSwapRewardDenom();\n    message.denom = object.denom ?? \"\";\n    message.configId =\n      object.configId !== undefined && object.configId !== null\n        ? Long.fromValue(object.configId)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseRandSwapRewardRound(): RandSwapRewardRound {\n  return { configId: Long.UZERO, round: Long.UZERO };\n}\n\nexport const RandSwapRewardRound = {\n  encode(\n    message: RandSwapRewardRound,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.configId.isZero()) {\n      writer.uint32(8).uint64(message.configId);\n    }\n    if (!message.round.isZero()) {\n      writer.uint32(16).uint64(message.round);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): RandSwapRewardRound {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRandSwapRewardRound();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.configId = reader.uint64() as Long;\n          break;\n        case 2:\n          message.round = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): RandSwapRewardRound {\n    return {\n      configId: isSet(object.configId)\n        ? Long.fromValue(object.configId)\n        : Long.UZERO,\n      round: isSet(object.round) ? Long.fromValue(object.round) : Long.UZERO,\n    };\n  },\n\n  toJSON(message: RandSwapRewardRound): unknown {\n    const obj: any = {};\n    message.configId !== undefined &&\n      (obj.configId = (message.configId || Long.UZERO).toString());\n    message.round !== undefined &&\n      (obj.round = (message.round || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<RandSwapRewardRound>, I>>(\n    object: I\n  ): RandSwapRewardRound {\n    const message = createBaseRandSwapRewardRound();\n    message.configId =\n      object.configId !== undefined && object.configId !== null\n        ? Long.fromValue(object.configId)\n        : Long.UZERO;\n    message.round =\n      object.round !== undefined && object.round !== null\n        ? Long.fromValue(object.round)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseRandSwapRewardRoundWithConfig(): RandSwapRewardRoundWithConfig {\n  return { configId: Long.UZERO, round: Long.UZERO, rewardConfig: undefined };\n}\n\nexport const RandSwapRewardRoundWithConfig = {\n  encode(\n    message: RandSwapRewardRoundWithConfig,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.configId.isZero()) {\n      writer.uint32(8).uint64(message.configId);\n    }\n    if (!message.round.isZero()) {\n      writer.uint32(16).uint64(message.round);\n    }\n    if (message.rewardConfig !== undefined) {\n      RandSwapRewardConfig.encode(\n        message.rewardConfig,\n        writer.uint32(26).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): RandSwapRewardRoundWithConfig {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRandSwapRewardRoundWithConfig();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.configId = reader.uint64() as Long;\n          break;\n        case 2:\n          message.round = reader.uint64() as Long;\n          break;\n        case 3:\n          message.rewardConfig = RandSwapRewardConfig.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): RandSwapRewardRoundWithConfig {\n    return {\n      configId: isSet(object.configId)\n        ? Long.fromValue(object.configId)\n        : Long.UZERO,\n      round: isSet(object.round) ? Long.fromValue(object.round) : Long.UZERO,\n      rewardConfig: isSet(object.rewardConfig)\n        ? RandSwapRewardConfig.fromJSON(object.rewardConfig)\n        : undefined,\n    };\n  },\n\n  toJSON(message: RandSwapRewardRoundWithConfig): unknown {\n    const obj: any = {};\n    message.configId !== undefined &&\n      (obj.configId = (message.configId || Long.UZERO).toString());\n    message.round !== undefined &&\n      (obj.round = (message.round || Long.UZERO).toString());\n    message.rewardConfig !== undefined &&\n      (obj.rewardConfig = message.rewardConfig\n        ? RandSwapRewardConfig.toJSON(message.rewardConfig)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<RandSwapRewardRoundWithConfig>, I>>(\n    object: I\n  ): RandSwapRewardRoundWithConfig {\n    const message = createBaseRandSwapRewardRoundWithConfig();\n    message.configId =\n      object.configId !== undefined && object.configId !== null\n        ? Long.fromValue(object.configId)\n        : Long.UZERO;\n    message.round =\n      object.round !== undefined && object.round !== null\n        ? Long.fromValue(object.round)\n        : Long.UZERO;\n    message.rewardConfig =\n      object.rewardConfig !== undefined && object.rewardConfig !== null\n        ? RandSwapRewardConfig.fromPartial(object.rewardConfig)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseRandSwapRewardRoundSequencer(): RandSwapRewardRoundSequencer {\n  return { configId: Long.UZERO, round: Long.UZERO, sequence: Long.UZERO };\n}\n\nexport const RandSwapRewardRoundSequencer = {\n  encode(\n    message: RandSwapRewardRoundSequencer,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.configId.isZero()) {\n      writer.uint32(8).uint64(message.configId);\n    }\n    if (!message.round.isZero()) {\n      writer.uint32(16).uint64(message.round);\n    }\n    if (!message.sequence.isZero()) {\n      writer.uint32(24).uint64(message.sequence);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): RandSwapRewardRoundSequencer {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRandSwapRewardRoundSequencer();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.configId = reader.uint64() as Long;\n          break;\n        case 2:\n          message.round = reader.uint64() as Long;\n          break;\n        case 3:\n          message.sequence = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): RandSwapRewardRoundSequencer {\n    return {\n      configId: isSet(object.configId)\n        ? Long.fromValue(object.configId)\n        : Long.UZERO,\n      round: isSet(object.round) ? Long.fromValue(object.round) : Long.UZERO,\n      sequence: isSet(object.sequence)\n        ? Long.fromValue(object.sequence)\n        : Long.UZERO,\n    };\n  },\n\n  toJSON(message: RandSwapRewardRoundSequencer): unknown {\n    const obj: any = {};\n    message.configId !== undefined &&\n      (obj.configId = (message.configId || Long.UZERO).toString());\n    message.round !== undefined &&\n      (obj.round = (message.round || Long.UZERO).toString());\n    message.sequence !== undefined &&\n      (obj.sequence = (message.sequence || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<RandSwapRewardRoundSequencer>, I>>(\n    object: I\n  ): RandSwapRewardRoundSequencer {\n    const message = createBaseRandSwapRewardRoundSequencer();\n    message.configId =\n      object.configId !== undefined && object.configId !== null\n        ? Long.fromValue(object.configId)\n        : Long.UZERO;\n    message.round =\n      object.round !== undefined && object.round !== null\n        ? Long.fromValue(object.round)\n        : Long.UZERO;\n    message.sequence =\n      object.sequence !== undefined && object.sequence !== null\n        ? Long.fromValue(object.sequence)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseRandSwapRewardRoundSequence(): RandSwapRewardRoundSequence {\n  return {\n    configId: Long.UZERO,\n    round: Long.UZERO,\n    sequence: Long.UZERO,\n    address: \"\",\n  };\n}\n\nexport const RandSwapRewardRoundSequence = {\n  encode(\n    message: RandSwapRewardRoundSequence,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.configId.isZero()) {\n      writer.uint32(8).uint64(message.configId);\n    }\n    if (!message.round.isZero()) {\n      writer.uint32(16).uint64(message.round);\n    }\n    if (!message.sequence.isZero()) {\n      writer.uint32(24).uint64(message.sequence);\n    }\n    if (message.address !== \"\") {\n      writer.uint32(34).string(message.address);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): RandSwapRewardRoundSequence {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRandSwapRewardRoundSequence();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.configId = reader.uint64() as Long;\n          break;\n        case 2:\n          message.round = reader.uint64() as Long;\n          break;\n        case 3:\n          message.sequence = reader.uint64() as Long;\n          break;\n        case 4:\n          message.address = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): RandSwapRewardRoundSequence {\n    return {\n      configId: isSet(object.configId)\n        ? Long.fromValue(object.configId)\n        : Long.UZERO,\n      round: isSet(object.round) ? Long.fromValue(object.round) : Long.UZERO,\n      sequence: isSet(object.sequence)\n        ? Long.fromValue(object.sequence)\n        : Long.UZERO,\n      address: isSet(object.address) ? String(object.address) : \"\",\n    };\n  },\n\n  toJSON(message: RandSwapRewardRoundSequence): unknown {\n    const obj: any = {};\n    message.configId !== undefined &&\n      (obj.configId = (message.configId || Long.UZERO).toString());\n    message.round !== undefined &&\n      (obj.round = (message.round || Long.UZERO).toString());\n    message.sequence !== undefined &&\n      (obj.sequence = (message.sequence || Long.UZERO).toString());\n    message.address !== undefined && (obj.address = message.address);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<RandSwapRewardRoundSequence>, I>>(\n    object: I\n  ): RandSwapRewardRoundSequence {\n    const message = createBaseRandSwapRewardRoundSequence();\n    message.configId =\n      object.configId !== undefined && object.configId !== null\n        ? Long.fromValue(object.configId)\n        : Long.UZERO;\n    message.round =\n      object.round !== undefined && object.round !== null\n        ? Long.fromValue(object.round)\n        : Long.UZERO;\n    message.sequence =\n      object.sequence !== undefined && object.sequence !== null\n        ? Long.fromValue(object.sequence)\n        : Long.UZERO;\n    message.address = object.address ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseRandSwapPoolReward(): RandSwapPoolReward {\n  return { address: \"\", configIds: [] };\n}\n\nexport const RandSwapPoolReward = {\n  encode(\n    message: RandSwapPoolReward,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.address !== \"\") {\n      writer.uint32(10).string(message.address);\n    }\n    writer.uint32(18).fork();\n    for (const v of message.configIds) {\n      writer.uint64(v);\n    }\n    writer.ldelim();\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): RandSwapPoolReward {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRandSwapPoolReward();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.address = reader.string();\n          break;\n        case 2:\n          if ((tag & 7) === 2) {\n            const end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.configIds.push(reader.uint64() as Long);\n            }\n          } else {\n            message.configIds.push(reader.uint64() as Long);\n          }\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): RandSwapPoolReward {\n    return {\n      address: isSet(object.address) ? String(object.address) : \"\",\n      configIds: Array.isArray(object?.configIds)\n        ? object.configIds.map((e: any) => Long.fromValue(e))\n        : [],\n    };\n  },\n\n  toJSON(message: RandSwapPoolReward): unknown {\n    const obj: any = {};\n    message.address !== undefined && (obj.address = message.address);\n    if (message.configIds) {\n      obj.configIds = message.configIds.map((e) =>\n        (e || Long.UZERO).toString()\n      );\n    } else {\n      obj.configIds = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<RandSwapPoolReward>, I>>(\n    object: I\n  ): RandSwapPoolReward {\n    const message = createBaseRandSwapPoolReward();\n    message.address = object.address ?? \"\";\n    message.configIds = object.configIds?.map((e) => Long.fromValue(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseRandSwapRewardReveal(): RandSwapRewardReveal {\n  return {\n    configId: Long.UZERO,\n    round: Long.UZERO,\n    config: undefined,\n    subConfigEachReward: [],\n    winnerSequences: [],\n  };\n}\n\nexport const RandSwapRewardReveal = {\n  encode(\n    message: RandSwapRewardReveal,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.configId.isZero()) {\n      writer.uint32(8).uint64(message.configId);\n    }\n    if (!message.round.isZero()) {\n      writer.uint32(16).uint64(message.round);\n    }\n    if (message.config !== undefined) {\n      RandSwapRewardConfig.encode(\n        message.config,\n        writer.uint32(26).fork()\n      ).ldelim();\n    }\n    for (const v of message.subConfigEachReward) {\n      writer.uint32(34).string(v!);\n    }\n    writer.uint32(42).fork();\n    for (const v of message.winnerSequences) {\n      writer.uint64(v);\n    }\n    writer.ldelim();\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): RandSwapRewardReveal {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRandSwapRewardReveal();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.configId = reader.uint64() as Long;\n          break;\n        case 2:\n          message.round = reader.uint64() as Long;\n          break;\n        case 3:\n          message.config = RandSwapRewardConfig.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.subConfigEachReward.push(reader.string());\n          break;\n        case 5:\n          if ((tag & 7) === 2) {\n            const end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.winnerSequences.push(reader.uint64() as Long);\n            }\n          } else {\n            message.winnerSequences.push(reader.uint64() as Long);\n          }\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): RandSwapRewardReveal {\n    return {\n      configId: isSet(object.configId)\n        ? Long.fromValue(object.configId)\n        : Long.UZERO,\n      round: isSet(object.round) ? Long.fromValue(object.round) : Long.UZERO,\n      config: isSet(object.config)\n        ? RandSwapRewardConfig.fromJSON(object.config)\n        : undefined,\n      subConfigEachReward: Array.isArray(object?.subConfigEachReward)\n        ? object.subConfigEachReward.map((e: any) => String(e))\n        : [],\n      winnerSequences: Array.isArray(object?.winnerSequences)\n        ? object.winnerSequences.map((e: any) => Long.fromValue(e))\n        : [],\n    };\n  },\n\n  toJSON(message: RandSwapRewardReveal): unknown {\n    const obj: any = {};\n    message.configId !== undefined &&\n      (obj.configId = (message.configId || Long.UZERO).toString());\n    message.round !== undefined &&\n      (obj.round = (message.round || Long.UZERO).toString());\n    message.config !== undefined &&\n      (obj.config = message.config\n        ? RandSwapRewardConfig.toJSON(message.config)\n        : undefined);\n    if (message.subConfigEachReward) {\n      obj.subConfigEachReward = message.subConfigEachReward.map((e) => e);\n    } else {\n      obj.subConfigEachReward = [];\n    }\n    if (message.winnerSequences) {\n      obj.winnerSequences = message.winnerSequences.map((e) =>\n        (e || Long.UZERO).toString()\n      );\n    } else {\n      obj.winnerSequences = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<RandSwapRewardReveal>, I>>(\n    object: I\n  ): RandSwapRewardReveal {\n    const message = createBaseRandSwapRewardReveal();\n    message.configId =\n      object.configId !== undefined && object.configId !== null\n        ? Long.fromValue(object.configId)\n        : Long.UZERO;\n    message.round =\n      object.round !== undefined && object.round !== null\n        ? Long.fromValue(object.round)\n        : Long.UZERO;\n    message.config =\n      object.config !== undefined && object.config !== null\n        ? RandSwapRewardConfig.fromPartial(object.config)\n        : undefined;\n    message.subConfigEachReward =\n      object.subConfigEachReward?.map((e) => e) || [];\n    message.winnerSequences =\n      object.winnerSequences?.map((e) => Long.fromValue(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseRandSwapAccountReward(): RandSwapAccountReward {\n  return { account: \"\", denom: \"\", amount: \"\" };\n}\n\nexport const RandSwapAccountReward = {\n  encode(\n    message: RandSwapAccountReward,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.account !== \"\") {\n      writer.uint32(10).string(message.account);\n    }\n    if (message.denom !== \"\") {\n      writer.uint32(18).string(message.denom);\n    }\n    if (message.amount !== \"\") {\n      writer.uint32(26).string(message.amount);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): RandSwapAccountReward {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRandSwapAccountReward();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.account = reader.string();\n          break;\n        case 2:\n          message.denom = reader.string();\n          break;\n        case 3:\n          message.amount = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): RandSwapAccountReward {\n    return {\n      account: isSet(object.account) ? String(object.account) : \"\",\n      denom: isSet(object.denom) ? String(object.denom) : \"\",\n      amount: isSet(object.amount) ? String(object.amount) : \"\",\n    };\n  },\n\n  toJSON(message: RandSwapAccountReward): unknown {\n    const obj: any = {};\n    message.account !== undefined && (obj.account = message.account);\n    message.denom !== undefined && (obj.denom = message.denom);\n    message.amount !== undefined && (obj.amount = message.amount);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<RandSwapAccountReward>, I>>(\n    object: I\n  ): RandSwapAccountReward {\n    const message = createBaseRandSwapAccountReward();\n    message.account = object.account ?? \"\";\n    message.denom = object.denom ?? \"\";\n    message.amount = object.amount ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseRandSwapSequenceClear(): RandSwapSequenceClear {\n  return { configId: Long.UZERO, round: Long.UZERO };\n}\n\nexport const RandSwapSequenceClear = {\n  encode(\n    message: RandSwapSequenceClear,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.configId.isZero()) {\n      writer.uint32(8).uint64(message.configId);\n    }\n    if (!message.round.isZero()) {\n      writer.uint32(16).uint64(message.round);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): RandSwapSequenceClear {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRandSwapSequenceClear();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.configId = reader.uint64() as Long;\n          break;\n        case 2:\n          message.round = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): RandSwapSequenceClear {\n    return {\n      configId: isSet(object.configId)\n        ? Long.fromValue(object.configId)\n        : Long.UZERO,\n      round: isSet(object.round) ? Long.fromValue(object.round) : Long.UZERO,\n    };\n  },\n\n  toJSON(message: RandSwapSequenceClear): unknown {\n    const obj: any = {};\n    message.configId !== undefined &&\n      (obj.configId = (message.configId || Long.UZERO).toString());\n    message.round !== undefined &&\n      (obj.round = (message.round || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<RandSwapSequenceClear>, I>>(\n    object: I\n  ): RandSwapSequenceClear {\n    const message = createBaseRandSwapSequenceClear();\n    message.configId =\n      object.configId !== undefined && object.configId !== null\n        ? Long.fromValue(object.configId)\n        : Long.UZERO;\n    message.round =\n      object.round !== undefined && object.round !== null\n        ? Long.fromValue(object.round)\n        : Long.UZERO;\n    return message;\n  },\n};\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"metaoslabs.metaos.poolincentives\";\n\nexport interface LiquidityRewardSubConfig {\n  /** the pool address */\n  address: string;\n  /** the total reward of weight in hundredths of a bip, i.e. 1e-6 */\n  weight: number;\n  /** the index of reward configs */\n  index: number;\n}\n\nexport interface LiquidityRewardConfig {\n  id: Long;\n  enabled: boolean;\n  mintable: boolean;\n  owner: string;\n  denom: string;\n  decimal: number;\n  totalRewardPerDay: string;\n  subConfigs: LiquidityRewardSubConfig[];\n}\n\nexport interface LiquidityRewardDenom {\n  denom: string;\n  configId: Long;\n}\n\nexport interface LiquidityPoolReward {\n  address: string;\n  configIds: Long[];\n}\n\nfunction createBaseLiquidityRewardSubConfig(): LiquidityRewardSubConfig {\n  return { address: \"\", weight: 0, index: 0 };\n}\n\nexport const LiquidityRewardSubConfig = {\n  encode(\n    message: LiquidityRewardSubConfig,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.address !== \"\") {\n      writer.uint32(10).string(message.address);\n    }\n    if (message.weight !== 0) {\n      writer.uint32(16).int32(message.weight);\n    }\n    if (message.index !== 0) {\n      writer.uint32(24).uint32(message.index);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): LiquidityRewardSubConfig {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseLiquidityRewardSubConfig();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.address = reader.string();\n          break;\n        case 2:\n          message.weight = reader.int32();\n          break;\n        case 3:\n          message.index = reader.uint32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): LiquidityRewardSubConfig {\n    return {\n      address: isSet(object.address) ? String(object.address) : \"\",\n      weight: isSet(object.weight) ? Number(object.weight) : 0,\n      index: isSet(object.index) ? Number(object.index) : 0,\n    };\n  },\n\n  toJSON(message: LiquidityRewardSubConfig): unknown {\n    const obj: any = {};\n    message.address !== undefined && (obj.address = message.address);\n    message.weight !== undefined && (obj.weight = Math.round(message.weight));\n    message.index !== undefined && (obj.index = Math.round(message.index));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<LiquidityRewardSubConfig>, I>>(\n    object: I\n  ): LiquidityRewardSubConfig {\n    const message = createBaseLiquidityRewardSubConfig();\n    message.address = object.address ?? \"\";\n    message.weight = object.weight ?? 0;\n    message.index = object.index ?? 0;\n    return message;\n  },\n};\n\nfunction createBaseLiquidityRewardConfig(): LiquidityRewardConfig {\n  return {\n    id: Long.UZERO,\n    enabled: false,\n    mintable: false,\n    owner: \"\",\n    denom: \"\",\n    decimal: 0,\n    totalRewardPerDay: \"\",\n    subConfigs: [],\n  };\n}\n\nexport const LiquidityRewardConfig = {\n  encode(\n    message: LiquidityRewardConfig,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.id.isZero()) {\n      writer.uint32(8).uint64(message.id);\n    }\n    if (message.enabled === true) {\n      writer.uint32(16).bool(message.enabled);\n    }\n    if (message.mintable === true) {\n      writer.uint32(24).bool(message.mintable);\n    }\n    if (message.owner !== \"\") {\n      writer.uint32(34).string(message.owner);\n    }\n    if (message.denom !== \"\") {\n      writer.uint32(42).string(message.denom);\n    }\n    if (message.decimal !== 0) {\n      writer.uint32(48).int32(message.decimal);\n    }\n    if (message.totalRewardPerDay !== \"\") {\n      writer.uint32(58).string(message.totalRewardPerDay);\n    }\n    for (const v of message.subConfigs) {\n      LiquidityRewardSubConfig.encode(v!, writer.uint32(66).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): LiquidityRewardConfig {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseLiquidityRewardConfig();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.uint64() as Long;\n          break;\n        case 2:\n          message.enabled = reader.bool();\n          break;\n        case 3:\n          message.mintable = reader.bool();\n          break;\n        case 4:\n          message.owner = reader.string();\n          break;\n        case 5:\n          message.denom = reader.string();\n          break;\n        case 6:\n          message.decimal = reader.int32();\n          break;\n        case 7:\n          message.totalRewardPerDay = reader.string();\n          break;\n        case 8:\n          message.subConfigs.push(\n            LiquidityRewardSubConfig.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): LiquidityRewardConfig {\n    return {\n      id: isSet(object.id) ? Long.fromValue(object.id) : Long.UZERO,\n      enabled: isSet(object.enabled) ? Boolean(object.enabled) : false,\n      mintable: isSet(object.mintable) ? Boolean(object.mintable) : false,\n      owner: isSet(object.owner) ? String(object.owner) : \"\",\n      denom: isSet(object.denom) ? String(object.denom) : \"\",\n      decimal: isSet(object.decimal) ? Number(object.decimal) : 0,\n      totalRewardPerDay: isSet(object.totalRewardPerDay)\n        ? String(object.totalRewardPerDay)\n        : \"\",\n      subConfigs: Array.isArray(object?.subConfigs)\n        ? object.subConfigs.map((e: any) =>\n            LiquidityRewardSubConfig.fromJSON(e)\n          )\n        : [],\n    };\n  },\n\n  toJSON(message: LiquidityRewardConfig): unknown {\n    const obj: any = {};\n    message.id !== undefined &&\n      (obj.id = (message.id || Long.UZERO).toString());\n    message.enabled !== undefined && (obj.enabled = message.enabled);\n    message.mintable !== undefined && (obj.mintable = message.mintable);\n    message.owner !== undefined && (obj.owner = message.owner);\n    message.denom !== undefined && (obj.denom = message.denom);\n    message.decimal !== undefined &&\n      (obj.decimal = Math.round(message.decimal));\n    message.totalRewardPerDay !== undefined &&\n      (obj.totalRewardPerDay = message.totalRewardPerDay);\n    if (message.subConfigs) {\n      obj.subConfigs = message.subConfigs.map((e) =>\n        e ? LiquidityRewardSubConfig.toJSON(e) : undefined\n      );\n    } else {\n      obj.subConfigs = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<LiquidityRewardConfig>, I>>(\n    object: I\n  ): LiquidityRewardConfig {\n    const message = createBaseLiquidityRewardConfig();\n    message.id =\n      object.id !== undefined && object.id !== null\n        ? Long.fromValue(object.id)\n        : Long.UZERO;\n    message.enabled = object.enabled ?? false;\n    message.mintable = object.mintable ?? false;\n    message.owner = object.owner ?? \"\";\n    message.denom = object.denom ?? \"\";\n    message.decimal = object.decimal ?? 0;\n    message.totalRewardPerDay = object.totalRewardPerDay ?? \"\";\n    message.subConfigs =\n      object.subConfigs?.map((e) => LiquidityRewardSubConfig.fromPartial(e)) ||\n      [];\n    return message;\n  },\n};\n\nfunction createBaseLiquidityRewardDenom(): LiquidityRewardDenom {\n  return { denom: \"\", configId: Long.UZERO };\n}\n\nexport const LiquidityRewardDenom = {\n  encode(\n    message: LiquidityRewardDenom,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.denom !== \"\") {\n      writer.uint32(10).string(message.denom);\n    }\n    if (!message.configId.isZero()) {\n      writer.uint32(16).uint64(message.configId);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): LiquidityRewardDenom {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseLiquidityRewardDenom();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.denom = reader.string();\n          break;\n        case 2:\n          message.configId = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): LiquidityRewardDenom {\n    return {\n      denom: isSet(object.denom) ? String(object.denom) : \"\",\n      configId: isSet(object.configId)\n        ? Long.fromValue(object.configId)\n        : Long.UZERO,\n    };\n  },\n\n  toJSON(message: LiquidityRewardDenom): unknown {\n    const obj: any = {};\n    message.denom !== undefined && (obj.denom = message.denom);\n    message.configId !== undefined &&\n      (obj.configId = (message.configId || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<LiquidityRewardDenom>, I>>(\n    object: I\n  ): LiquidityRewardDenom {\n    const message = createBaseLiquidityRewardDenom();\n    message.denom = object.denom ?? \"\";\n    message.configId =\n      object.configId !== undefined && object.configId !== null\n        ? Long.fromValue(object.configId)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseLiquidityPoolReward(): LiquidityPoolReward {\n  return { address: \"\", configIds: [] };\n}\n\nexport const LiquidityPoolReward = {\n  encode(\n    message: LiquidityPoolReward,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.address !== \"\") {\n      writer.uint32(10).string(message.address);\n    }\n    writer.uint32(18).fork();\n    for (const v of message.configIds) {\n      writer.uint64(v);\n    }\n    writer.ldelim();\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): LiquidityPoolReward {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseLiquidityPoolReward();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.address = reader.string();\n          break;\n        case 2:\n          if ((tag & 7) === 2) {\n            const end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.configIds.push(reader.uint64() as Long);\n            }\n          } else {\n            message.configIds.push(reader.uint64() as Long);\n          }\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): LiquidityPoolReward {\n    return {\n      address: isSet(object.address) ? String(object.address) : \"\",\n      configIds: Array.isArray(object?.configIds)\n        ? object.configIds.map((e: any) => Long.fromValue(e))\n        : [],\n    };\n  },\n\n  toJSON(message: LiquidityPoolReward): unknown {\n    const obj: any = {};\n    message.address !== undefined && (obj.address = message.address);\n    if (message.configIds) {\n      obj.configIds = message.configIds.map((e) =>\n        (e || Long.UZERO).toString()\n      );\n    } else {\n      obj.configIds = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<LiquidityPoolReward>, I>>(\n    object: I\n  ): LiquidityPoolReward {\n    const message = createBaseLiquidityPoolReward();\n    message.address = object.address ?? \"\";\n    message.configIds = object.configIds?.map((e) => Long.fromValue(e)) || [];\n    return message;\n  },\n};\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport { grpc } from \"@improbable-eng/grpc-web\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { RandSwapRewardConfig } from \"./rand_swap_reward\";\nimport { LiquidityRewardConfig } from \"./liquidity_reward\";\nimport { BrowserHeaders } from \"browser-headers\";\n\nexport const protobufPackage = \"metaoslabs.metaos.poolincentives\";\n\nexport interface MsgCreateRandSwapRewardConfig {\n  creator: string;\n  config?: RandSwapRewardConfig;\n}\n\nexport interface MsgCreateRandSwapRewardConfigResponse {}\n\nexport interface MsgOpenRandSwapReward {\n  creator: string;\n  configId: Long;\n}\n\nexport interface MsgOpenRandSwapRewardResponse {}\n\nexport interface MsgCloseRandSwapReward {\n  creator: string;\n  configId: Long;\n}\n\nexport interface MsgCloseRandSwapRewardResponse {}\n\nexport interface MsgUpdateRandSwapRewardConfig {\n  creator: string;\n  configId: Long;\n  config?: RandSwapRewardConfig;\n}\n\nexport interface MsgUpdateRandSwapRewardConfigResponse {}\n\nexport interface MsgCollectRandSwapReward {\n  creator: string;\n  denom: string;\n  recipient: string;\n}\n\nexport interface MsgCollectRandSwapRewardResponse {}\n\nexport interface MsgCreateLiquidityRewardConfig {\n  creator: string;\n  config?: LiquidityRewardConfig;\n}\n\nexport interface MsgCreateLiquidityRewardConfigResponse {}\n\nexport interface MsgUpdateLiquidityRewardConfig {\n  creator: string;\n  configId: Long;\n  config?: LiquidityRewardConfig;\n}\n\nexport interface MsgUpdateLiquidityRewardConfigResponse {}\n\nexport interface MsgOpenLiquidityReward {\n  creator: string;\n  configId: Long;\n}\n\nexport interface MsgOpenLiquidityRewardResponse {}\n\nexport interface MsgCloseLiquidityReward {\n  creator: string;\n  configId: Long;\n}\n\nexport interface MsgCloseLiquidityRewardResponse {}\n\nfunction createBaseMsgCreateRandSwapRewardConfig(): MsgCreateRandSwapRewardConfig {\n  return { creator: \"\", config: undefined };\n}\n\nexport const MsgCreateRandSwapRewardConfig = {\n  encode(\n    message: MsgCreateRandSwapRewardConfig,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.config !== undefined) {\n      RandSwapRewardConfig.encode(\n        message.config,\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCreateRandSwapRewardConfig {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCreateRandSwapRewardConfig();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.config = RandSwapRewardConfig.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCreateRandSwapRewardConfig {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      config: isSet(object.config)\n        ? RandSwapRewardConfig.fromJSON(object.config)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgCreateRandSwapRewardConfig): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.config !== undefined &&\n      (obj.config = message.config\n        ? RandSwapRewardConfig.toJSON(message.config)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCreateRandSwapRewardConfig>, I>>(\n    object: I\n  ): MsgCreateRandSwapRewardConfig {\n    const message = createBaseMsgCreateRandSwapRewardConfig();\n    message.creator = object.creator ?? \"\";\n    message.config =\n      object.config !== undefined && object.config !== null\n        ? RandSwapRewardConfig.fromPartial(object.config)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgCreateRandSwapRewardConfigResponse(): MsgCreateRandSwapRewardConfigResponse {\n  return {};\n}\n\nexport const MsgCreateRandSwapRewardConfigResponse = {\n  encode(\n    _: MsgCreateRandSwapRewardConfigResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCreateRandSwapRewardConfigResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCreateRandSwapRewardConfigResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCreateRandSwapRewardConfigResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCreateRandSwapRewardConfigResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<\n    I extends Exact<DeepPartial<MsgCreateRandSwapRewardConfigResponse>, I>\n  >(_: I): MsgCreateRandSwapRewardConfigResponse {\n    const message = createBaseMsgCreateRandSwapRewardConfigResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgOpenRandSwapReward(): MsgOpenRandSwapReward {\n  return { creator: \"\", configId: Long.UZERO };\n}\n\nexport const MsgOpenRandSwapReward = {\n  encode(\n    message: MsgOpenRandSwapReward,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (!message.configId.isZero()) {\n      writer.uint32(16).uint64(message.configId);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgOpenRandSwapReward {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgOpenRandSwapReward();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.configId = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgOpenRandSwapReward {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      configId: isSet(object.configId)\n        ? Long.fromValue(object.configId)\n        : Long.UZERO,\n    };\n  },\n\n  toJSON(message: MsgOpenRandSwapReward): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.configId !== undefined &&\n      (obj.configId = (message.configId || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgOpenRandSwapReward>, I>>(\n    object: I\n  ): MsgOpenRandSwapReward {\n    const message = createBaseMsgOpenRandSwapReward();\n    message.creator = object.creator ?? \"\";\n    message.configId =\n      object.configId !== undefined && object.configId !== null\n        ? Long.fromValue(object.configId)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseMsgOpenRandSwapRewardResponse(): MsgOpenRandSwapRewardResponse {\n  return {};\n}\n\nexport const MsgOpenRandSwapRewardResponse = {\n  encode(\n    _: MsgOpenRandSwapRewardResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgOpenRandSwapRewardResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgOpenRandSwapRewardResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgOpenRandSwapRewardResponse {\n    return {};\n  },\n\n  toJSON(_: MsgOpenRandSwapRewardResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgOpenRandSwapRewardResponse>, I>>(\n    _: I\n  ): MsgOpenRandSwapRewardResponse {\n    const message = createBaseMsgOpenRandSwapRewardResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgCloseRandSwapReward(): MsgCloseRandSwapReward {\n  return { creator: \"\", configId: Long.UZERO };\n}\n\nexport const MsgCloseRandSwapReward = {\n  encode(\n    message: MsgCloseRandSwapReward,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (!message.configId.isZero()) {\n      writer.uint32(16).uint64(message.configId);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCloseRandSwapReward {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCloseRandSwapReward();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.configId = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCloseRandSwapReward {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      configId: isSet(object.configId)\n        ? Long.fromValue(object.configId)\n        : Long.UZERO,\n    };\n  },\n\n  toJSON(message: MsgCloseRandSwapReward): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.configId !== undefined &&\n      (obj.configId = (message.configId || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCloseRandSwapReward>, I>>(\n    object: I\n  ): MsgCloseRandSwapReward {\n    const message = createBaseMsgCloseRandSwapReward();\n    message.creator = object.creator ?? \"\";\n    message.configId =\n      object.configId !== undefined && object.configId !== null\n        ? Long.fromValue(object.configId)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseMsgCloseRandSwapRewardResponse(): MsgCloseRandSwapRewardResponse {\n  return {};\n}\n\nexport const MsgCloseRandSwapRewardResponse = {\n  encode(\n    _: MsgCloseRandSwapRewardResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCloseRandSwapRewardResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCloseRandSwapRewardResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCloseRandSwapRewardResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCloseRandSwapRewardResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCloseRandSwapRewardResponse>, I>>(\n    _: I\n  ): MsgCloseRandSwapRewardResponse {\n    const message = createBaseMsgCloseRandSwapRewardResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgUpdateRandSwapRewardConfig(): MsgUpdateRandSwapRewardConfig {\n  return { creator: \"\", configId: Long.UZERO, config: undefined };\n}\n\nexport const MsgUpdateRandSwapRewardConfig = {\n  encode(\n    message: MsgUpdateRandSwapRewardConfig,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (!message.configId.isZero()) {\n      writer.uint32(16).uint64(message.configId);\n    }\n    if (message.config !== undefined) {\n      RandSwapRewardConfig.encode(\n        message.config,\n        writer.uint32(26).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgUpdateRandSwapRewardConfig {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgUpdateRandSwapRewardConfig();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.configId = reader.uint64() as Long;\n          break;\n        case 3:\n          message.config = RandSwapRewardConfig.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgUpdateRandSwapRewardConfig {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      configId: isSet(object.configId)\n        ? Long.fromValue(object.configId)\n        : Long.UZERO,\n      config: isSet(object.config)\n        ? RandSwapRewardConfig.fromJSON(object.config)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgUpdateRandSwapRewardConfig): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.configId !== undefined &&\n      (obj.configId = (message.configId || Long.UZERO).toString());\n    message.config !== undefined &&\n      (obj.config = message.config\n        ? RandSwapRewardConfig.toJSON(message.config)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgUpdateRandSwapRewardConfig>, I>>(\n    object: I\n  ): MsgUpdateRandSwapRewardConfig {\n    const message = createBaseMsgUpdateRandSwapRewardConfig();\n    message.creator = object.creator ?? \"\";\n    message.configId =\n      object.configId !== undefined && object.configId !== null\n        ? Long.fromValue(object.configId)\n        : Long.UZERO;\n    message.config =\n      object.config !== undefined && object.config !== null\n        ? RandSwapRewardConfig.fromPartial(object.config)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgUpdateRandSwapRewardConfigResponse(): MsgUpdateRandSwapRewardConfigResponse {\n  return {};\n}\n\nexport const MsgUpdateRandSwapRewardConfigResponse = {\n  encode(\n    _: MsgUpdateRandSwapRewardConfigResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgUpdateRandSwapRewardConfigResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgUpdateRandSwapRewardConfigResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgUpdateRandSwapRewardConfigResponse {\n    return {};\n  },\n\n  toJSON(_: MsgUpdateRandSwapRewardConfigResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<\n    I extends Exact<DeepPartial<MsgUpdateRandSwapRewardConfigResponse>, I>\n  >(_: I): MsgUpdateRandSwapRewardConfigResponse {\n    const message = createBaseMsgUpdateRandSwapRewardConfigResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgCollectRandSwapReward(): MsgCollectRandSwapReward {\n  return { creator: \"\", denom: \"\", recipient: \"\" };\n}\n\nexport const MsgCollectRandSwapReward = {\n  encode(\n    message: MsgCollectRandSwapReward,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.denom !== \"\") {\n      writer.uint32(18).string(message.denom);\n    }\n    if (message.recipient !== \"\") {\n      writer.uint32(26).string(message.recipient);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCollectRandSwapReward {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCollectRandSwapReward();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.denom = reader.string();\n          break;\n        case 3:\n          message.recipient = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCollectRandSwapReward {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      denom: isSet(object.denom) ? String(object.denom) : \"\",\n      recipient: isSet(object.recipient) ? String(object.recipient) : \"\",\n    };\n  },\n\n  toJSON(message: MsgCollectRandSwapReward): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.denom !== undefined && (obj.denom = message.denom);\n    message.recipient !== undefined && (obj.recipient = message.recipient);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCollectRandSwapReward>, I>>(\n    object: I\n  ): MsgCollectRandSwapReward {\n    const message = createBaseMsgCollectRandSwapReward();\n    message.creator = object.creator ?? \"\";\n    message.denom = object.denom ?? \"\";\n    message.recipient = object.recipient ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgCollectRandSwapRewardResponse(): MsgCollectRandSwapRewardResponse {\n  return {};\n}\n\nexport const MsgCollectRandSwapRewardResponse = {\n  encode(\n    _: MsgCollectRandSwapRewardResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCollectRandSwapRewardResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCollectRandSwapRewardResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCollectRandSwapRewardResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCollectRandSwapRewardResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<\n    I extends Exact<DeepPartial<MsgCollectRandSwapRewardResponse>, I>\n  >(_: I): MsgCollectRandSwapRewardResponse {\n    const message = createBaseMsgCollectRandSwapRewardResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgCreateLiquidityRewardConfig(): MsgCreateLiquidityRewardConfig {\n  return { creator: \"\", config: undefined };\n}\n\nexport const MsgCreateLiquidityRewardConfig = {\n  encode(\n    message: MsgCreateLiquidityRewardConfig,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.config !== undefined) {\n      LiquidityRewardConfig.encode(\n        message.config,\n        writer.uint32(26).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCreateLiquidityRewardConfig {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCreateLiquidityRewardConfig();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 3:\n          message.config = LiquidityRewardConfig.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCreateLiquidityRewardConfig {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      config: isSet(object.config)\n        ? LiquidityRewardConfig.fromJSON(object.config)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgCreateLiquidityRewardConfig): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.config !== undefined &&\n      (obj.config = message.config\n        ? LiquidityRewardConfig.toJSON(message.config)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCreateLiquidityRewardConfig>, I>>(\n    object: I\n  ): MsgCreateLiquidityRewardConfig {\n    const message = createBaseMsgCreateLiquidityRewardConfig();\n    message.creator = object.creator ?? \"\";\n    message.config =\n      object.config !== undefined && object.config !== null\n        ? LiquidityRewardConfig.fromPartial(object.config)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgCreateLiquidityRewardConfigResponse(): MsgCreateLiquidityRewardConfigResponse {\n  return {};\n}\n\nexport const MsgCreateLiquidityRewardConfigResponse = {\n  encode(\n    _: MsgCreateLiquidityRewardConfigResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCreateLiquidityRewardConfigResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCreateLiquidityRewardConfigResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCreateLiquidityRewardConfigResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCreateLiquidityRewardConfigResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<\n    I extends Exact<DeepPartial<MsgCreateLiquidityRewardConfigResponse>, I>\n  >(_: I): MsgCreateLiquidityRewardConfigResponse {\n    const message = createBaseMsgCreateLiquidityRewardConfigResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgUpdateLiquidityRewardConfig(): MsgUpdateLiquidityRewardConfig {\n  return { creator: \"\", configId: Long.UZERO, config: undefined };\n}\n\nexport const MsgUpdateLiquidityRewardConfig = {\n  encode(\n    message: MsgUpdateLiquidityRewardConfig,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (!message.configId.isZero()) {\n      writer.uint32(16).uint64(message.configId);\n    }\n    if (message.config !== undefined) {\n      LiquidityRewardConfig.encode(\n        message.config,\n        writer.uint32(34).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgUpdateLiquidityRewardConfig {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgUpdateLiquidityRewardConfig();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.configId = reader.uint64() as Long;\n          break;\n        case 4:\n          message.config = LiquidityRewardConfig.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgUpdateLiquidityRewardConfig {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      configId: isSet(object.configId)\n        ? Long.fromValue(object.configId)\n        : Long.UZERO,\n      config: isSet(object.config)\n        ? LiquidityRewardConfig.fromJSON(object.config)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgUpdateLiquidityRewardConfig): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.configId !== undefined &&\n      (obj.configId = (message.configId || Long.UZERO).toString());\n    message.config !== undefined &&\n      (obj.config = message.config\n        ? LiquidityRewardConfig.toJSON(message.config)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgUpdateLiquidityRewardConfig>, I>>(\n    object: I\n  ): MsgUpdateLiquidityRewardConfig {\n    const message = createBaseMsgUpdateLiquidityRewardConfig();\n    message.creator = object.creator ?? \"\";\n    message.configId =\n      object.configId !== undefined && object.configId !== null\n        ? Long.fromValue(object.configId)\n        : Long.UZERO;\n    message.config =\n      object.config !== undefined && object.config !== null\n        ? LiquidityRewardConfig.fromPartial(object.config)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgUpdateLiquidityRewardConfigResponse(): MsgUpdateLiquidityRewardConfigResponse {\n  return {};\n}\n\nexport const MsgUpdateLiquidityRewardConfigResponse = {\n  encode(\n    _: MsgUpdateLiquidityRewardConfigResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgUpdateLiquidityRewardConfigResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgUpdateLiquidityRewardConfigResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgUpdateLiquidityRewardConfigResponse {\n    return {};\n  },\n\n  toJSON(_: MsgUpdateLiquidityRewardConfigResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<\n    I extends Exact<DeepPartial<MsgUpdateLiquidityRewardConfigResponse>, I>\n  >(_: I): MsgUpdateLiquidityRewardConfigResponse {\n    const message = createBaseMsgUpdateLiquidityRewardConfigResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgOpenLiquidityReward(): MsgOpenLiquidityReward {\n  return { creator: \"\", configId: Long.UZERO };\n}\n\nexport const MsgOpenLiquidityReward = {\n  encode(\n    message: MsgOpenLiquidityReward,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (!message.configId.isZero()) {\n      writer.uint32(16).uint64(message.configId);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgOpenLiquidityReward {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgOpenLiquidityReward();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.configId = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgOpenLiquidityReward {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      configId: isSet(object.configId)\n        ? Long.fromValue(object.configId)\n        : Long.UZERO,\n    };\n  },\n\n  toJSON(message: MsgOpenLiquidityReward): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.configId !== undefined &&\n      (obj.configId = (message.configId || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgOpenLiquidityReward>, I>>(\n    object: I\n  ): MsgOpenLiquidityReward {\n    const message = createBaseMsgOpenLiquidityReward();\n    message.creator = object.creator ?? \"\";\n    message.configId =\n      object.configId !== undefined && object.configId !== null\n        ? Long.fromValue(object.configId)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseMsgOpenLiquidityRewardResponse(): MsgOpenLiquidityRewardResponse {\n  return {};\n}\n\nexport const MsgOpenLiquidityRewardResponse = {\n  encode(\n    _: MsgOpenLiquidityRewardResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgOpenLiquidityRewardResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgOpenLiquidityRewardResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgOpenLiquidityRewardResponse {\n    return {};\n  },\n\n  toJSON(_: MsgOpenLiquidityRewardResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgOpenLiquidityRewardResponse>, I>>(\n    _: I\n  ): MsgOpenLiquidityRewardResponse {\n    const message = createBaseMsgOpenLiquidityRewardResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgCloseLiquidityReward(): MsgCloseLiquidityReward {\n  return { creator: \"\", configId: Long.UZERO };\n}\n\nexport const MsgCloseLiquidityReward = {\n  encode(\n    message: MsgCloseLiquidityReward,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (!message.configId.isZero()) {\n      writer.uint32(16).uint64(message.configId);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCloseLiquidityReward {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCloseLiquidityReward();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.configId = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCloseLiquidityReward {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      configId: isSet(object.configId)\n        ? Long.fromValue(object.configId)\n        : Long.UZERO,\n    };\n  },\n\n  toJSON(message: MsgCloseLiquidityReward): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.configId !== undefined &&\n      (obj.configId = (message.configId || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCloseLiquidityReward>, I>>(\n    object: I\n  ): MsgCloseLiquidityReward {\n    const message = createBaseMsgCloseLiquidityReward();\n    message.creator = object.creator ?? \"\";\n    message.configId =\n      object.configId !== undefined && object.configId !== null\n        ? Long.fromValue(object.configId)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseMsgCloseLiquidityRewardResponse(): MsgCloseLiquidityRewardResponse {\n  return {};\n}\n\nexport const MsgCloseLiquidityRewardResponse = {\n  encode(\n    _: MsgCloseLiquidityRewardResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCloseLiquidityRewardResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCloseLiquidityRewardResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCloseLiquidityRewardResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCloseLiquidityRewardResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCloseLiquidityRewardResponse>, I>>(\n    _: I\n  ): MsgCloseLiquidityRewardResponse {\n    const message = createBaseMsgCloseLiquidityRewardResponse();\n    return message;\n  },\n};\n\n/** Msg defines the Msg service. */\nexport interface Msg {\n  CreateRandSwapRewardConfig(\n    request: DeepPartial<MsgCreateRandSwapRewardConfig>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCreateRandSwapRewardConfigResponse>;\n  UpdateRandSwapRewardConfig(\n    request: DeepPartial<MsgUpdateRandSwapRewardConfig>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgUpdateRandSwapRewardConfigResponse>;\n  OpenRandSwapReward(\n    request: DeepPartial<MsgOpenRandSwapReward>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgOpenRandSwapRewardResponse>;\n  CloseRandSwapReward(\n    request: DeepPartial<MsgCloseRandSwapReward>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCloseRandSwapRewardResponse>;\n  CollectRandSwapReward(\n    request: DeepPartial<MsgCollectRandSwapReward>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCollectRandSwapRewardResponse>;\n  CreateLiquidityRewardConfig(\n    request: DeepPartial<MsgCreateLiquidityRewardConfig>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCreateLiquidityRewardConfigResponse>;\n  UpdateLiquidityRewardConfig(\n    request: DeepPartial<MsgUpdateLiquidityRewardConfig>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgUpdateLiquidityRewardConfigResponse>;\n  OpenLiquidityReward(\n    request: DeepPartial<MsgOpenLiquidityReward>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgOpenLiquidityRewardResponse>;\n  /** this line is used by starport scaffolding # proto/tx/rpc */\n  CloseLiquidityReward(\n    request: DeepPartial<MsgCloseLiquidityReward>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCloseLiquidityRewardResponse>;\n}\n\nexport class MsgClientImpl implements Msg {\n  private readonly rpc: Rpc;\n\n  constructor(rpc: Rpc) {\n    this.rpc = rpc;\n    this.CreateRandSwapRewardConfig =\n      this.CreateRandSwapRewardConfig.bind(this);\n    this.UpdateRandSwapRewardConfig =\n      this.UpdateRandSwapRewardConfig.bind(this);\n    this.OpenRandSwapReward = this.OpenRandSwapReward.bind(this);\n    this.CloseRandSwapReward = this.CloseRandSwapReward.bind(this);\n    this.CollectRandSwapReward = this.CollectRandSwapReward.bind(this);\n    this.CreateLiquidityRewardConfig =\n      this.CreateLiquidityRewardConfig.bind(this);\n    this.UpdateLiquidityRewardConfig =\n      this.UpdateLiquidityRewardConfig.bind(this);\n    this.OpenLiquidityReward = this.OpenLiquidityReward.bind(this);\n    this.CloseLiquidityReward = this.CloseLiquidityReward.bind(this);\n  }\n\n  CreateRandSwapRewardConfig(\n    request: DeepPartial<MsgCreateRandSwapRewardConfig>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCreateRandSwapRewardConfigResponse> {\n    return this.rpc.unary(\n      MsgCreateRandSwapRewardConfigDesc,\n      MsgCreateRandSwapRewardConfig.fromPartial(request),\n      metadata\n    );\n  }\n\n  UpdateRandSwapRewardConfig(\n    request: DeepPartial<MsgUpdateRandSwapRewardConfig>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgUpdateRandSwapRewardConfigResponse> {\n    return this.rpc.unary(\n      MsgUpdateRandSwapRewardConfigDesc,\n      MsgUpdateRandSwapRewardConfig.fromPartial(request),\n      metadata\n    );\n  }\n\n  OpenRandSwapReward(\n    request: DeepPartial<MsgOpenRandSwapReward>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgOpenRandSwapRewardResponse> {\n    return this.rpc.unary(\n      MsgOpenRandSwapRewardDesc,\n      MsgOpenRandSwapReward.fromPartial(request),\n      metadata\n    );\n  }\n\n  CloseRandSwapReward(\n    request: DeepPartial<MsgCloseRandSwapReward>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCloseRandSwapRewardResponse> {\n    return this.rpc.unary(\n      MsgCloseRandSwapRewardDesc,\n      MsgCloseRandSwapReward.fromPartial(request),\n      metadata\n    );\n  }\n\n  CollectRandSwapReward(\n    request: DeepPartial<MsgCollectRandSwapReward>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCollectRandSwapRewardResponse> {\n    return this.rpc.unary(\n      MsgCollectRandSwapRewardDesc,\n      MsgCollectRandSwapReward.fromPartial(request),\n      metadata\n    );\n  }\n\n  CreateLiquidityRewardConfig(\n    request: DeepPartial<MsgCreateLiquidityRewardConfig>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCreateLiquidityRewardConfigResponse> {\n    return this.rpc.unary(\n      MsgCreateLiquidityRewardConfigDesc,\n      MsgCreateLiquidityRewardConfig.fromPartial(request),\n      metadata\n    );\n  }\n\n  UpdateLiquidityRewardConfig(\n    request: DeepPartial<MsgUpdateLiquidityRewardConfig>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgUpdateLiquidityRewardConfigResponse> {\n    return this.rpc.unary(\n      MsgUpdateLiquidityRewardConfigDesc,\n      MsgUpdateLiquidityRewardConfig.fromPartial(request),\n      metadata\n    );\n  }\n\n  OpenLiquidityReward(\n    request: DeepPartial<MsgOpenLiquidityReward>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgOpenLiquidityRewardResponse> {\n    return this.rpc.unary(\n      MsgOpenLiquidityRewardDesc,\n      MsgOpenLiquidityReward.fromPartial(request),\n      metadata\n    );\n  }\n\n  CloseLiquidityReward(\n    request: DeepPartial<MsgCloseLiquidityReward>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCloseLiquidityRewardResponse> {\n    return this.rpc.unary(\n      MsgCloseLiquidityRewardDesc,\n      MsgCloseLiquidityReward.fromPartial(request),\n      metadata\n    );\n  }\n}\n\nexport const MsgDesc = {\n  serviceName: \"metaoslabs.metaos.poolincentives.Msg\",\n};\n\nexport const MsgCreateRandSwapRewardConfigDesc: UnaryMethodDefinitionish = {\n  methodName: \"CreateRandSwapRewardConfig\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCreateRandSwapRewardConfig.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCreateRandSwapRewardConfigResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgUpdateRandSwapRewardConfigDesc: UnaryMethodDefinitionish = {\n  methodName: \"UpdateRandSwapRewardConfig\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgUpdateRandSwapRewardConfig.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgUpdateRandSwapRewardConfigResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgOpenRandSwapRewardDesc: UnaryMethodDefinitionish = {\n  methodName: \"OpenRandSwapReward\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgOpenRandSwapReward.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgOpenRandSwapRewardResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgCloseRandSwapRewardDesc: UnaryMethodDefinitionish = {\n  methodName: \"CloseRandSwapReward\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCloseRandSwapReward.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCloseRandSwapRewardResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgCollectRandSwapRewardDesc: UnaryMethodDefinitionish = {\n  methodName: \"CollectRandSwapReward\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCollectRandSwapReward.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCollectRandSwapRewardResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgCreateLiquidityRewardConfigDesc: UnaryMethodDefinitionish = {\n  methodName: \"CreateLiquidityRewardConfig\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCreateLiquidityRewardConfig.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCreateLiquidityRewardConfigResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgUpdateLiquidityRewardConfigDesc: UnaryMethodDefinitionish = {\n  methodName: \"UpdateLiquidityRewardConfig\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgUpdateLiquidityRewardConfig.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgUpdateLiquidityRewardConfigResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgOpenLiquidityRewardDesc: UnaryMethodDefinitionish = {\n  methodName: \"OpenLiquidityReward\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgOpenLiquidityReward.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgOpenLiquidityRewardResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgCloseLiquidityRewardDesc: UnaryMethodDefinitionish = {\n  methodName: \"CloseLiquidityReward\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCloseLiquidityReward.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCloseLiquidityRewardResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\ninterface UnaryMethodDefinitionishR\n  extends grpc.UnaryMethodDefinition<any, any> {\n  requestStream: any;\n  responseStream: any;\n}\n\ntype UnaryMethodDefinitionish = UnaryMethodDefinitionishR;\n\ninterface Rpc {\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any>;\n}\n\nexport class GrpcWebImpl {\n  private host: string;\n  private options: {\n    transport?: grpc.TransportFactory;\n\n    debug?: boolean;\n    metadata?: grpc.Metadata;\n  };\n\n  constructor(\n    host: string,\n    options: {\n      transport?: grpc.TransportFactory;\n\n      debug?: boolean;\n      metadata?: grpc.Metadata;\n    }\n  ) {\n    this.host = host;\n    this.options = options;\n  }\n\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    _request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any> {\n    const request = { ..._request, ...methodDesc.requestType };\n    const maybeCombinedMetadata =\n      metadata && this.options.metadata\n        ? new BrowserHeaders({\n            ...this.options?.metadata.headersMap,\n            ...metadata?.headersMap,\n          })\n        : metadata || this.options.metadata;\n    return new Promise((resolve, reject) => {\n      grpc.unary(methodDesc, {\n        request,\n        host: this.host,\n        metadata: maybeCombinedMetadata,\n        transport: this.options.transport,\n        debug: this.options.debug,\n        onEnd: function (response) {\n          if (response.status === grpc.Code.OK) {\n            resolve(response.message);\n          } else {\n            const err = new Error(response.statusMessage) as any;\n            err.code = response.status;\n            err.metadata = response.trailers;\n            reject(err);\n          }\n        },\n      });\n    });\n  }\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","import {\n  protobufPackage,\n  MsgCreateRandSwapRewardConfig as MsgCreateRandSwapRewardConfig_pb,\n  MsgOpenRandSwapReward as MsgOpenRandSwapReward_pb,\n  MsgCloseRandSwapReward as MsgCloseRandSwapReward_pb,\n  MsgUpdateRandSwapRewardConfig as MsgUpdateRandSwapRewardConfig_pb,\n  MsgCollectRandSwapReward as MsgCollectRandSwapReward_pb,\n  MsgCreateLiquidityRewardConfig as MsgCreateLiquidityRewardConfig_pb,\n  MsgUpdateLiquidityRewardConfig as MsgUpdateLiquidityRewardConfig_pb,\n  MsgOpenLiquidityReward as MsgOpenLiquidityReward_pb,\n  MsgCloseLiquidityReward as MsgCloseLiquidityReward_pb,\n} from \"../proto/pool-incentives/tx\";\nimport { BaseMsg } from \"./BaseMsg\";\nimport { EncodeObject } from \"@cosmjs/proto-signing\";\n\nexport class MsgCreateRandSwapRewardConfig extends BaseMsg {\n  public protoMsg: MsgCreateRandSwapRewardConfig_pb;\n  constructor(msg: MsgCreateRandSwapRewardConfig_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgCreateRandSwapRewardConfig.typeUrl,\n      value: MsgCreateRandSwapRewardConfig_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgCreateRandSwapRewardConfig {\n  export const typeUrl: string = `/${protobufPackage}.MsgCreateRandSwapRewardConfig`;\n  export const Proto = MsgCreateRandSwapRewardConfig_pb;\n  export interface Proto extends MsgCreateRandSwapRewardConfig_pb {}\n}\n\nexport class MsgCollectRandSwapReward extends BaseMsg {\n  public protoMsg: MsgCollectRandSwapReward_pb;\n  constructor(msg: MsgCollectRandSwapReward_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgCollectRandSwapReward.typeUrl,\n      value: MsgCollectRandSwapReward_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgCollectRandSwapReward {\n  export const typeUrl: string = `/${protobufPackage}.MsgCollectRandSwapReward`;\n  export const Proto = MsgCollectRandSwapReward_pb;\n  export interface Proto extends MsgCollectRandSwapReward_pb {}\n}\n\nexport class MsgOpenRandSwapReward extends BaseMsg {\n  public protoMsg: MsgOpenRandSwapReward_pb;\n  constructor(msg: MsgOpenRandSwapReward_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgOpenRandSwapReward.typeUrl,\n      value: MsgOpenRandSwapReward_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgOpenRandSwapReward {\n  export const typeUrl: string = `/${protobufPackage}.MsgOpenRandSwapReward`;\n  export const Proto = MsgOpenRandSwapReward_pb;\n  export interface Proto extends MsgOpenRandSwapReward_pb {}\n}\n\nexport class MsgCloseRandSwapReward extends BaseMsg {\n  public protoMsg: MsgCloseRandSwapReward_pb;\n  constructor(msg: MsgCloseRandSwapReward_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgCloseRandSwapReward.typeUrl,\n      value: MsgCloseRandSwapReward_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgCloseRandSwapReward {\n  export const typeUrl: string = `/${protobufPackage}.MsgCloseRandSwapReward`;\n  export const Proto = MsgCloseRandSwapReward_pb;\n  export interface Proto extends MsgCloseRandSwapReward_pb {}\n}\n\nexport class MsgUpdateRandSwapRewardConfig extends BaseMsg {\n  public protoMsg: MsgUpdateRandSwapRewardConfig_pb;\n  constructor(msg: MsgUpdateRandSwapRewardConfig_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgUpdateRandSwapRewardConfig.typeUrl,\n      value: MsgUpdateRandSwapRewardConfig_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgUpdateRandSwapRewardConfig {\n  export const typeUrl: string = `/${protobufPackage}.MsgUpdateRandSwapRewardConfig`;\n  export const Proto = MsgUpdateRandSwapRewardConfig_pb;\n  export interface Proto extends MsgUpdateRandSwapRewardConfig_pb {}\n}\n\nexport class MsgCreateLiquidityRewardConfig extends BaseMsg {\n  public protoMsg: MsgCreateLiquidityRewardConfig_pb;\n  constructor(msg: MsgCreateLiquidityRewardConfig_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgCreateLiquidityRewardConfig.typeUrl,\n      value: MsgCreateLiquidityRewardConfig_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgCreateLiquidityRewardConfig {\n  export const typeUrl: string = `/${protobufPackage}.MsgCreateLiquidityRewardConfig`;\n  export const Proto = MsgCreateLiquidityRewardConfig_pb;\n  export interface Proto extends MsgCreateLiquidityRewardConfig_pb {}\n}\n\nexport class MsgUpdateLiquidityRewardConfig extends BaseMsg {\n  public protoMsg: MsgUpdateLiquidityRewardConfig_pb;\n  constructor(msg: MsgUpdateLiquidityRewardConfig_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgUpdateLiquidityRewardConfig.typeUrl,\n      value: MsgUpdateLiquidityRewardConfig_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgUpdateLiquidityRewardConfig {\n  export const typeUrl: string = `/${protobufPackage}.MsgUpdateLiquidityRewardConfig`;\n  export const Proto = MsgUpdateLiquidityRewardConfig_pb;\n  export interface Proto extends MsgUpdateLiquidityRewardConfig_pb {}\n}\n\nexport class MsgOpenLiquidityReward extends BaseMsg {\n  public protoMsg: MsgOpenLiquidityReward_pb;\n  constructor(msg: MsgOpenLiquidityReward_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgOpenLiquidityReward.typeUrl,\n      value: MsgOpenLiquidityReward_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgOpenLiquidityReward {\n  export const typeUrl: string = `/${protobufPackage}.MsgOpenLiquidityReward`;\n  export const Proto = MsgOpenLiquidityReward_pb;\n  export interface Proto extends MsgOpenLiquidityReward_pb {}\n}\n\nexport class MsgCloseLiquidityReward extends BaseMsg {\n  public protoMsg: MsgCloseLiquidityReward_pb;\n  constructor(msg: MsgCloseLiquidityReward_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgCloseLiquidityReward.typeUrl,\n      value: MsgCloseLiquidityReward_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgCloseLiquidityReward {\n  export const typeUrl: string = `/${protobufPackage}.MsgCloseLiquidityReward`;\n  export const Proto = MsgCloseLiquidityReward_pb;\n  export interface Proto extends MsgCloseLiquidityReward_pb {}\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"tendermint.crypto\";\n\nexport interface Proof {\n  total: Long;\n  index: Long;\n  leafHash: Uint8Array;\n  aunts: Uint8Array[];\n}\n\nexport interface ValueOp {\n  /** Encoded in ProofOp.Key. */\n  key: Uint8Array;\n  /** To encode in ProofOp.Data */\n  proof?: Proof;\n}\n\nexport interface DominoOp {\n  key: string;\n  input: string;\n  output: string;\n}\n\n/**\n * ProofOp defines an operation used for calculating Merkle root\n * The data could be arbitrary format, providing nessecary data\n * for example neighbouring node hash\n */\nexport interface ProofOp {\n  type: string;\n  key: Uint8Array;\n  data: Uint8Array;\n}\n\n/** ProofOps is Merkle proof defined by the list of ProofOps */\nexport interface ProofOps {\n  ops: ProofOp[];\n}\n\nfunction createBaseProof(): Proof {\n  return {\n    total: Long.ZERO,\n    index: Long.ZERO,\n    leafHash: new Uint8Array(),\n    aunts: [],\n  };\n}\n\nexport const Proof = {\n  encode(message: Proof, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (!message.total.isZero()) {\n      writer.uint32(8).int64(message.total);\n    }\n    if (!message.index.isZero()) {\n      writer.uint32(16).int64(message.index);\n    }\n    if (message.leafHash.length !== 0) {\n      writer.uint32(26).bytes(message.leafHash);\n    }\n    for (const v of message.aunts) {\n      writer.uint32(34).bytes(v!);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Proof {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseProof();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.total = reader.int64() as Long;\n          break;\n        case 2:\n          message.index = reader.int64() as Long;\n          break;\n        case 3:\n          message.leafHash = reader.bytes();\n          break;\n        case 4:\n          message.aunts.push(reader.bytes());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Proof {\n    return {\n      total: isSet(object.total) ? Long.fromValue(object.total) : Long.ZERO,\n      index: isSet(object.index) ? Long.fromValue(object.index) : Long.ZERO,\n      leafHash: isSet(object.leafHash)\n        ? bytesFromBase64(object.leafHash)\n        : new Uint8Array(),\n      aunts: Array.isArray(object?.aunts)\n        ? object.aunts.map((e: any) => bytesFromBase64(e))\n        : [],\n    };\n  },\n\n  toJSON(message: Proof): unknown {\n    const obj: any = {};\n    message.total !== undefined &&\n      (obj.total = (message.total || Long.ZERO).toString());\n    message.index !== undefined &&\n      (obj.index = (message.index || Long.ZERO).toString());\n    message.leafHash !== undefined &&\n      (obj.leafHash = base64FromBytes(\n        message.leafHash !== undefined ? message.leafHash : new Uint8Array()\n      ));\n    if (message.aunts) {\n      obj.aunts = message.aunts.map((e) =>\n        base64FromBytes(e !== undefined ? e : new Uint8Array())\n      );\n    } else {\n      obj.aunts = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Proof>, I>>(object: I): Proof {\n    const message = createBaseProof();\n    message.total =\n      object.total !== undefined && object.total !== null\n        ? Long.fromValue(object.total)\n        : Long.ZERO;\n    message.index =\n      object.index !== undefined && object.index !== null\n        ? Long.fromValue(object.index)\n        : Long.ZERO;\n    message.leafHash = object.leafHash ?? new Uint8Array();\n    message.aunts = object.aunts?.map((e) => e) || [];\n    return message;\n  },\n};\n\nfunction createBaseValueOp(): ValueOp {\n  return { key: new Uint8Array(), proof: undefined };\n}\n\nexport const ValueOp = {\n  encode(\n    message: ValueOp,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n    if (message.proof !== undefined) {\n      Proof.encode(message.proof, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): ValueOp {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseValueOp();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n        case 2:\n          message.proof = Proof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ValueOp {\n    return {\n      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),\n      proof: isSet(object.proof) ? Proof.fromJSON(object.proof) : undefined,\n    };\n  },\n\n  toJSON(message: ValueOp): unknown {\n    const obj: any = {};\n    message.key !== undefined &&\n      (obj.key = base64FromBytes(\n        message.key !== undefined ? message.key : new Uint8Array()\n      ));\n    message.proof !== undefined &&\n      (obj.proof = message.proof ? Proof.toJSON(message.proof) : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<ValueOp>, I>>(object: I): ValueOp {\n    const message = createBaseValueOp();\n    message.key = object.key ?? new Uint8Array();\n    message.proof =\n      object.proof !== undefined && object.proof !== null\n        ? Proof.fromPartial(object.proof)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseDominoOp(): DominoOp {\n  return { key: \"\", input: \"\", output: \"\" };\n}\n\nexport const DominoOp = {\n  encode(\n    message: DominoOp,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.key !== \"\") {\n      writer.uint32(10).string(message.key);\n    }\n    if (message.input !== \"\") {\n      writer.uint32(18).string(message.input);\n    }\n    if (message.output !== \"\") {\n      writer.uint32(26).string(message.output);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): DominoOp {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDominoOp();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.string();\n          break;\n        case 2:\n          message.input = reader.string();\n          break;\n        case 3:\n          message.output = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): DominoOp {\n    return {\n      key: isSet(object.key) ? String(object.key) : \"\",\n      input: isSet(object.input) ? String(object.input) : \"\",\n      output: isSet(object.output) ? String(object.output) : \"\",\n    };\n  },\n\n  toJSON(message: DominoOp): unknown {\n    const obj: any = {};\n    message.key !== undefined && (obj.key = message.key);\n    message.input !== undefined && (obj.input = message.input);\n    message.output !== undefined && (obj.output = message.output);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<DominoOp>, I>>(object: I): DominoOp {\n    const message = createBaseDominoOp();\n    message.key = object.key ?? \"\";\n    message.input = object.input ?? \"\";\n    message.output = object.output ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseProofOp(): ProofOp {\n  return { type: \"\", key: new Uint8Array(), data: new Uint8Array() };\n}\n\nexport const ProofOp = {\n  encode(\n    message: ProofOp,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.type !== \"\") {\n      writer.uint32(10).string(message.type);\n    }\n    if (message.key.length !== 0) {\n      writer.uint32(18).bytes(message.key);\n    }\n    if (message.data.length !== 0) {\n      writer.uint32(26).bytes(message.data);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): ProofOp {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseProofOp();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.type = reader.string();\n          break;\n        case 2:\n          message.key = reader.bytes();\n          break;\n        case 3:\n          message.data = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ProofOp {\n    return {\n      type: isSet(object.type) ? String(object.type) : \"\",\n      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),\n      data: isSet(object.data)\n        ? bytesFromBase64(object.data)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: ProofOp): unknown {\n    const obj: any = {};\n    message.type !== undefined && (obj.type = message.type);\n    message.key !== undefined &&\n      (obj.key = base64FromBytes(\n        message.key !== undefined ? message.key : new Uint8Array()\n      ));\n    message.data !== undefined &&\n      (obj.data = base64FromBytes(\n        message.data !== undefined ? message.data : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<ProofOp>, I>>(object: I): ProofOp {\n    const message = createBaseProofOp();\n    message.type = object.type ?? \"\";\n    message.key = object.key ?? new Uint8Array();\n    message.data = object.data ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBaseProofOps(): ProofOps {\n  return { ops: [] };\n}\n\nexport const ProofOps = {\n  encode(\n    message: ProofOps,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.ops) {\n      ProofOp.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): ProofOps {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseProofOps();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.ops.push(ProofOp.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ProofOps {\n    return {\n      ops: Array.isArray(object?.ops)\n        ? object.ops.map((e: any) => ProofOp.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: ProofOps): unknown {\n    const obj: any = {};\n    if (message.ops) {\n      obj.ops = message.ops.map((e) => (e ? ProofOp.toJSON(e) : undefined));\n    } else {\n      obj.ops = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<ProofOps>, I>>(object: I): ProofOps {\n    const message = createBaseProofOps();\n    message.ops = object.ops?.map((e) => ProofOp.fromPartial(e)) || [];\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"tendermint.version\";\n\n/**\n * App includes the protocol and software version for the application.\n * This information is included in ResponseInfo. The App.Protocol can be\n * updated in ResponseEndBlock.\n */\nexport interface App {\n  protocol: Long;\n  software: string;\n}\n\n/**\n * Consensus captures the consensus rules for processing a block in the\n * blockchain, including all blockchain data structures and the rules of the\n * application's state transition machine.\n */\nexport interface Consensus {\n  block: Long;\n  app: Long;\n}\n\nfunction createBaseApp(): App {\n  return { protocol: Long.UZERO, software: \"\" };\n}\n\nexport const App = {\n  encode(message: App, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (!message.protocol.isZero()) {\n      writer.uint32(8).uint64(message.protocol);\n    }\n    if (message.software !== \"\") {\n      writer.uint32(18).string(message.software);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): App {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseApp();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.protocol = reader.uint64() as Long;\n          break;\n        case 2:\n          message.software = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): App {\n    return {\n      protocol: isSet(object.protocol)\n        ? Long.fromValue(object.protocol)\n        : Long.UZERO,\n      software: isSet(object.software) ? String(object.software) : \"\",\n    };\n  },\n\n  toJSON(message: App): unknown {\n    const obj: any = {};\n    message.protocol !== undefined &&\n      (obj.protocol = (message.protocol || Long.UZERO).toString());\n    message.software !== undefined && (obj.software = message.software);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<App>, I>>(object: I): App {\n    const message = createBaseApp();\n    message.protocol =\n      object.protocol !== undefined && object.protocol !== null\n        ? Long.fromValue(object.protocol)\n        : Long.UZERO;\n    message.software = object.software ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseConsensus(): Consensus {\n  return { block: Long.UZERO, app: Long.UZERO };\n}\n\nexport const Consensus = {\n  encode(\n    message: Consensus,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.block.isZero()) {\n      writer.uint32(8).uint64(message.block);\n    }\n    if (!message.app.isZero()) {\n      writer.uint32(16).uint64(message.app);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Consensus {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseConsensus();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.block = reader.uint64() as Long;\n          break;\n        case 2:\n          message.app = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Consensus {\n    return {\n      block: isSet(object.block) ? Long.fromValue(object.block) : Long.UZERO,\n      app: isSet(object.app) ? Long.fromValue(object.app) : Long.UZERO,\n    };\n  },\n\n  toJSON(message: Consensus): unknown {\n    const obj: any = {};\n    message.block !== undefined &&\n      (obj.block = (message.block || Long.UZERO).toString());\n    message.app !== undefined &&\n      (obj.app = (message.app || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Consensus>, I>>(\n    object: I\n  ): Consensus {\n    const message = createBaseConsensus();\n    message.block =\n      object.block !== undefined && object.block !== null\n        ? Long.fromValue(object.block)\n        : Long.UZERO;\n    message.app =\n      object.app !== undefined && object.app !== null\n        ? Long.fromValue(object.app)\n        : Long.UZERO;\n    return message;\n  },\n};\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"tendermint.crypto\";\n\n/** PublicKey defines the keys available for use with Tendermint Validators */\nexport interface PublicKey {\n  ed25519: Uint8Array | undefined;\n  secp256k1: Uint8Array | undefined;\n}\n\nfunction createBasePublicKey(): PublicKey {\n  return { ed25519: undefined, secp256k1: undefined };\n}\n\nexport const PublicKey = {\n  encode(\n    message: PublicKey,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.ed25519 !== undefined) {\n      writer.uint32(10).bytes(message.ed25519);\n    }\n    if (message.secp256k1 !== undefined) {\n      writer.uint32(18).bytes(message.secp256k1);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): PublicKey {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBasePublicKey();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.ed25519 = reader.bytes();\n          break;\n        case 2:\n          message.secp256k1 = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): PublicKey {\n    return {\n      ed25519: isSet(object.ed25519)\n        ? bytesFromBase64(object.ed25519)\n        : undefined,\n      secp256k1: isSet(object.secp256k1)\n        ? bytesFromBase64(object.secp256k1)\n        : undefined,\n    };\n  },\n\n  toJSON(message: PublicKey): unknown {\n    const obj: any = {};\n    message.ed25519 !== undefined &&\n      (obj.ed25519 =\n        message.ed25519 !== undefined\n          ? base64FromBytes(message.ed25519)\n          : undefined);\n    message.secp256k1 !== undefined &&\n      (obj.secp256k1 =\n        message.secp256k1 !== undefined\n          ? base64FromBytes(message.secp256k1)\n          : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<PublicKey>, I>>(\n    object: I\n  ): PublicKey {\n    const message = createBasePublicKey();\n    message.ed25519 = object.ed25519 ?? undefined;\n    message.secp256k1 = object.secp256k1 ?? undefined;\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { PublicKey } from \"../crypto/keys\";\n\nexport const protobufPackage = \"tendermint.types\";\n\nexport interface ValidatorSet {\n  validators: Validator[];\n  proposer?: Validator;\n  totalVotingPower: Long;\n}\n\nexport interface Validator {\n  address: Uint8Array;\n  pubKey?: PublicKey;\n  votingPower: Long;\n  proposerPriority: Long;\n}\n\nexport interface SimpleValidator {\n  pubKey?: PublicKey;\n  votingPower: Long;\n}\n\nfunction createBaseValidatorSet(): ValidatorSet {\n  return { validators: [], proposer: undefined, totalVotingPower: Long.ZERO };\n}\n\nexport const ValidatorSet = {\n  encode(\n    message: ValidatorSet,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.validators) {\n      Validator.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.proposer !== undefined) {\n      Validator.encode(message.proposer, writer.uint32(18).fork()).ldelim();\n    }\n    if (!message.totalVotingPower.isZero()) {\n      writer.uint32(24).int64(message.totalVotingPower);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): ValidatorSet {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseValidatorSet();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.validators.push(Validator.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.proposer = Validator.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.totalVotingPower = reader.int64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ValidatorSet {\n    return {\n      validators: Array.isArray(object?.validators)\n        ? object.validators.map((e: any) => Validator.fromJSON(e))\n        : [],\n      proposer: isSet(object.proposer)\n        ? Validator.fromJSON(object.proposer)\n        : undefined,\n      totalVotingPower: isSet(object.totalVotingPower)\n        ? Long.fromValue(object.totalVotingPower)\n        : Long.ZERO,\n    };\n  },\n\n  toJSON(message: ValidatorSet): unknown {\n    const obj: any = {};\n    if (message.validators) {\n      obj.validators = message.validators.map((e) =>\n        e ? Validator.toJSON(e) : undefined\n      );\n    } else {\n      obj.validators = [];\n    }\n    message.proposer !== undefined &&\n      (obj.proposer = message.proposer\n        ? Validator.toJSON(message.proposer)\n        : undefined);\n    message.totalVotingPower !== undefined &&\n      (obj.totalVotingPower = (\n        message.totalVotingPower || Long.ZERO\n      ).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<ValidatorSet>, I>>(\n    object: I\n  ): ValidatorSet {\n    const message = createBaseValidatorSet();\n    message.validators =\n      object.validators?.map((e) => Validator.fromPartial(e)) || [];\n    message.proposer =\n      object.proposer !== undefined && object.proposer !== null\n        ? Validator.fromPartial(object.proposer)\n        : undefined;\n    message.totalVotingPower =\n      object.totalVotingPower !== undefined && object.totalVotingPower !== null\n        ? Long.fromValue(object.totalVotingPower)\n        : Long.ZERO;\n    return message;\n  },\n};\n\nfunction createBaseValidator(): Validator {\n  return {\n    address: new Uint8Array(),\n    pubKey: undefined,\n    votingPower: Long.ZERO,\n    proposerPriority: Long.ZERO,\n  };\n}\n\nexport const Validator = {\n  encode(\n    message: Validator,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.address.length !== 0) {\n      writer.uint32(10).bytes(message.address);\n    }\n    if (message.pubKey !== undefined) {\n      PublicKey.encode(message.pubKey, writer.uint32(18).fork()).ldelim();\n    }\n    if (!message.votingPower.isZero()) {\n      writer.uint32(24).int64(message.votingPower);\n    }\n    if (!message.proposerPriority.isZero()) {\n      writer.uint32(32).int64(message.proposerPriority);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Validator {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseValidator();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.address = reader.bytes();\n          break;\n        case 2:\n          message.pubKey = PublicKey.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.votingPower = reader.int64() as Long;\n          break;\n        case 4:\n          message.proposerPriority = reader.int64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Validator {\n    return {\n      address: isSet(object.address)\n        ? bytesFromBase64(object.address)\n        : new Uint8Array(),\n      pubKey: isSet(object.pubKey)\n        ? PublicKey.fromJSON(object.pubKey)\n        : undefined,\n      votingPower: isSet(object.votingPower)\n        ? Long.fromValue(object.votingPower)\n        : Long.ZERO,\n      proposerPriority: isSet(object.proposerPriority)\n        ? Long.fromValue(object.proposerPriority)\n        : Long.ZERO,\n    };\n  },\n\n  toJSON(message: Validator): unknown {\n    const obj: any = {};\n    message.address !== undefined &&\n      (obj.address = base64FromBytes(\n        message.address !== undefined ? message.address : new Uint8Array()\n      ));\n    message.pubKey !== undefined &&\n      (obj.pubKey = message.pubKey\n        ? PublicKey.toJSON(message.pubKey)\n        : undefined);\n    message.votingPower !== undefined &&\n      (obj.votingPower = (message.votingPower || Long.ZERO).toString());\n    message.proposerPriority !== undefined &&\n      (obj.proposerPriority = (\n        message.proposerPriority || Long.ZERO\n      ).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Validator>, I>>(\n    object: I\n  ): Validator {\n    const message = createBaseValidator();\n    message.address = object.address ?? new Uint8Array();\n    message.pubKey =\n      object.pubKey !== undefined && object.pubKey !== null\n        ? PublicKey.fromPartial(object.pubKey)\n        : undefined;\n    message.votingPower =\n      object.votingPower !== undefined && object.votingPower !== null\n        ? Long.fromValue(object.votingPower)\n        : Long.ZERO;\n    message.proposerPriority =\n      object.proposerPriority !== undefined && object.proposerPriority !== null\n        ? Long.fromValue(object.proposerPriority)\n        : Long.ZERO;\n    return message;\n  },\n};\n\nfunction createBaseSimpleValidator(): SimpleValidator {\n  return { pubKey: undefined, votingPower: Long.ZERO };\n}\n\nexport const SimpleValidator = {\n  encode(\n    message: SimpleValidator,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.pubKey !== undefined) {\n      PublicKey.encode(message.pubKey, writer.uint32(10).fork()).ldelim();\n    }\n    if (!message.votingPower.isZero()) {\n      writer.uint32(16).int64(message.votingPower);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): SimpleValidator {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSimpleValidator();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.pubKey = PublicKey.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.votingPower = reader.int64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SimpleValidator {\n    return {\n      pubKey: isSet(object.pubKey)\n        ? PublicKey.fromJSON(object.pubKey)\n        : undefined,\n      votingPower: isSet(object.votingPower)\n        ? Long.fromValue(object.votingPower)\n        : Long.ZERO,\n    };\n  },\n\n  toJSON(message: SimpleValidator): unknown {\n    const obj: any = {};\n    message.pubKey !== undefined &&\n      (obj.pubKey = message.pubKey\n        ? PublicKey.toJSON(message.pubKey)\n        : undefined);\n    message.votingPower !== undefined &&\n      (obj.votingPower = (message.votingPower || Long.ZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SimpleValidator>, I>>(\n    object: I\n  ): SimpleValidator {\n    const message = createBaseSimpleValidator();\n    message.pubKey =\n      object.pubKey !== undefined && object.pubKey !== null\n        ? PublicKey.fromPartial(object.pubKey)\n        : undefined;\n    message.votingPower =\n      object.votingPower !== undefined && object.votingPower !== null\n        ? Long.fromValue(object.votingPower)\n        : Long.ZERO;\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Proof } from \"../crypto/proof\";\nimport { Consensus } from \"../version/types\";\nimport { ValidatorSet } from \"./validator\";\nimport { Timestamp } from \"../../google/protobuf/timestamp\";\n\nexport const protobufPackage = \"tendermint.types\";\n\n/** BlockIdFlag indicates which BlcokID the signature is for */\nexport enum BlockIDFlag {\n  BLOCK_ID_FLAG_UNKNOWN = 0,\n  BLOCK_ID_FLAG_ABSENT = 1,\n  BLOCK_ID_FLAG_COMMIT = 2,\n  BLOCK_ID_FLAG_NIL = 3,\n  UNRECOGNIZED = -1,\n}\n\nexport function blockIDFlagFromJSON(object: any): BlockIDFlag {\n  switch (object) {\n    case 0:\n    case \"BLOCK_ID_FLAG_UNKNOWN\":\n      return BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN;\n    case 1:\n    case \"BLOCK_ID_FLAG_ABSENT\":\n      return BlockIDFlag.BLOCK_ID_FLAG_ABSENT;\n    case 2:\n    case \"BLOCK_ID_FLAG_COMMIT\":\n      return BlockIDFlag.BLOCK_ID_FLAG_COMMIT;\n    case 3:\n    case \"BLOCK_ID_FLAG_NIL\":\n      return BlockIDFlag.BLOCK_ID_FLAG_NIL;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return BlockIDFlag.UNRECOGNIZED;\n  }\n}\n\nexport function blockIDFlagToJSON(object: BlockIDFlag): string {\n  switch (object) {\n    case BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN:\n      return \"BLOCK_ID_FLAG_UNKNOWN\";\n    case BlockIDFlag.BLOCK_ID_FLAG_ABSENT:\n      return \"BLOCK_ID_FLAG_ABSENT\";\n    case BlockIDFlag.BLOCK_ID_FLAG_COMMIT:\n      return \"BLOCK_ID_FLAG_COMMIT\";\n    case BlockIDFlag.BLOCK_ID_FLAG_NIL:\n      return \"BLOCK_ID_FLAG_NIL\";\n    case BlockIDFlag.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n\n/** SignedMsgType is a type of signed message in the consensus. */\nexport enum SignedMsgType {\n  SIGNED_MSG_TYPE_UNKNOWN = 0,\n  /** SIGNED_MSG_TYPE_PREVOTE - Votes */\n  SIGNED_MSG_TYPE_PREVOTE = 1,\n  SIGNED_MSG_TYPE_PRECOMMIT = 2,\n  /** SIGNED_MSG_TYPE_PROPOSAL - Proposals */\n  SIGNED_MSG_TYPE_PROPOSAL = 32,\n  UNRECOGNIZED = -1,\n}\n\nexport function signedMsgTypeFromJSON(object: any): SignedMsgType {\n  switch (object) {\n    case 0:\n    case \"SIGNED_MSG_TYPE_UNKNOWN\":\n      return SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN;\n    case 1:\n    case \"SIGNED_MSG_TYPE_PREVOTE\":\n      return SignedMsgType.SIGNED_MSG_TYPE_PREVOTE;\n    case 2:\n    case \"SIGNED_MSG_TYPE_PRECOMMIT\":\n      return SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT;\n    case 32:\n    case \"SIGNED_MSG_TYPE_PROPOSAL\":\n      return SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return SignedMsgType.UNRECOGNIZED;\n  }\n}\n\nexport function signedMsgTypeToJSON(object: SignedMsgType): string {\n  switch (object) {\n    case SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN:\n      return \"SIGNED_MSG_TYPE_UNKNOWN\";\n    case SignedMsgType.SIGNED_MSG_TYPE_PREVOTE:\n      return \"SIGNED_MSG_TYPE_PREVOTE\";\n    case SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT:\n      return \"SIGNED_MSG_TYPE_PRECOMMIT\";\n    case SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL:\n      return \"SIGNED_MSG_TYPE_PROPOSAL\";\n    case SignedMsgType.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n\n/** PartsetHeader */\nexport interface PartSetHeader {\n  total: number;\n  hash: Uint8Array;\n}\n\nexport interface Part {\n  index: number;\n  bytes: Uint8Array;\n  proof?: Proof;\n}\n\n/** BlockID */\nexport interface BlockID {\n  hash: Uint8Array;\n  partSetHeader?: PartSetHeader;\n}\n\n/** Header defines the structure of a Tendermint block header. */\nexport interface Header {\n  /** basic block info */\n  version?: Consensus;\n  chainId: string;\n  height: Long;\n  time?: Date;\n  /** prev block info */\n  lastBlockId?: BlockID;\n  /** hashes of block data */\n  lastCommitHash: Uint8Array;\n  /** transactions */\n  dataHash: Uint8Array;\n  /** hashes from the app output from the prev block */\n  validatorsHash: Uint8Array;\n  /** validators for the next block */\n  nextValidatorsHash: Uint8Array;\n  /** consensus params for current block */\n  consensusHash: Uint8Array;\n  /** state after txs from the previous block */\n  appHash: Uint8Array;\n  /** root hash of all results from the txs from the previous block */\n  lastResultsHash: Uint8Array;\n  /** consensus info */\n  evidenceHash: Uint8Array;\n  /** original proposer of the block */\n  proposerAddress: Uint8Array;\n}\n\n/** Data contains the set of transactions included in the block */\nexport interface Data {\n  /**\n   * Txs that will be applied by state @ block.Height+1.\n   * NOTE: not all txs here are valid.  We're just agreeing on the order first.\n   * This means that block.AppHash does not include these txs.\n   */\n  txs: Uint8Array[];\n}\n\n/**\n * Vote represents a prevote, precommit, or commit vote from validators for\n * consensus.\n */\nexport interface Vote {\n  type: SignedMsgType;\n  height: Long;\n  round: number;\n  /** zero if vote is nil. */\n  blockId?: BlockID;\n  timestamp?: Date;\n  validatorAddress: Uint8Array;\n  validatorIndex: number;\n  signature: Uint8Array;\n}\n\n/**\n * Commit contains the evidence that a block was committed by a set of\n * validators.\n */\nexport interface Commit {\n  height: Long;\n  round: number;\n  blockId?: BlockID;\n  signatures: CommitSig[];\n}\n\n/** CommitSig is a part of the Vote included in a Commit. */\nexport interface CommitSig {\n  blockIdFlag: BlockIDFlag;\n  validatorAddress: Uint8Array;\n  timestamp?: Date;\n  signature: Uint8Array;\n}\n\nexport interface Proposal {\n  type: SignedMsgType;\n  height: Long;\n  round: number;\n  polRound: number;\n  blockId?: BlockID;\n  timestamp?: Date;\n  signature: Uint8Array;\n}\n\nexport interface SignedHeader {\n  header?: Header;\n  commit?: Commit;\n}\n\nexport interface LightBlock {\n  signedHeader?: SignedHeader;\n  validatorSet?: ValidatorSet;\n}\n\nexport interface BlockMeta {\n  blockId?: BlockID;\n  blockSize: Long;\n  header?: Header;\n  numTxs: Long;\n}\n\n/**\n * TxProof represents a Merkle proof of the presence of a transaction in the\n * Merkle tree.\n */\nexport interface TxProof {\n  rootHash: Uint8Array;\n  data: Uint8Array;\n  proof?: Proof;\n}\n\nfunction createBasePartSetHeader(): PartSetHeader {\n  return { total: 0, hash: new Uint8Array() };\n}\n\nexport const PartSetHeader = {\n  encode(\n    message: PartSetHeader,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.total !== 0) {\n      writer.uint32(8).uint32(message.total);\n    }\n    if (message.hash.length !== 0) {\n      writer.uint32(18).bytes(message.hash);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): PartSetHeader {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBasePartSetHeader();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.total = reader.uint32();\n          break;\n        case 2:\n          message.hash = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): PartSetHeader {\n    return {\n      total: isSet(object.total) ? Number(object.total) : 0,\n      hash: isSet(object.hash)\n        ? bytesFromBase64(object.hash)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: PartSetHeader): unknown {\n    const obj: any = {};\n    message.total !== undefined && (obj.total = Math.round(message.total));\n    message.hash !== undefined &&\n      (obj.hash = base64FromBytes(\n        message.hash !== undefined ? message.hash : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<PartSetHeader>, I>>(\n    object: I\n  ): PartSetHeader {\n    const message = createBasePartSetHeader();\n    message.total = object.total ?? 0;\n    message.hash = object.hash ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBasePart(): Part {\n  return { index: 0, bytes: new Uint8Array(), proof: undefined };\n}\n\nexport const Part = {\n  encode(message: Part, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (message.index !== 0) {\n      writer.uint32(8).uint32(message.index);\n    }\n    if (message.bytes.length !== 0) {\n      writer.uint32(18).bytes(message.bytes);\n    }\n    if (message.proof !== undefined) {\n      Proof.encode(message.proof, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Part {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBasePart();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.index = reader.uint32();\n          break;\n        case 2:\n          message.bytes = reader.bytes();\n          break;\n        case 3:\n          message.proof = Proof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Part {\n    return {\n      index: isSet(object.index) ? Number(object.index) : 0,\n      bytes: isSet(object.bytes)\n        ? bytesFromBase64(object.bytes)\n        : new Uint8Array(),\n      proof: isSet(object.proof) ? Proof.fromJSON(object.proof) : undefined,\n    };\n  },\n\n  toJSON(message: Part): unknown {\n    const obj: any = {};\n    message.index !== undefined && (obj.index = Math.round(message.index));\n    message.bytes !== undefined &&\n      (obj.bytes = base64FromBytes(\n        message.bytes !== undefined ? message.bytes : new Uint8Array()\n      ));\n    message.proof !== undefined &&\n      (obj.proof = message.proof ? Proof.toJSON(message.proof) : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Part>, I>>(object: I): Part {\n    const message = createBasePart();\n    message.index = object.index ?? 0;\n    message.bytes = object.bytes ?? new Uint8Array();\n    message.proof =\n      object.proof !== undefined && object.proof !== null\n        ? Proof.fromPartial(object.proof)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseBlockID(): BlockID {\n  return { hash: new Uint8Array(), partSetHeader: undefined };\n}\n\nexport const BlockID = {\n  encode(\n    message: BlockID,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.hash.length !== 0) {\n      writer.uint32(10).bytes(message.hash);\n    }\n    if (message.partSetHeader !== undefined) {\n      PartSetHeader.encode(\n        message.partSetHeader,\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): BlockID {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseBlockID();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.hash = reader.bytes();\n          break;\n        case 2:\n          message.partSetHeader = PartSetHeader.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): BlockID {\n    return {\n      hash: isSet(object.hash)\n        ? bytesFromBase64(object.hash)\n        : new Uint8Array(),\n      partSetHeader: isSet(object.partSetHeader)\n        ? PartSetHeader.fromJSON(object.partSetHeader)\n        : undefined,\n    };\n  },\n\n  toJSON(message: BlockID): unknown {\n    const obj: any = {};\n    message.hash !== undefined &&\n      (obj.hash = base64FromBytes(\n        message.hash !== undefined ? message.hash : new Uint8Array()\n      ));\n    message.partSetHeader !== undefined &&\n      (obj.partSetHeader = message.partSetHeader\n        ? PartSetHeader.toJSON(message.partSetHeader)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<BlockID>, I>>(object: I): BlockID {\n    const message = createBaseBlockID();\n    message.hash = object.hash ?? new Uint8Array();\n    message.partSetHeader =\n      object.partSetHeader !== undefined && object.partSetHeader !== null\n        ? PartSetHeader.fromPartial(object.partSetHeader)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseHeader(): Header {\n  return {\n    version: undefined,\n    chainId: \"\",\n    height: Long.ZERO,\n    time: undefined,\n    lastBlockId: undefined,\n    lastCommitHash: new Uint8Array(),\n    dataHash: new Uint8Array(),\n    validatorsHash: new Uint8Array(),\n    nextValidatorsHash: new Uint8Array(),\n    consensusHash: new Uint8Array(),\n    appHash: new Uint8Array(),\n    lastResultsHash: new Uint8Array(),\n    evidenceHash: new Uint8Array(),\n    proposerAddress: new Uint8Array(),\n  };\n}\n\nexport const Header = {\n  encode(\n    message: Header,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.version !== undefined) {\n      Consensus.encode(message.version, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.chainId !== \"\") {\n      writer.uint32(18).string(message.chainId);\n    }\n    if (!message.height.isZero()) {\n      writer.uint32(24).int64(message.height);\n    }\n    if (message.time !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.time),\n        writer.uint32(34).fork()\n      ).ldelim();\n    }\n    if (message.lastBlockId !== undefined) {\n      BlockID.encode(message.lastBlockId, writer.uint32(42).fork()).ldelim();\n    }\n    if (message.lastCommitHash.length !== 0) {\n      writer.uint32(50).bytes(message.lastCommitHash);\n    }\n    if (message.dataHash.length !== 0) {\n      writer.uint32(58).bytes(message.dataHash);\n    }\n    if (message.validatorsHash.length !== 0) {\n      writer.uint32(66).bytes(message.validatorsHash);\n    }\n    if (message.nextValidatorsHash.length !== 0) {\n      writer.uint32(74).bytes(message.nextValidatorsHash);\n    }\n    if (message.consensusHash.length !== 0) {\n      writer.uint32(82).bytes(message.consensusHash);\n    }\n    if (message.appHash.length !== 0) {\n      writer.uint32(90).bytes(message.appHash);\n    }\n    if (message.lastResultsHash.length !== 0) {\n      writer.uint32(98).bytes(message.lastResultsHash);\n    }\n    if (message.evidenceHash.length !== 0) {\n      writer.uint32(106).bytes(message.evidenceHash);\n    }\n    if (message.proposerAddress.length !== 0) {\n      writer.uint32(114).bytes(message.proposerAddress);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Header {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseHeader();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.version = Consensus.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.chainId = reader.string();\n          break;\n        case 3:\n          message.height = reader.int64() as Long;\n          break;\n        case 4:\n          message.time = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        case 5:\n          message.lastBlockId = BlockID.decode(reader, reader.uint32());\n          break;\n        case 6:\n          message.lastCommitHash = reader.bytes();\n          break;\n        case 7:\n          message.dataHash = reader.bytes();\n          break;\n        case 8:\n          message.validatorsHash = reader.bytes();\n          break;\n        case 9:\n          message.nextValidatorsHash = reader.bytes();\n          break;\n        case 10:\n          message.consensusHash = reader.bytes();\n          break;\n        case 11:\n          message.appHash = reader.bytes();\n          break;\n        case 12:\n          message.lastResultsHash = reader.bytes();\n          break;\n        case 13:\n          message.evidenceHash = reader.bytes();\n          break;\n        case 14:\n          message.proposerAddress = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Header {\n    return {\n      version: isSet(object.version)\n        ? Consensus.fromJSON(object.version)\n        : undefined,\n      chainId: isSet(object.chainId) ? String(object.chainId) : \"\",\n      height: isSet(object.height) ? Long.fromValue(object.height) : Long.ZERO,\n      time: isSet(object.time) ? fromJsonTimestamp(object.time) : undefined,\n      lastBlockId: isSet(object.lastBlockId)\n        ? BlockID.fromJSON(object.lastBlockId)\n        : undefined,\n      lastCommitHash: isSet(object.lastCommitHash)\n        ? bytesFromBase64(object.lastCommitHash)\n        : new Uint8Array(),\n      dataHash: isSet(object.dataHash)\n        ? bytesFromBase64(object.dataHash)\n        : new Uint8Array(),\n      validatorsHash: isSet(object.validatorsHash)\n        ? bytesFromBase64(object.validatorsHash)\n        : new Uint8Array(),\n      nextValidatorsHash: isSet(object.nextValidatorsHash)\n        ? bytesFromBase64(object.nextValidatorsHash)\n        : new Uint8Array(),\n      consensusHash: isSet(object.consensusHash)\n        ? bytesFromBase64(object.consensusHash)\n        : new Uint8Array(),\n      appHash: isSet(object.appHash)\n        ? bytesFromBase64(object.appHash)\n        : new Uint8Array(),\n      lastResultsHash: isSet(object.lastResultsHash)\n        ? bytesFromBase64(object.lastResultsHash)\n        : new Uint8Array(),\n      evidenceHash: isSet(object.evidenceHash)\n        ? bytesFromBase64(object.evidenceHash)\n        : new Uint8Array(),\n      proposerAddress: isSet(object.proposerAddress)\n        ? bytesFromBase64(object.proposerAddress)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: Header): unknown {\n    const obj: any = {};\n    message.version !== undefined &&\n      (obj.version = message.version\n        ? Consensus.toJSON(message.version)\n        : undefined);\n    message.chainId !== undefined && (obj.chainId = message.chainId);\n    message.height !== undefined &&\n      (obj.height = (message.height || Long.ZERO).toString());\n    message.time !== undefined && (obj.time = message.time.toISOString());\n    message.lastBlockId !== undefined &&\n      (obj.lastBlockId = message.lastBlockId\n        ? BlockID.toJSON(message.lastBlockId)\n        : undefined);\n    message.lastCommitHash !== undefined &&\n      (obj.lastCommitHash = base64FromBytes(\n        message.lastCommitHash !== undefined\n          ? message.lastCommitHash\n          : new Uint8Array()\n      ));\n    message.dataHash !== undefined &&\n      (obj.dataHash = base64FromBytes(\n        message.dataHash !== undefined ? message.dataHash : new Uint8Array()\n      ));\n    message.validatorsHash !== undefined &&\n      (obj.validatorsHash = base64FromBytes(\n        message.validatorsHash !== undefined\n          ? message.validatorsHash\n          : new Uint8Array()\n      ));\n    message.nextValidatorsHash !== undefined &&\n      (obj.nextValidatorsHash = base64FromBytes(\n        message.nextValidatorsHash !== undefined\n          ? message.nextValidatorsHash\n          : new Uint8Array()\n      ));\n    message.consensusHash !== undefined &&\n      (obj.consensusHash = base64FromBytes(\n        message.consensusHash !== undefined\n          ? message.consensusHash\n          : new Uint8Array()\n      ));\n    message.appHash !== undefined &&\n      (obj.appHash = base64FromBytes(\n        message.appHash !== undefined ? message.appHash : new Uint8Array()\n      ));\n    message.lastResultsHash !== undefined &&\n      (obj.lastResultsHash = base64FromBytes(\n        message.lastResultsHash !== undefined\n          ? message.lastResultsHash\n          : new Uint8Array()\n      ));\n    message.evidenceHash !== undefined &&\n      (obj.evidenceHash = base64FromBytes(\n        message.evidenceHash !== undefined\n          ? message.evidenceHash\n          : new Uint8Array()\n      ));\n    message.proposerAddress !== undefined &&\n      (obj.proposerAddress = base64FromBytes(\n        message.proposerAddress !== undefined\n          ? message.proposerAddress\n          : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Header>, I>>(object: I): Header {\n    const message = createBaseHeader();\n    message.version =\n      object.version !== undefined && object.version !== null\n        ? Consensus.fromPartial(object.version)\n        : undefined;\n    message.chainId = object.chainId ?? \"\";\n    message.height =\n      object.height !== undefined && object.height !== null\n        ? Long.fromValue(object.height)\n        : Long.ZERO;\n    message.time = object.time ?? undefined;\n    message.lastBlockId =\n      object.lastBlockId !== undefined && object.lastBlockId !== null\n        ? BlockID.fromPartial(object.lastBlockId)\n        : undefined;\n    message.lastCommitHash = object.lastCommitHash ?? new Uint8Array();\n    message.dataHash = object.dataHash ?? new Uint8Array();\n    message.validatorsHash = object.validatorsHash ?? new Uint8Array();\n    message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();\n    message.consensusHash = object.consensusHash ?? new Uint8Array();\n    message.appHash = object.appHash ?? new Uint8Array();\n    message.lastResultsHash = object.lastResultsHash ?? new Uint8Array();\n    message.evidenceHash = object.evidenceHash ?? new Uint8Array();\n    message.proposerAddress = object.proposerAddress ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBaseData(): Data {\n  return { txs: [] };\n}\n\nexport const Data = {\n  encode(message: Data, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    for (const v of message.txs) {\n      writer.uint32(10).bytes(v!);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Data {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseData();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.txs.push(reader.bytes());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Data {\n    return {\n      txs: Array.isArray(object?.txs)\n        ? object.txs.map((e: any) => bytesFromBase64(e))\n        : [],\n    };\n  },\n\n  toJSON(message: Data): unknown {\n    const obj: any = {};\n    if (message.txs) {\n      obj.txs = message.txs.map((e) =>\n        base64FromBytes(e !== undefined ? e : new Uint8Array())\n      );\n    } else {\n      obj.txs = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Data>, I>>(object: I): Data {\n    const message = createBaseData();\n    message.txs = object.txs?.map((e) => e) || [];\n    return message;\n  },\n};\n\nfunction createBaseVote(): Vote {\n  return {\n    type: 0,\n    height: Long.ZERO,\n    round: 0,\n    blockId: undefined,\n    timestamp: undefined,\n    validatorAddress: new Uint8Array(),\n    validatorIndex: 0,\n    signature: new Uint8Array(),\n  };\n}\n\nexport const Vote = {\n  encode(message: Vote, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (message.type !== 0) {\n      writer.uint32(8).int32(message.type);\n    }\n    if (!message.height.isZero()) {\n      writer.uint32(16).int64(message.height);\n    }\n    if (message.round !== 0) {\n      writer.uint32(24).int32(message.round);\n    }\n    if (message.blockId !== undefined) {\n      BlockID.encode(message.blockId, writer.uint32(34).fork()).ldelim();\n    }\n    if (message.timestamp !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.timestamp),\n        writer.uint32(42).fork()\n      ).ldelim();\n    }\n    if (message.validatorAddress.length !== 0) {\n      writer.uint32(50).bytes(message.validatorAddress);\n    }\n    if (message.validatorIndex !== 0) {\n      writer.uint32(56).int32(message.validatorIndex);\n    }\n    if (message.signature.length !== 0) {\n      writer.uint32(66).bytes(message.signature);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Vote {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseVote();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.type = reader.int32() as any;\n          break;\n        case 2:\n          message.height = reader.int64() as Long;\n          break;\n        case 3:\n          message.round = reader.int32();\n          break;\n        case 4:\n          message.blockId = BlockID.decode(reader, reader.uint32());\n          break;\n        case 5:\n          message.timestamp = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        case 6:\n          message.validatorAddress = reader.bytes();\n          break;\n        case 7:\n          message.validatorIndex = reader.int32();\n          break;\n        case 8:\n          message.signature = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Vote {\n    return {\n      type: isSet(object.type) ? signedMsgTypeFromJSON(object.type) : 0,\n      height: isSet(object.height) ? Long.fromValue(object.height) : Long.ZERO,\n      round: isSet(object.round) ? Number(object.round) : 0,\n      blockId: isSet(object.blockId)\n        ? BlockID.fromJSON(object.blockId)\n        : undefined,\n      timestamp: isSet(object.timestamp)\n        ? fromJsonTimestamp(object.timestamp)\n        : undefined,\n      validatorAddress: isSet(object.validatorAddress)\n        ? bytesFromBase64(object.validatorAddress)\n        : new Uint8Array(),\n      validatorIndex: isSet(object.validatorIndex)\n        ? Number(object.validatorIndex)\n        : 0,\n      signature: isSet(object.signature)\n        ? bytesFromBase64(object.signature)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: Vote): unknown {\n    const obj: any = {};\n    message.type !== undefined &&\n      (obj.type = signedMsgTypeToJSON(message.type));\n    message.height !== undefined &&\n      (obj.height = (message.height || Long.ZERO).toString());\n    message.round !== undefined && (obj.round = Math.round(message.round));\n    message.blockId !== undefined &&\n      (obj.blockId = message.blockId\n        ? BlockID.toJSON(message.blockId)\n        : undefined);\n    message.timestamp !== undefined &&\n      (obj.timestamp = message.timestamp.toISOString());\n    message.validatorAddress !== undefined &&\n      (obj.validatorAddress = base64FromBytes(\n        message.validatorAddress !== undefined\n          ? message.validatorAddress\n          : new Uint8Array()\n      ));\n    message.validatorIndex !== undefined &&\n      (obj.validatorIndex = Math.round(message.validatorIndex));\n    message.signature !== undefined &&\n      (obj.signature = base64FromBytes(\n        message.signature !== undefined ? message.signature : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Vote>, I>>(object: I): Vote {\n    const message = createBaseVote();\n    message.type = object.type ?? 0;\n    message.height =\n      object.height !== undefined && object.height !== null\n        ? Long.fromValue(object.height)\n        : Long.ZERO;\n    message.round = object.round ?? 0;\n    message.blockId =\n      object.blockId !== undefined && object.blockId !== null\n        ? BlockID.fromPartial(object.blockId)\n        : undefined;\n    message.timestamp = object.timestamp ?? undefined;\n    message.validatorAddress = object.validatorAddress ?? new Uint8Array();\n    message.validatorIndex = object.validatorIndex ?? 0;\n    message.signature = object.signature ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBaseCommit(): Commit {\n  return { height: Long.ZERO, round: 0, blockId: undefined, signatures: [] };\n}\n\nexport const Commit = {\n  encode(\n    message: Commit,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.height.isZero()) {\n      writer.uint32(8).int64(message.height);\n    }\n    if (message.round !== 0) {\n      writer.uint32(16).int32(message.round);\n    }\n    if (message.blockId !== undefined) {\n      BlockID.encode(message.blockId, writer.uint32(26).fork()).ldelim();\n    }\n    for (const v of message.signatures) {\n      CommitSig.encode(v!, writer.uint32(34).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Commit {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseCommit();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.height = reader.int64() as Long;\n          break;\n        case 2:\n          message.round = reader.int32();\n          break;\n        case 3:\n          message.blockId = BlockID.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.signatures.push(CommitSig.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Commit {\n    return {\n      height: isSet(object.height) ? Long.fromValue(object.height) : Long.ZERO,\n      round: isSet(object.round) ? Number(object.round) : 0,\n      blockId: isSet(object.blockId)\n        ? BlockID.fromJSON(object.blockId)\n        : undefined,\n      signatures: Array.isArray(object?.signatures)\n        ? object.signatures.map((e: any) => CommitSig.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: Commit): unknown {\n    const obj: any = {};\n    message.height !== undefined &&\n      (obj.height = (message.height || Long.ZERO).toString());\n    message.round !== undefined && (obj.round = Math.round(message.round));\n    message.blockId !== undefined &&\n      (obj.blockId = message.blockId\n        ? BlockID.toJSON(message.blockId)\n        : undefined);\n    if (message.signatures) {\n      obj.signatures = message.signatures.map((e) =>\n        e ? CommitSig.toJSON(e) : undefined\n      );\n    } else {\n      obj.signatures = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Commit>, I>>(object: I): Commit {\n    const message = createBaseCommit();\n    message.height =\n      object.height !== undefined && object.height !== null\n        ? Long.fromValue(object.height)\n        : Long.ZERO;\n    message.round = object.round ?? 0;\n    message.blockId =\n      object.blockId !== undefined && object.blockId !== null\n        ? BlockID.fromPartial(object.blockId)\n        : undefined;\n    message.signatures =\n      object.signatures?.map((e) => CommitSig.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseCommitSig(): CommitSig {\n  return {\n    blockIdFlag: 0,\n    validatorAddress: new Uint8Array(),\n    timestamp: undefined,\n    signature: new Uint8Array(),\n  };\n}\n\nexport const CommitSig = {\n  encode(\n    message: CommitSig,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.blockIdFlag !== 0) {\n      writer.uint32(8).int32(message.blockIdFlag);\n    }\n    if (message.validatorAddress.length !== 0) {\n      writer.uint32(18).bytes(message.validatorAddress);\n    }\n    if (message.timestamp !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.timestamp),\n        writer.uint32(26).fork()\n      ).ldelim();\n    }\n    if (message.signature.length !== 0) {\n      writer.uint32(34).bytes(message.signature);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): CommitSig {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseCommitSig();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.blockIdFlag = reader.int32() as any;\n          break;\n        case 2:\n          message.validatorAddress = reader.bytes();\n          break;\n        case 3:\n          message.timestamp = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        case 4:\n          message.signature = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): CommitSig {\n    return {\n      blockIdFlag: isSet(object.blockIdFlag)\n        ? blockIDFlagFromJSON(object.blockIdFlag)\n        : 0,\n      validatorAddress: isSet(object.validatorAddress)\n        ? bytesFromBase64(object.validatorAddress)\n        : new Uint8Array(),\n      timestamp: isSet(object.timestamp)\n        ? fromJsonTimestamp(object.timestamp)\n        : undefined,\n      signature: isSet(object.signature)\n        ? bytesFromBase64(object.signature)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: CommitSig): unknown {\n    const obj: any = {};\n    message.blockIdFlag !== undefined &&\n      (obj.blockIdFlag = blockIDFlagToJSON(message.blockIdFlag));\n    message.validatorAddress !== undefined &&\n      (obj.validatorAddress = base64FromBytes(\n        message.validatorAddress !== undefined\n          ? message.validatorAddress\n          : new Uint8Array()\n      ));\n    message.timestamp !== undefined &&\n      (obj.timestamp = message.timestamp.toISOString());\n    message.signature !== undefined &&\n      (obj.signature = base64FromBytes(\n        message.signature !== undefined ? message.signature : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<CommitSig>, I>>(\n    object: I\n  ): CommitSig {\n    const message = createBaseCommitSig();\n    message.blockIdFlag = object.blockIdFlag ?? 0;\n    message.validatorAddress = object.validatorAddress ?? new Uint8Array();\n    message.timestamp = object.timestamp ?? undefined;\n    message.signature = object.signature ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBaseProposal(): Proposal {\n  return {\n    type: 0,\n    height: Long.ZERO,\n    round: 0,\n    polRound: 0,\n    blockId: undefined,\n    timestamp: undefined,\n    signature: new Uint8Array(),\n  };\n}\n\nexport const Proposal = {\n  encode(\n    message: Proposal,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.type !== 0) {\n      writer.uint32(8).int32(message.type);\n    }\n    if (!message.height.isZero()) {\n      writer.uint32(16).int64(message.height);\n    }\n    if (message.round !== 0) {\n      writer.uint32(24).int32(message.round);\n    }\n    if (message.polRound !== 0) {\n      writer.uint32(32).int32(message.polRound);\n    }\n    if (message.blockId !== undefined) {\n      BlockID.encode(message.blockId, writer.uint32(42).fork()).ldelim();\n    }\n    if (message.timestamp !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.timestamp),\n        writer.uint32(50).fork()\n      ).ldelim();\n    }\n    if (message.signature.length !== 0) {\n      writer.uint32(58).bytes(message.signature);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Proposal {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseProposal();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.type = reader.int32() as any;\n          break;\n        case 2:\n          message.height = reader.int64() as Long;\n          break;\n        case 3:\n          message.round = reader.int32();\n          break;\n        case 4:\n          message.polRound = reader.int32();\n          break;\n        case 5:\n          message.blockId = BlockID.decode(reader, reader.uint32());\n          break;\n        case 6:\n          message.timestamp = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        case 7:\n          message.signature = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Proposal {\n    return {\n      type: isSet(object.type) ? signedMsgTypeFromJSON(object.type) : 0,\n      height: isSet(object.height) ? Long.fromValue(object.height) : Long.ZERO,\n      round: isSet(object.round) ? Number(object.round) : 0,\n      polRound: isSet(object.polRound) ? Number(object.polRound) : 0,\n      blockId: isSet(object.blockId)\n        ? BlockID.fromJSON(object.blockId)\n        : undefined,\n      timestamp: isSet(object.timestamp)\n        ? fromJsonTimestamp(object.timestamp)\n        : undefined,\n      signature: isSet(object.signature)\n        ? bytesFromBase64(object.signature)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: Proposal): unknown {\n    const obj: any = {};\n    message.type !== undefined &&\n      (obj.type = signedMsgTypeToJSON(message.type));\n    message.height !== undefined &&\n      (obj.height = (message.height || Long.ZERO).toString());\n    message.round !== undefined && (obj.round = Math.round(message.round));\n    message.polRound !== undefined &&\n      (obj.polRound = Math.round(message.polRound));\n    message.blockId !== undefined &&\n      (obj.blockId = message.blockId\n        ? BlockID.toJSON(message.blockId)\n        : undefined);\n    message.timestamp !== undefined &&\n      (obj.timestamp = message.timestamp.toISOString());\n    message.signature !== undefined &&\n      (obj.signature = base64FromBytes(\n        message.signature !== undefined ? message.signature : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Proposal>, I>>(object: I): Proposal {\n    const message = createBaseProposal();\n    message.type = object.type ?? 0;\n    message.height =\n      object.height !== undefined && object.height !== null\n        ? Long.fromValue(object.height)\n        : Long.ZERO;\n    message.round = object.round ?? 0;\n    message.polRound = object.polRound ?? 0;\n    message.blockId =\n      object.blockId !== undefined && object.blockId !== null\n        ? BlockID.fromPartial(object.blockId)\n        : undefined;\n    message.timestamp = object.timestamp ?? undefined;\n    message.signature = object.signature ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBaseSignedHeader(): SignedHeader {\n  return { header: undefined, commit: undefined };\n}\n\nexport const SignedHeader = {\n  encode(\n    message: SignedHeader,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.header !== undefined) {\n      Header.encode(message.header, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.commit !== undefined) {\n      Commit.encode(message.commit, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): SignedHeader {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSignedHeader();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.header = Header.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.commit = Commit.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SignedHeader {\n    return {\n      header: isSet(object.header) ? Header.fromJSON(object.header) : undefined,\n      commit: isSet(object.commit) ? Commit.fromJSON(object.commit) : undefined,\n    };\n  },\n\n  toJSON(message: SignedHeader): unknown {\n    const obj: any = {};\n    message.header !== undefined &&\n      (obj.header = message.header ? Header.toJSON(message.header) : undefined);\n    message.commit !== undefined &&\n      (obj.commit = message.commit ? Commit.toJSON(message.commit) : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SignedHeader>, I>>(\n    object: I\n  ): SignedHeader {\n    const message = createBaseSignedHeader();\n    message.header =\n      object.header !== undefined && object.header !== null\n        ? Header.fromPartial(object.header)\n        : undefined;\n    message.commit =\n      object.commit !== undefined && object.commit !== null\n        ? Commit.fromPartial(object.commit)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseLightBlock(): LightBlock {\n  return { signedHeader: undefined, validatorSet: undefined };\n}\n\nexport const LightBlock = {\n  encode(\n    message: LightBlock,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.signedHeader !== undefined) {\n      SignedHeader.encode(\n        message.signedHeader,\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    if (message.validatorSet !== undefined) {\n      ValidatorSet.encode(\n        message.validatorSet,\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): LightBlock {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseLightBlock();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.signedHeader = SignedHeader.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.validatorSet = ValidatorSet.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): LightBlock {\n    return {\n      signedHeader: isSet(object.signedHeader)\n        ? SignedHeader.fromJSON(object.signedHeader)\n        : undefined,\n      validatorSet: isSet(object.validatorSet)\n        ? ValidatorSet.fromJSON(object.validatorSet)\n        : undefined,\n    };\n  },\n\n  toJSON(message: LightBlock): unknown {\n    const obj: any = {};\n    message.signedHeader !== undefined &&\n      (obj.signedHeader = message.signedHeader\n        ? SignedHeader.toJSON(message.signedHeader)\n        : undefined);\n    message.validatorSet !== undefined &&\n      (obj.validatorSet = message.validatorSet\n        ? ValidatorSet.toJSON(message.validatorSet)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<LightBlock>, I>>(\n    object: I\n  ): LightBlock {\n    const message = createBaseLightBlock();\n    message.signedHeader =\n      object.signedHeader !== undefined && object.signedHeader !== null\n        ? SignedHeader.fromPartial(object.signedHeader)\n        : undefined;\n    message.validatorSet =\n      object.validatorSet !== undefined && object.validatorSet !== null\n        ? ValidatorSet.fromPartial(object.validatorSet)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseBlockMeta(): BlockMeta {\n  return {\n    blockId: undefined,\n    blockSize: Long.ZERO,\n    header: undefined,\n    numTxs: Long.ZERO,\n  };\n}\n\nexport const BlockMeta = {\n  encode(\n    message: BlockMeta,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.blockId !== undefined) {\n      BlockID.encode(message.blockId, writer.uint32(10).fork()).ldelim();\n    }\n    if (!message.blockSize.isZero()) {\n      writer.uint32(16).int64(message.blockSize);\n    }\n    if (message.header !== undefined) {\n      Header.encode(message.header, writer.uint32(26).fork()).ldelim();\n    }\n    if (!message.numTxs.isZero()) {\n      writer.uint32(32).int64(message.numTxs);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): BlockMeta {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseBlockMeta();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.blockId = BlockID.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.blockSize = reader.int64() as Long;\n          break;\n        case 3:\n          message.header = Header.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.numTxs = reader.int64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): BlockMeta {\n    return {\n      blockId: isSet(object.blockId)\n        ? BlockID.fromJSON(object.blockId)\n        : undefined,\n      blockSize: isSet(object.blockSize)\n        ? Long.fromValue(object.blockSize)\n        : Long.ZERO,\n      header: isSet(object.header) ? Header.fromJSON(object.header) : undefined,\n      numTxs: isSet(object.numTxs) ? Long.fromValue(object.numTxs) : Long.ZERO,\n    };\n  },\n\n  toJSON(message: BlockMeta): unknown {\n    const obj: any = {};\n    message.blockId !== undefined &&\n      (obj.blockId = message.blockId\n        ? BlockID.toJSON(message.blockId)\n        : undefined);\n    message.blockSize !== undefined &&\n      (obj.blockSize = (message.blockSize || Long.ZERO).toString());\n    message.header !== undefined &&\n      (obj.header = message.header ? Header.toJSON(message.header) : undefined);\n    message.numTxs !== undefined &&\n      (obj.numTxs = (message.numTxs || Long.ZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<BlockMeta>, I>>(\n    object: I\n  ): BlockMeta {\n    const message = createBaseBlockMeta();\n    message.blockId =\n      object.blockId !== undefined && object.blockId !== null\n        ? BlockID.fromPartial(object.blockId)\n        : undefined;\n    message.blockSize =\n      object.blockSize !== undefined && object.blockSize !== null\n        ? Long.fromValue(object.blockSize)\n        : Long.ZERO;\n    message.header =\n      object.header !== undefined && object.header !== null\n        ? Header.fromPartial(object.header)\n        : undefined;\n    message.numTxs =\n      object.numTxs !== undefined && object.numTxs !== null\n        ? Long.fromValue(object.numTxs)\n        : Long.ZERO;\n    return message;\n  },\n};\n\nfunction createBaseTxProof(): TxProof {\n  return {\n    rootHash: new Uint8Array(),\n    data: new Uint8Array(),\n    proof: undefined,\n  };\n}\n\nexport const TxProof = {\n  encode(\n    message: TxProof,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.rootHash.length !== 0) {\n      writer.uint32(10).bytes(message.rootHash);\n    }\n    if (message.data.length !== 0) {\n      writer.uint32(18).bytes(message.data);\n    }\n    if (message.proof !== undefined) {\n      Proof.encode(message.proof, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): TxProof {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTxProof();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.rootHash = reader.bytes();\n          break;\n        case 2:\n          message.data = reader.bytes();\n          break;\n        case 3:\n          message.proof = Proof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): TxProof {\n    return {\n      rootHash: isSet(object.rootHash)\n        ? bytesFromBase64(object.rootHash)\n        : new Uint8Array(),\n      data: isSet(object.data)\n        ? bytesFromBase64(object.data)\n        : new Uint8Array(),\n      proof: isSet(object.proof) ? Proof.fromJSON(object.proof) : undefined,\n    };\n  },\n\n  toJSON(message: TxProof): unknown {\n    const obj: any = {};\n    message.rootHash !== undefined &&\n      (obj.rootHash = base64FromBytes(\n        message.rootHash !== undefined ? message.rootHash : new Uint8Array()\n      ));\n    message.data !== undefined &&\n      (obj.data = base64FromBytes(\n        message.data !== undefined ? message.data : new Uint8Array()\n      ));\n    message.proof !== undefined &&\n      (obj.proof = message.proof ? Proof.toJSON(message.proof) : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<TxProof>, I>>(object: I): TxProof {\n    const message = createBaseTxProof();\n    message.rootHash = object.rootHash ?? new Uint8Array();\n    message.data = object.data ?? new Uint8Array();\n    message.proof =\n      object.proof !== undefined && object.proof !== null\n        ? Proof.fromPartial(object.proof)\n        : undefined;\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nfunction toTimestamp(date: Date): Timestamp {\n  const seconds = numberToLong(date.getTime() / 1_000);\n  const nanos = (date.getTime() % 1_000) * 1_000_000;\n  return { seconds, nanos };\n}\n\nfunction fromTimestamp(t: Timestamp): Date {\n  let millis = t.seconds.toNumber() * 1_000;\n  millis += t.nanos / 1_000_000;\n  return new Date(millis);\n}\n\nfunction fromJsonTimestamp(o: any): Date {\n  if (o instanceof Date) {\n    return o;\n  } else if (typeof o === \"string\") {\n    return new Date(o);\n  } else {\n    return fromTimestamp(Timestamp.fromJSON(o));\n  }\n}\n\nfunction numberToLong(number: number) {\n  return Long.fromNumber(number);\n}\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Header } from \"../../../tendermint/types/types\";\nimport { Any } from \"../../../google/protobuf/any\";\nimport { Duration } from \"../../../google/protobuf/duration\";\nimport { Coin } from \"../../base/v1beta1/coin\";\nimport { Timestamp } from \"../../../google/protobuf/timestamp\";\n\nexport const protobufPackage = \"cosmos.staking.v1beta1\";\n\n/** BondStatus is the status of a validator. */\nexport enum BondStatus {\n  /** BOND_STATUS_UNSPECIFIED - UNSPECIFIED defines an invalid validator status. */\n  BOND_STATUS_UNSPECIFIED = 0,\n  /** BOND_STATUS_UNBONDED - UNBONDED defines a validator that is not bonded. */\n  BOND_STATUS_UNBONDED = 1,\n  /** BOND_STATUS_UNBONDING - UNBONDING defines a validator that is unbonding. */\n  BOND_STATUS_UNBONDING = 2,\n  /** BOND_STATUS_BONDED - BONDED defines a validator that is bonded. */\n  BOND_STATUS_BONDED = 3,\n  UNRECOGNIZED = -1,\n}\n\nexport function bondStatusFromJSON(object: any): BondStatus {\n  switch (object) {\n    case 0:\n    case \"BOND_STATUS_UNSPECIFIED\":\n      return BondStatus.BOND_STATUS_UNSPECIFIED;\n    case 1:\n    case \"BOND_STATUS_UNBONDED\":\n      return BondStatus.BOND_STATUS_UNBONDED;\n    case 2:\n    case \"BOND_STATUS_UNBONDING\":\n      return BondStatus.BOND_STATUS_UNBONDING;\n    case 3:\n    case \"BOND_STATUS_BONDED\":\n      return BondStatus.BOND_STATUS_BONDED;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return BondStatus.UNRECOGNIZED;\n  }\n}\n\nexport function bondStatusToJSON(object: BondStatus): string {\n  switch (object) {\n    case BondStatus.BOND_STATUS_UNSPECIFIED:\n      return \"BOND_STATUS_UNSPECIFIED\";\n    case BondStatus.BOND_STATUS_UNBONDED:\n      return \"BOND_STATUS_UNBONDED\";\n    case BondStatus.BOND_STATUS_UNBONDING:\n      return \"BOND_STATUS_UNBONDING\";\n    case BondStatus.BOND_STATUS_BONDED:\n      return \"BOND_STATUS_BONDED\";\n    case BondStatus.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n\n/**\n * HistoricalInfo contains header and validator information for a given block.\n * It is stored as part of staking module's state, which persists the `n` most\n * recent HistoricalInfo\n * (`n` is set by the staking module's `historical_entries` parameter).\n */\nexport interface HistoricalInfo {\n  header?: Header;\n  valset: Validator[];\n}\n\n/**\n * CommissionRates defines the initial commission rates to be used for creating\n * a validator.\n */\nexport interface CommissionRates {\n  /** rate is the commission rate charged to delegators, as a fraction. */\n  rate: string;\n  /** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */\n  maxRate: string;\n  /** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */\n  maxChangeRate: string;\n}\n\n/** Commission defines commission parameters for a given validator. */\nexport interface Commission {\n  /** commission_rates defines the initial commission rates to be used for creating a validator. */\n  commissionRates?: CommissionRates;\n  /** update_time is the last time the commission rate was changed. */\n  updateTime?: Date;\n}\n\n/** Description defines a validator description. */\nexport interface Description {\n  /** moniker defines a human-readable name for the validator. */\n  moniker: string;\n  /** identity defines an optional identity signature (ex. UPort or Keybase). */\n  identity: string;\n  /** website defines an optional website link. */\n  website: string;\n  /** security_contact defines an optional email for security contact. */\n  securityContact: string;\n  /** details define other optional details. */\n  details: string;\n}\n\n/**\n * Validator defines a validator, together with the total amount of the\n * Validator's bond shares and their exchange rate to coins. Slashing results in\n * a decrease in the exchange rate, allowing correct calculation of future\n * undelegations without iterating over delegators. When coins are delegated to\n * this validator, the validator is credited with a delegation whose number of\n * bond shares is based on the amount of coins delegated divided by the current\n * exchange rate. Voting power can be calculated as total bonded shares\n * multiplied by exchange rate.\n */\nexport interface Validator {\n  /** operator_address defines the address of the validator's operator; bech encoded in JSON. */\n  operatorAddress: string;\n  /** consensus_pubkey is the consensus public key of the validator, as a Protobuf Any. */\n  consensusPubkey?: Any;\n  /** jailed defined whether the validator has been jailed from bonded status or not. */\n  jailed: boolean;\n  /** status is the validator status (bonded/unbonding/unbonded). */\n  status: BondStatus;\n  /** tokens define the delegated tokens (incl. self-delegation). */\n  tokens: string;\n  /** delegator_shares defines total shares issued to a validator's delegators. */\n  delegatorShares: string;\n  /** description defines the description terms for the validator. */\n  description?: Description;\n  /** unbonding_height defines, if unbonding, the height at which this validator has begun unbonding. */\n  unbondingHeight: Long;\n  /** unbonding_time defines, if unbonding, the min time for the validator to complete unbonding. */\n  unbondingTime?: Date;\n  /** commission defines the commission parameters. */\n  commission?: Commission;\n  /** min_self_delegation is the validator's self declared minimum self delegation. */\n  minSelfDelegation: string;\n}\n\n/** ValAddresses defines a repeated set of validator addresses. */\nexport interface ValAddresses {\n  addresses: string[];\n}\n\n/**\n * DVPair is struct that just has a delegator-validator pair with no other data.\n * It is intended to be used as a marshalable pointer. For example, a DVPair can\n * be used to construct the key to getting an UnbondingDelegation from state.\n */\nexport interface DVPair {\n  delegatorAddress: string;\n  validatorAddress: string;\n}\n\n/** DVPairs defines an array of DVPair objects. */\nexport interface DVPairs {\n  pairs: DVPair[];\n}\n\n/**\n * DVVTriplet is struct that just has a delegator-validator-validator triplet\n * with no other data. It is intended to be used as a marshalable pointer. For\n * example, a DVVTriplet can be used to construct the key to getting a\n * Redelegation from state.\n */\nexport interface DVVTriplet {\n  delegatorAddress: string;\n  validatorSrcAddress: string;\n  validatorDstAddress: string;\n}\n\n/** DVVTriplets defines an array of DVVTriplet objects. */\nexport interface DVVTriplets {\n  triplets: DVVTriplet[];\n}\n\n/**\n * Delegation represents the bond with tokens held by an account. It is\n * owned by one delegator, and is associated with the voting power of one\n * validator.\n */\nexport interface Delegation {\n  /** delegator_address is the bech32-encoded address of the delegator. */\n  delegatorAddress: string;\n  /** validator_address is the bech32-encoded address of the validator. */\n  validatorAddress: string;\n  /** shares define the delegation shares received. */\n  shares: string;\n}\n\n/**\n * UnbondingDelegation stores all of a single delegator's unbonding bonds\n * for a single validator in an time-ordered list.\n */\nexport interface UnbondingDelegation {\n  /** delegator_address is the bech32-encoded address of the delegator. */\n  delegatorAddress: string;\n  /** validator_address is the bech32-encoded address of the validator. */\n  validatorAddress: string;\n  /** entries are the unbonding delegation entries. */\n  entries: UnbondingDelegationEntry[];\n}\n\n/** UnbondingDelegationEntry defines an unbonding object with relevant metadata. */\nexport interface UnbondingDelegationEntry {\n  /** creation_height is the height which the unbonding took place. */\n  creationHeight: Long;\n  /** completion_time is the unix time for unbonding completion. */\n  completionTime?: Date;\n  /** initial_balance defines the tokens initially scheduled to receive at completion. */\n  initialBalance: string;\n  /** balance defines the tokens to receive at completion. */\n  balance: string;\n}\n\n/** RedelegationEntry defines a redelegation object with relevant metadata. */\nexport interface RedelegationEntry {\n  /** creation_height  defines the height which the redelegation took place. */\n  creationHeight: Long;\n  /** completion_time defines the unix time for redelegation completion. */\n  completionTime?: Date;\n  /** initial_balance defines the initial balance when redelegation started. */\n  initialBalance: string;\n  /** shares_dst is the amount of destination-validator shares created by redelegation. */\n  sharesDst: string;\n}\n\n/**\n * Redelegation contains the list of a particular delegator's redelegating bonds\n * from a particular source validator to a particular destination validator.\n */\nexport interface Redelegation {\n  /** delegator_address is the bech32-encoded address of the delegator. */\n  delegatorAddress: string;\n  /** validator_src_address is the validator redelegation source operator address. */\n  validatorSrcAddress: string;\n  /** validator_dst_address is the validator redelegation destination operator address. */\n  validatorDstAddress: string;\n  /** entries are the redelegation entries. */\n  entries: RedelegationEntry[];\n}\n\n/** Params defines the parameters for the staking module. */\nexport interface Params {\n  /** unbonding_time is the time duration of unbonding. */\n  unbondingTime?: Duration;\n  /** max_validators is the maximum number of validators. */\n  maxValidators: number;\n  /** max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio). */\n  maxEntries: number;\n  /** historical_entries is the number of historical entries to persist. */\n  historicalEntries: number;\n  /** bond_denom defines the bondable coin denomination. */\n  bondDenom: string;\n}\n\n/**\n * DelegationResponse is equivalent to Delegation except that it contains a\n * balance in addition to shares which is more suitable for client responses.\n */\nexport interface DelegationResponse {\n  delegation?: Delegation;\n  balance?: Coin;\n}\n\n/**\n * RedelegationEntryResponse is equivalent to a RedelegationEntry except that it\n * contains a balance in addition to shares which is more suitable for client\n * responses.\n */\nexport interface RedelegationEntryResponse {\n  redelegationEntry?: RedelegationEntry;\n  balance: string;\n}\n\n/**\n * RedelegationResponse is equivalent to a Redelegation except that its entries\n * contain a balance in addition to shares which is more suitable for client\n * responses.\n */\nexport interface RedelegationResponse {\n  redelegation?: Redelegation;\n  entries: RedelegationEntryResponse[];\n}\n\n/**\n * Pool is used for tracking bonded and not-bonded token supply of the bond\n * denomination.\n */\nexport interface Pool {\n  notBondedTokens: string;\n  bondedTokens: string;\n}\n\nfunction createBaseHistoricalInfo(): HistoricalInfo {\n  return { header: undefined, valset: [] };\n}\n\nexport const HistoricalInfo = {\n  encode(\n    message: HistoricalInfo,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.header !== undefined) {\n      Header.encode(message.header, writer.uint32(10).fork()).ldelim();\n    }\n    for (const v of message.valset) {\n      Validator.encode(v!, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): HistoricalInfo {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseHistoricalInfo();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.header = Header.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.valset.push(Validator.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): HistoricalInfo {\n    return {\n      header: isSet(object.header) ? Header.fromJSON(object.header) : undefined,\n      valset: Array.isArray(object?.valset)\n        ? object.valset.map((e: any) => Validator.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: HistoricalInfo): unknown {\n    const obj: any = {};\n    message.header !== undefined &&\n      (obj.header = message.header ? Header.toJSON(message.header) : undefined);\n    if (message.valset) {\n      obj.valset = message.valset.map((e) =>\n        e ? Validator.toJSON(e) : undefined\n      );\n    } else {\n      obj.valset = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<HistoricalInfo>, I>>(\n    object: I\n  ): HistoricalInfo {\n    const message = createBaseHistoricalInfo();\n    message.header =\n      object.header !== undefined && object.header !== null\n        ? Header.fromPartial(object.header)\n        : undefined;\n    message.valset = object.valset?.map((e) => Validator.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseCommissionRates(): CommissionRates {\n  return { rate: \"\", maxRate: \"\", maxChangeRate: \"\" };\n}\n\nexport const CommissionRates = {\n  encode(\n    message: CommissionRates,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.rate !== \"\") {\n      writer.uint32(10).string(message.rate);\n    }\n    if (message.maxRate !== \"\") {\n      writer.uint32(18).string(message.maxRate);\n    }\n    if (message.maxChangeRate !== \"\") {\n      writer.uint32(26).string(message.maxChangeRate);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): CommissionRates {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseCommissionRates();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.rate = reader.string();\n          break;\n        case 2:\n          message.maxRate = reader.string();\n          break;\n        case 3:\n          message.maxChangeRate = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): CommissionRates {\n    return {\n      rate: isSet(object.rate) ? String(object.rate) : \"\",\n      maxRate: isSet(object.maxRate) ? String(object.maxRate) : \"\",\n      maxChangeRate: isSet(object.maxChangeRate)\n        ? String(object.maxChangeRate)\n        : \"\",\n    };\n  },\n\n  toJSON(message: CommissionRates): unknown {\n    const obj: any = {};\n    message.rate !== undefined && (obj.rate = message.rate);\n    message.maxRate !== undefined && (obj.maxRate = message.maxRate);\n    message.maxChangeRate !== undefined &&\n      (obj.maxChangeRate = message.maxChangeRate);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<CommissionRates>, I>>(\n    object: I\n  ): CommissionRates {\n    const message = createBaseCommissionRates();\n    message.rate = object.rate ?? \"\";\n    message.maxRate = object.maxRate ?? \"\";\n    message.maxChangeRate = object.maxChangeRate ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseCommission(): Commission {\n  return { commissionRates: undefined, updateTime: undefined };\n}\n\nexport const Commission = {\n  encode(\n    message: Commission,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.commissionRates !== undefined) {\n      CommissionRates.encode(\n        message.commissionRates,\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    if (message.updateTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.updateTime),\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Commission {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseCommission();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.commissionRates = CommissionRates.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n        case 2:\n          message.updateTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Commission {\n    return {\n      commissionRates: isSet(object.commissionRates)\n        ? CommissionRates.fromJSON(object.commissionRates)\n        : undefined,\n      updateTime: isSet(object.updateTime)\n        ? fromJsonTimestamp(object.updateTime)\n        : undefined,\n    };\n  },\n\n  toJSON(message: Commission): unknown {\n    const obj: any = {};\n    message.commissionRates !== undefined &&\n      (obj.commissionRates = message.commissionRates\n        ? CommissionRates.toJSON(message.commissionRates)\n        : undefined);\n    message.updateTime !== undefined &&\n      (obj.updateTime = message.updateTime.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Commission>, I>>(\n    object: I\n  ): Commission {\n    const message = createBaseCommission();\n    message.commissionRates =\n      object.commissionRates !== undefined && object.commissionRates !== null\n        ? CommissionRates.fromPartial(object.commissionRates)\n        : undefined;\n    message.updateTime = object.updateTime ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseDescription(): Description {\n  return {\n    moniker: \"\",\n    identity: \"\",\n    website: \"\",\n    securityContact: \"\",\n    details: \"\",\n  };\n}\n\nexport const Description = {\n  encode(\n    message: Description,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.moniker !== \"\") {\n      writer.uint32(10).string(message.moniker);\n    }\n    if (message.identity !== \"\") {\n      writer.uint32(18).string(message.identity);\n    }\n    if (message.website !== \"\") {\n      writer.uint32(26).string(message.website);\n    }\n    if (message.securityContact !== \"\") {\n      writer.uint32(34).string(message.securityContact);\n    }\n    if (message.details !== \"\") {\n      writer.uint32(42).string(message.details);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Description {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDescription();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.moniker = reader.string();\n          break;\n        case 2:\n          message.identity = reader.string();\n          break;\n        case 3:\n          message.website = reader.string();\n          break;\n        case 4:\n          message.securityContact = reader.string();\n          break;\n        case 5:\n          message.details = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Description {\n    return {\n      moniker: isSet(object.moniker) ? String(object.moniker) : \"\",\n      identity: isSet(object.identity) ? String(object.identity) : \"\",\n      website: isSet(object.website) ? String(object.website) : \"\",\n      securityContact: isSet(object.securityContact)\n        ? String(object.securityContact)\n        : \"\",\n      details: isSet(object.details) ? String(object.details) : \"\",\n    };\n  },\n\n  toJSON(message: Description): unknown {\n    const obj: any = {};\n    message.moniker !== undefined && (obj.moniker = message.moniker);\n    message.identity !== undefined && (obj.identity = message.identity);\n    message.website !== undefined && (obj.website = message.website);\n    message.securityContact !== undefined &&\n      (obj.securityContact = message.securityContact);\n    message.details !== undefined && (obj.details = message.details);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Description>, I>>(\n    object: I\n  ): Description {\n    const message = createBaseDescription();\n    message.moniker = object.moniker ?? \"\";\n    message.identity = object.identity ?? \"\";\n    message.website = object.website ?? \"\";\n    message.securityContact = object.securityContact ?? \"\";\n    message.details = object.details ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseValidator(): Validator {\n  return {\n    operatorAddress: \"\",\n    consensusPubkey: undefined,\n    jailed: false,\n    status: 0,\n    tokens: \"\",\n    delegatorShares: \"\",\n    description: undefined,\n    unbondingHeight: Long.ZERO,\n    unbondingTime: undefined,\n    commission: undefined,\n    minSelfDelegation: \"\",\n  };\n}\n\nexport const Validator = {\n  encode(\n    message: Validator,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.operatorAddress !== \"\") {\n      writer.uint32(10).string(message.operatorAddress);\n    }\n    if (message.consensusPubkey !== undefined) {\n      Any.encode(message.consensusPubkey, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.jailed === true) {\n      writer.uint32(24).bool(message.jailed);\n    }\n    if (message.status !== 0) {\n      writer.uint32(32).int32(message.status);\n    }\n    if (message.tokens !== \"\") {\n      writer.uint32(42).string(message.tokens);\n    }\n    if (message.delegatorShares !== \"\") {\n      writer.uint32(50).string(message.delegatorShares);\n    }\n    if (message.description !== undefined) {\n      Description.encode(\n        message.description,\n        writer.uint32(58).fork()\n      ).ldelim();\n    }\n    if (!message.unbondingHeight.isZero()) {\n      writer.uint32(64).int64(message.unbondingHeight);\n    }\n    if (message.unbondingTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.unbondingTime),\n        writer.uint32(74).fork()\n      ).ldelim();\n    }\n    if (message.commission !== undefined) {\n      Commission.encode(message.commission, writer.uint32(82).fork()).ldelim();\n    }\n    if (message.minSelfDelegation !== \"\") {\n      writer.uint32(90).string(message.minSelfDelegation);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Validator {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseValidator();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.operatorAddress = reader.string();\n          break;\n        case 2:\n          message.consensusPubkey = Any.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.jailed = reader.bool();\n          break;\n        case 4:\n          message.status = reader.int32() as any;\n          break;\n        case 5:\n          message.tokens = reader.string();\n          break;\n        case 6:\n          message.delegatorShares = reader.string();\n          break;\n        case 7:\n          message.description = Description.decode(reader, reader.uint32());\n          break;\n        case 8:\n          message.unbondingHeight = reader.int64() as Long;\n          break;\n        case 9:\n          message.unbondingTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        case 10:\n          message.commission = Commission.decode(reader, reader.uint32());\n          break;\n        case 11:\n          message.minSelfDelegation = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Validator {\n    return {\n      operatorAddress: isSet(object.operatorAddress)\n        ? String(object.operatorAddress)\n        : \"\",\n      consensusPubkey: isSet(object.consensusPubkey)\n        ? Any.fromJSON(object.consensusPubkey)\n        : undefined,\n      jailed: isSet(object.jailed) ? Boolean(object.jailed) : false,\n      status: isSet(object.status) ? bondStatusFromJSON(object.status) : 0,\n      tokens: isSet(object.tokens) ? String(object.tokens) : \"\",\n      delegatorShares: isSet(object.delegatorShares)\n        ? String(object.delegatorShares)\n        : \"\",\n      description: isSet(object.description)\n        ? Description.fromJSON(object.description)\n        : undefined,\n      unbondingHeight: isSet(object.unbondingHeight)\n        ? Long.fromValue(object.unbondingHeight)\n        : Long.ZERO,\n      unbondingTime: isSet(object.unbondingTime)\n        ? fromJsonTimestamp(object.unbondingTime)\n        : undefined,\n      commission: isSet(object.commission)\n        ? Commission.fromJSON(object.commission)\n        : undefined,\n      minSelfDelegation: isSet(object.minSelfDelegation)\n        ? String(object.minSelfDelegation)\n        : \"\",\n    };\n  },\n\n  toJSON(message: Validator): unknown {\n    const obj: any = {};\n    message.operatorAddress !== undefined &&\n      (obj.operatorAddress = message.operatorAddress);\n    message.consensusPubkey !== undefined &&\n      (obj.consensusPubkey = message.consensusPubkey\n        ? Any.toJSON(message.consensusPubkey)\n        : undefined);\n    message.jailed !== undefined && (obj.jailed = message.jailed);\n    message.status !== undefined &&\n      (obj.status = bondStatusToJSON(message.status));\n    message.tokens !== undefined && (obj.tokens = message.tokens);\n    message.delegatorShares !== undefined &&\n      (obj.delegatorShares = message.delegatorShares);\n    message.description !== undefined &&\n      (obj.description = message.description\n        ? Description.toJSON(message.description)\n        : undefined);\n    message.unbondingHeight !== undefined &&\n      (obj.unbondingHeight = (message.unbondingHeight || Long.ZERO).toString());\n    message.unbondingTime !== undefined &&\n      (obj.unbondingTime = message.unbondingTime.toISOString());\n    message.commission !== undefined &&\n      (obj.commission = message.commission\n        ? Commission.toJSON(message.commission)\n        : undefined);\n    message.minSelfDelegation !== undefined &&\n      (obj.minSelfDelegation = message.minSelfDelegation);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Validator>, I>>(\n    object: I\n  ): Validator {\n    const message = createBaseValidator();\n    message.operatorAddress = object.operatorAddress ?? \"\";\n    message.consensusPubkey =\n      object.consensusPubkey !== undefined && object.consensusPubkey !== null\n        ? Any.fromPartial(object.consensusPubkey)\n        : undefined;\n    message.jailed = object.jailed ?? false;\n    message.status = object.status ?? 0;\n    message.tokens = object.tokens ?? \"\";\n    message.delegatorShares = object.delegatorShares ?? \"\";\n    message.description =\n      object.description !== undefined && object.description !== null\n        ? Description.fromPartial(object.description)\n        : undefined;\n    message.unbondingHeight =\n      object.unbondingHeight !== undefined && object.unbondingHeight !== null\n        ? Long.fromValue(object.unbondingHeight)\n        : Long.ZERO;\n    message.unbondingTime = object.unbondingTime ?? undefined;\n    message.commission =\n      object.commission !== undefined && object.commission !== null\n        ? Commission.fromPartial(object.commission)\n        : undefined;\n    message.minSelfDelegation = object.minSelfDelegation ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseValAddresses(): ValAddresses {\n  return { addresses: [] };\n}\n\nexport const ValAddresses = {\n  encode(\n    message: ValAddresses,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.addresses) {\n      writer.uint32(10).string(v!);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): ValAddresses {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseValAddresses();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.addresses.push(reader.string());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ValAddresses {\n    return {\n      addresses: Array.isArray(object?.addresses)\n        ? object.addresses.map((e: any) => String(e))\n        : [],\n    };\n  },\n\n  toJSON(message: ValAddresses): unknown {\n    const obj: any = {};\n    if (message.addresses) {\n      obj.addresses = message.addresses.map((e) => e);\n    } else {\n      obj.addresses = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<ValAddresses>, I>>(\n    object: I\n  ): ValAddresses {\n    const message = createBaseValAddresses();\n    message.addresses = object.addresses?.map((e) => e) || [];\n    return message;\n  },\n};\n\nfunction createBaseDVPair(): DVPair {\n  return { delegatorAddress: \"\", validatorAddress: \"\" };\n}\n\nexport const DVPair = {\n  encode(\n    message: DVPair,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(18).string(message.validatorAddress);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): DVPair {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDVPair();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorAddress = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): DVPair {\n    return {\n      delegatorAddress: isSet(object.delegatorAddress)\n        ? String(object.delegatorAddress)\n        : \"\",\n      validatorAddress: isSet(object.validatorAddress)\n        ? String(object.validatorAddress)\n        : \"\",\n    };\n  },\n\n  toJSON(message: DVPair): unknown {\n    const obj: any = {};\n    message.delegatorAddress !== undefined &&\n      (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorAddress !== undefined &&\n      (obj.validatorAddress = message.validatorAddress);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<DVPair>, I>>(object: I): DVPair {\n    const message = createBaseDVPair();\n    message.delegatorAddress = object.delegatorAddress ?? \"\";\n    message.validatorAddress = object.validatorAddress ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseDVPairs(): DVPairs {\n  return { pairs: [] };\n}\n\nexport const DVPairs = {\n  encode(\n    message: DVPairs,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.pairs) {\n      DVPair.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): DVPairs {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDVPairs();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.pairs.push(DVPair.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): DVPairs {\n    return {\n      pairs: Array.isArray(object?.pairs)\n        ? object.pairs.map((e: any) => DVPair.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: DVPairs): unknown {\n    const obj: any = {};\n    if (message.pairs) {\n      obj.pairs = message.pairs.map((e) => (e ? DVPair.toJSON(e) : undefined));\n    } else {\n      obj.pairs = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<DVPairs>, I>>(object: I): DVPairs {\n    const message = createBaseDVPairs();\n    message.pairs = object.pairs?.map((e) => DVPair.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseDVVTriplet(): DVVTriplet {\n  return {\n    delegatorAddress: \"\",\n    validatorSrcAddress: \"\",\n    validatorDstAddress: \"\",\n  };\n}\n\nexport const DVVTriplet = {\n  encode(\n    message: DVVTriplet,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorSrcAddress !== \"\") {\n      writer.uint32(18).string(message.validatorSrcAddress);\n    }\n    if (message.validatorDstAddress !== \"\") {\n      writer.uint32(26).string(message.validatorDstAddress);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): DVVTriplet {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDVVTriplet();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorSrcAddress = reader.string();\n          break;\n        case 3:\n          message.validatorDstAddress = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): DVVTriplet {\n    return {\n      delegatorAddress: isSet(object.delegatorAddress)\n        ? String(object.delegatorAddress)\n        : \"\",\n      validatorSrcAddress: isSet(object.validatorSrcAddress)\n        ? String(object.validatorSrcAddress)\n        : \"\",\n      validatorDstAddress: isSet(object.validatorDstAddress)\n        ? String(object.validatorDstAddress)\n        : \"\",\n    };\n  },\n\n  toJSON(message: DVVTriplet): unknown {\n    const obj: any = {};\n    message.delegatorAddress !== undefined &&\n      (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorSrcAddress !== undefined &&\n      (obj.validatorSrcAddress = message.validatorSrcAddress);\n    message.validatorDstAddress !== undefined &&\n      (obj.validatorDstAddress = message.validatorDstAddress);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<DVVTriplet>, I>>(\n    object: I\n  ): DVVTriplet {\n    const message = createBaseDVVTriplet();\n    message.delegatorAddress = object.delegatorAddress ?? \"\";\n    message.validatorSrcAddress = object.validatorSrcAddress ?? \"\";\n    message.validatorDstAddress = object.validatorDstAddress ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseDVVTriplets(): DVVTriplets {\n  return { triplets: [] };\n}\n\nexport const DVVTriplets = {\n  encode(\n    message: DVVTriplets,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.triplets) {\n      DVVTriplet.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): DVVTriplets {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDVVTriplets();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.triplets.push(DVVTriplet.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): DVVTriplets {\n    return {\n      triplets: Array.isArray(object?.triplets)\n        ? object.triplets.map((e: any) => DVVTriplet.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: DVVTriplets): unknown {\n    const obj: any = {};\n    if (message.triplets) {\n      obj.triplets = message.triplets.map((e) =>\n        e ? DVVTriplet.toJSON(e) : undefined\n      );\n    } else {\n      obj.triplets = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<DVVTriplets>, I>>(\n    object: I\n  ): DVVTriplets {\n    const message = createBaseDVVTriplets();\n    message.triplets =\n      object.triplets?.map((e) => DVVTriplet.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseDelegation(): Delegation {\n  return { delegatorAddress: \"\", validatorAddress: \"\", shares: \"\" };\n}\n\nexport const Delegation = {\n  encode(\n    message: Delegation,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(18).string(message.validatorAddress);\n    }\n    if (message.shares !== \"\") {\n      writer.uint32(26).string(message.shares);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Delegation {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDelegation();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorAddress = reader.string();\n          break;\n        case 3:\n          message.shares = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Delegation {\n    return {\n      delegatorAddress: isSet(object.delegatorAddress)\n        ? String(object.delegatorAddress)\n        : \"\",\n      validatorAddress: isSet(object.validatorAddress)\n        ? String(object.validatorAddress)\n        : \"\",\n      shares: isSet(object.shares) ? String(object.shares) : \"\",\n    };\n  },\n\n  toJSON(message: Delegation): unknown {\n    const obj: any = {};\n    message.delegatorAddress !== undefined &&\n      (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorAddress !== undefined &&\n      (obj.validatorAddress = message.validatorAddress);\n    message.shares !== undefined && (obj.shares = message.shares);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Delegation>, I>>(\n    object: I\n  ): Delegation {\n    const message = createBaseDelegation();\n    message.delegatorAddress = object.delegatorAddress ?? \"\";\n    message.validatorAddress = object.validatorAddress ?? \"\";\n    message.shares = object.shares ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseUnbondingDelegation(): UnbondingDelegation {\n  return { delegatorAddress: \"\", validatorAddress: \"\", entries: [] };\n}\n\nexport const UnbondingDelegation = {\n  encode(\n    message: UnbondingDelegation,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(18).string(message.validatorAddress);\n    }\n    for (const v of message.entries) {\n      UnbondingDelegationEntry.encode(v!, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): UnbondingDelegation {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseUnbondingDelegation();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorAddress = reader.string();\n          break;\n        case 3:\n          message.entries.push(\n            UnbondingDelegationEntry.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): UnbondingDelegation {\n    return {\n      delegatorAddress: isSet(object.delegatorAddress)\n        ? String(object.delegatorAddress)\n        : \"\",\n      validatorAddress: isSet(object.validatorAddress)\n        ? String(object.validatorAddress)\n        : \"\",\n      entries: Array.isArray(object?.entries)\n        ? object.entries.map((e: any) => UnbondingDelegationEntry.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: UnbondingDelegation): unknown {\n    const obj: any = {};\n    message.delegatorAddress !== undefined &&\n      (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorAddress !== undefined &&\n      (obj.validatorAddress = message.validatorAddress);\n    if (message.entries) {\n      obj.entries = message.entries.map((e) =>\n        e ? UnbondingDelegationEntry.toJSON(e) : undefined\n      );\n    } else {\n      obj.entries = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<UnbondingDelegation>, I>>(\n    object: I\n  ): UnbondingDelegation {\n    const message = createBaseUnbondingDelegation();\n    message.delegatorAddress = object.delegatorAddress ?? \"\";\n    message.validatorAddress = object.validatorAddress ?? \"\";\n    message.entries =\n      object.entries?.map((e) => UnbondingDelegationEntry.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseUnbondingDelegationEntry(): UnbondingDelegationEntry {\n  return {\n    creationHeight: Long.ZERO,\n    completionTime: undefined,\n    initialBalance: \"\",\n    balance: \"\",\n  };\n}\n\nexport const UnbondingDelegationEntry = {\n  encode(\n    message: UnbondingDelegationEntry,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.creationHeight.isZero()) {\n      writer.uint32(8).int64(message.creationHeight);\n    }\n    if (message.completionTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.completionTime),\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    if (message.initialBalance !== \"\") {\n      writer.uint32(26).string(message.initialBalance);\n    }\n    if (message.balance !== \"\") {\n      writer.uint32(34).string(message.balance);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): UnbondingDelegationEntry {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseUnbondingDelegationEntry();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creationHeight = reader.int64() as Long;\n          break;\n        case 2:\n          message.completionTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        case 3:\n          message.initialBalance = reader.string();\n          break;\n        case 4:\n          message.balance = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): UnbondingDelegationEntry {\n    return {\n      creationHeight: isSet(object.creationHeight)\n        ? Long.fromValue(object.creationHeight)\n        : Long.ZERO,\n      completionTime: isSet(object.completionTime)\n        ? fromJsonTimestamp(object.completionTime)\n        : undefined,\n      initialBalance: isSet(object.initialBalance)\n        ? String(object.initialBalance)\n        : \"\",\n      balance: isSet(object.balance) ? String(object.balance) : \"\",\n    };\n  },\n\n  toJSON(message: UnbondingDelegationEntry): unknown {\n    const obj: any = {};\n    message.creationHeight !== undefined &&\n      (obj.creationHeight = (message.creationHeight || Long.ZERO).toString());\n    message.completionTime !== undefined &&\n      (obj.completionTime = message.completionTime.toISOString());\n    message.initialBalance !== undefined &&\n      (obj.initialBalance = message.initialBalance);\n    message.balance !== undefined && (obj.balance = message.balance);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<UnbondingDelegationEntry>, I>>(\n    object: I\n  ): UnbondingDelegationEntry {\n    const message = createBaseUnbondingDelegationEntry();\n    message.creationHeight =\n      object.creationHeight !== undefined && object.creationHeight !== null\n        ? Long.fromValue(object.creationHeight)\n        : Long.ZERO;\n    message.completionTime = object.completionTime ?? undefined;\n    message.initialBalance = object.initialBalance ?? \"\";\n    message.balance = object.balance ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseRedelegationEntry(): RedelegationEntry {\n  return {\n    creationHeight: Long.ZERO,\n    completionTime: undefined,\n    initialBalance: \"\",\n    sharesDst: \"\",\n  };\n}\n\nexport const RedelegationEntry = {\n  encode(\n    message: RedelegationEntry,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.creationHeight.isZero()) {\n      writer.uint32(8).int64(message.creationHeight);\n    }\n    if (message.completionTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.completionTime),\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    if (message.initialBalance !== \"\") {\n      writer.uint32(26).string(message.initialBalance);\n    }\n    if (message.sharesDst !== \"\") {\n      writer.uint32(34).string(message.sharesDst);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): RedelegationEntry {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRedelegationEntry();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creationHeight = reader.int64() as Long;\n          break;\n        case 2:\n          message.completionTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        case 3:\n          message.initialBalance = reader.string();\n          break;\n        case 4:\n          message.sharesDst = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): RedelegationEntry {\n    return {\n      creationHeight: isSet(object.creationHeight)\n        ? Long.fromValue(object.creationHeight)\n        : Long.ZERO,\n      completionTime: isSet(object.completionTime)\n        ? fromJsonTimestamp(object.completionTime)\n        : undefined,\n      initialBalance: isSet(object.initialBalance)\n        ? String(object.initialBalance)\n        : \"\",\n      sharesDst: isSet(object.sharesDst) ? String(object.sharesDst) : \"\",\n    };\n  },\n\n  toJSON(message: RedelegationEntry): unknown {\n    const obj: any = {};\n    message.creationHeight !== undefined &&\n      (obj.creationHeight = (message.creationHeight || Long.ZERO).toString());\n    message.completionTime !== undefined &&\n      (obj.completionTime = message.completionTime.toISOString());\n    message.initialBalance !== undefined &&\n      (obj.initialBalance = message.initialBalance);\n    message.sharesDst !== undefined && (obj.sharesDst = message.sharesDst);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<RedelegationEntry>, I>>(\n    object: I\n  ): RedelegationEntry {\n    const message = createBaseRedelegationEntry();\n    message.creationHeight =\n      object.creationHeight !== undefined && object.creationHeight !== null\n        ? Long.fromValue(object.creationHeight)\n        : Long.ZERO;\n    message.completionTime = object.completionTime ?? undefined;\n    message.initialBalance = object.initialBalance ?? \"\";\n    message.sharesDst = object.sharesDst ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseRedelegation(): Redelegation {\n  return {\n    delegatorAddress: \"\",\n    validatorSrcAddress: \"\",\n    validatorDstAddress: \"\",\n    entries: [],\n  };\n}\n\nexport const Redelegation = {\n  encode(\n    message: Redelegation,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorSrcAddress !== \"\") {\n      writer.uint32(18).string(message.validatorSrcAddress);\n    }\n    if (message.validatorDstAddress !== \"\") {\n      writer.uint32(26).string(message.validatorDstAddress);\n    }\n    for (const v of message.entries) {\n      RedelegationEntry.encode(v!, writer.uint32(34).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Redelegation {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRedelegation();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorSrcAddress = reader.string();\n          break;\n        case 3:\n          message.validatorDstAddress = reader.string();\n          break;\n        case 4:\n          message.entries.push(\n            RedelegationEntry.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Redelegation {\n    return {\n      delegatorAddress: isSet(object.delegatorAddress)\n        ? String(object.delegatorAddress)\n        : \"\",\n      validatorSrcAddress: isSet(object.validatorSrcAddress)\n        ? String(object.validatorSrcAddress)\n        : \"\",\n      validatorDstAddress: isSet(object.validatorDstAddress)\n        ? String(object.validatorDstAddress)\n        : \"\",\n      entries: Array.isArray(object?.entries)\n        ? object.entries.map((e: any) => RedelegationEntry.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: Redelegation): unknown {\n    const obj: any = {};\n    message.delegatorAddress !== undefined &&\n      (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorSrcAddress !== undefined &&\n      (obj.validatorSrcAddress = message.validatorSrcAddress);\n    message.validatorDstAddress !== undefined &&\n      (obj.validatorDstAddress = message.validatorDstAddress);\n    if (message.entries) {\n      obj.entries = message.entries.map((e) =>\n        e ? RedelegationEntry.toJSON(e) : undefined\n      );\n    } else {\n      obj.entries = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Redelegation>, I>>(\n    object: I\n  ): Redelegation {\n    const message = createBaseRedelegation();\n    message.delegatorAddress = object.delegatorAddress ?? \"\";\n    message.validatorSrcAddress = object.validatorSrcAddress ?? \"\";\n    message.validatorDstAddress = object.validatorDstAddress ?? \"\";\n    message.entries =\n      object.entries?.map((e) => RedelegationEntry.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseParams(): Params {\n  return {\n    unbondingTime: undefined,\n    maxValidators: 0,\n    maxEntries: 0,\n    historicalEntries: 0,\n    bondDenom: \"\",\n  };\n}\n\nexport const Params = {\n  encode(\n    message: Params,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.unbondingTime !== undefined) {\n      Duration.encode(message.unbondingTime, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.maxValidators !== 0) {\n      writer.uint32(16).uint32(message.maxValidators);\n    }\n    if (message.maxEntries !== 0) {\n      writer.uint32(24).uint32(message.maxEntries);\n    }\n    if (message.historicalEntries !== 0) {\n      writer.uint32(32).uint32(message.historicalEntries);\n    }\n    if (message.bondDenom !== \"\") {\n      writer.uint32(42).string(message.bondDenom);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Params {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseParams();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.unbondingTime = Duration.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.maxValidators = reader.uint32();\n          break;\n        case 3:\n          message.maxEntries = reader.uint32();\n          break;\n        case 4:\n          message.historicalEntries = reader.uint32();\n          break;\n        case 5:\n          message.bondDenom = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Params {\n    return {\n      unbondingTime: isSet(object.unbondingTime)\n        ? Duration.fromJSON(object.unbondingTime)\n        : undefined,\n      maxValidators: isSet(object.maxValidators)\n        ? Number(object.maxValidators)\n        : 0,\n      maxEntries: isSet(object.maxEntries) ? Number(object.maxEntries) : 0,\n      historicalEntries: isSet(object.historicalEntries)\n        ? Number(object.historicalEntries)\n        : 0,\n      bondDenom: isSet(object.bondDenom) ? String(object.bondDenom) : \"\",\n    };\n  },\n\n  toJSON(message: Params): unknown {\n    const obj: any = {};\n    message.unbondingTime !== undefined &&\n      (obj.unbondingTime = message.unbondingTime\n        ? Duration.toJSON(message.unbondingTime)\n        : undefined);\n    message.maxValidators !== undefined &&\n      (obj.maxValidators = Math.round(message.maxValidators));\n    message.maxEntries !== undefined &&\n      (obj.maxEntries = Math.round(message.maxEntries));\n    message.historicalEntries !== undefined &&\n      (obj.historicalEntries = Math.round(message.historicalEntries));\n    message.bondDenom !== undefined && (obj.bondDenom = message.bondDenom);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Params>, I>>(object: I): Params {\n    const message = createBaseParams();\n    message.unbondingTime =\n      object.unbondingTime !== undefined && object.unbondingTime !== null\n        ? Duration.fromPartial(object.unbondingTime)\n        : undefined;\n    message.maxValidators = object.maxValidators ?? 0;\n    message.maxEntries = object.maxEntries ?? 0;\n    message.historicalEntries = object.historicalEntries ?? 0;\n    message.bondDenom = object.bondDenom ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseDelegationResponse(): DelegationResponse {\n  return { delegation: undefined, balance: undefined };\n}\n\nexport const DelegationResponse = {\n  encode(\n    message: DelegationResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.delegation !== undefined) {\n      Delegation.encode(message.delegation, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.balance !== undefined) {\n      Coin.encode(message.balance, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): DelegationResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDelegationResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegation = Delegation.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.balance = Coin.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): DelegationResponse {\n    return {\n      delegation: isSet(object.delegation)\n        ? Delegation.fromJSON(object.delegation)\n        : undefined,\n      balance: isSet(object.balance)\n        ? Coin.fromJSON(object.balance)\n        : undefined,\n    };\n  },\n\n  toJSON(message: DelegationResponse): unknown {\n    const obj: any = {};\n    message.delegation !== undefined &&\n      (obj.delegation = message.delegation\n        ? Delegation.toJSON(message.delegation)\n        : undefined);\n    message.balance !== undefined &&\n      (obj.balance = message.balance\n        ? Coin.toJSON(message.balance)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<DelegationResponse>, I>>(\n    object: I\n  ): DelegationResponse {\n    const message = createBaseDelegationResponse();\n    message.delegation =\n      object.delegation !== undefined && object.delegation !== null\n        ? Delegation.fromPartial(object.delegation)\n        : undefined;\n    message.balance =\n      object.balance !== undefined && object.balance !== null\n        ? Coin.fromPartial(object.balance)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseRedelegationEntryResponse(): RedelegationEntryResponse {\n  return { redelegationEntry: undefined, balance: \"\" };\n}\n\nexport const RedelegationEntryResponse = {\n  encode(\n    message: RedelegationEntryResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.redelegationEntry !== undefined) {\n      RedelegationEntry.encode(\n        message.redelegationEntry,\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    if (message.balance !== \"\") {\n      writer.uint32(34).string(message.balance);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): RedelegationEntryResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRedelegationEntryResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.redelegationEntry = RedelegationEntry.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n        case 4:\n          message.balance = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): RedelegationEntryResponse {\n    return {\n      redelegationEntry: isSet(object.redelegationEntry)\n        ? RedelegationEntry.fromJSON(object.redelegationEntry)\n        : undefined,\n      balance: isSet(object.balance) ? String(object.balance) : \"\",\n    };\n  },\n\n  toJSON(message: RedelegationEntryResponse): unknown {\n    const obj: any = {};\n    message.redelegationEntry !== undefined &&\n      (obj.redelegationEntry = message.redelegationEntry\n        ? RedelegationEntry.toJSON(message.redelegationEntry)\n        : undefined);\n    message.balance !== undefined && (obj.balance = message.balance);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<RedelegationEntryResponse>, I>>(\n    object: I\n  ): RedelegationEntryResponse {\n    const message = createBaseRedelegationEntryResponse();\n    message.redelegationEntry =\n      object.redelegationEntry !== undefined &&\n      object.redelegationEntry !== null\n        ? RedelegationEntry.fromPartial(object.redelegationEntry)\n        : undefined;\n    message.balance = object.balance ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseRedelegationResponse(): RedelegationResponse {\n  return { redelegation: undefined, entries: [] };\n}\n\nexport const RedelegationResponse = {\n  encode(\n    message: RedelegationResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.redelegation !== undefined) {\n      Redelegation.encode(\n        message.redelegation,\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    for (const v of message.entries) {\n      RedelegationEntryResponse.encode(v!, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): RedelegationResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRedelegationResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.redelegation = Redelegation.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.entries.push(\n            RedelegationEntryResponse.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): RedelegationResponse {\n    return {\n      redelegation: isSet(object.redelegation)\n        ? Redelegation.fromJSON(object.redelegation)\n        : undefined,\n      entries: Array.isArray(object?.entries)\n        ? object.entries.map((e: any) => RedelegationEntryResponse.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: RedelegationResponse): unknown {\n    const obj: any = {};\n    message.redelegation !== undefined &&\n      (obj.redelegation = message.redelegation\n        ? Redelegation.toJSON(message.redelegation)\n        : undefined);\n    if (message.entries) {\n      obj.entries = message.entries.map((e) =>\n        e ? RedelegationEntryResponse.toJSON(e) : undefined\n      );\n    } else {\n      obj.entries = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<RedelegationResponse>, I>>(\n    object: I\n  ): RedelegationResponse {\n    const message = createBaseRedelegationResponse();\n    message.redelegation =\n      object.redelegation !== undefined && object.redelegation !== null\n        ? Redelegation.fromPartial(object.redelegation)\n        : undefined;\n    message.entries =\n      object.entries?.map((e) => RedelegationEntryResponse.fromPartial(e)) ||\n      [];\n    return message;\n  },\n};\n\nfunction createBasePool(): Pool {\n  return { notBondedTokens: \"\", bondedTokens: \"\" };\n}\n\nexport const Pool = {\n  encode(message: Pool, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (message.notBondedTokens !== \"\") {\n      writer.uint32(10).string(message.notBondedTokens);\n    }\n    if (message.bondedTokens !== \"\") {\n      writer.uint32(18).string(message.bondedTokens);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Pool {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBasePool();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.notBondedTokens = reader.string();\n          break;\n        case 2:\n          message.bondedTokens = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Pool {\n    return {\n      notBondedTokens: isSet(object.notBondedTokens)\n        ? String(object.notBondedTokens)\n        : \"\",\n      bondedTokens: isSet(object.bondedTokens)\n        ? String(object.bondedTokens)\n        : \"\",\n    };\n  },\n\n  toJSON(message: Pool): unknown {\n    const obj: any = {};\n    message.notBondedTokens !== undefined &&\n      (obj.notBondedTokens = message.notBondedTokens);\n    message.bondedTokens !== undefined &&\n      (obj.bondedTokens = message.bondedTokens);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Pool>, I>>(object: I): Pool {\n    const message = createBasePool();\n    message.notBondedTokens = object.notBondedTokens ?? \"\";\n    message.bondedTokens = object.bondedTokens ?? \"\";\n    return message;\n  },\n};\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nfunction toTimestamp(date: Date): Timestamp {\n  const seconds = numberToLong(date.getTime() / 1_000);\n  const nanos = (date.getTime() % 1_000) * 1_000_000;\n  return { seconds, nanos };\n}\n\nfunction fromTimestamp(t: Timestamp): Date {\n  let millis = t.seconds.toNumber() * 1_000;\n  millis += t.nanos / 1_000_000;\n  return new Date(millis);\n}\n\nfunction fromJsonTimestamp(o: any): Date {\n  if (o instanceof Date) {\n    return o;\n  } else if (typeof o === \"string\") {\n    return new Date(o);\n  } else {\n    return fromTimestamp(Timestamp.fromJSON(o));\n  }\n}\n\nfunction numberToLong(number: number) {\n  return Long.fromNumber(number);\n}\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport { grpc } from \"@improbable-eng/grpc-web\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Description, CommissionRates } from \"./staking\";\nimport { Any } from \"../../../google/protobuf/any\";\nimport { Coin } from \"../../base/v1beta1/coin\";\nimport { BrowserHeaders } from \"browser-headers\";\nimport { Timestamp } from \"../../../google/protobuf/timestamp\";\n\nexport const protobufPackage = \"cosmos.staking.v1beta1\";\n\n/** MsgCreateValidator defines a SDK message for creating a new validator. */\nexport interface MsgCreateValidator {\n  description?: Description;\n  commission?: CommissionRates;\n  minSelfDelegation: string;\n  delegatorAddress: string;\n  validatorAddress: string;\n  pubkey?: Any;\n  value?: Coin;\n}\n\n/** MsgCreateValidatorResponse defines the Msg/CreateValidator response type. */\nexport interface MsgCreateValidatorResponse {}\n\n/** MsgEditValidator defines a SDK message for editing an existing validator. */\nexport interface MsgEditValidator {\n  description?: Description;\n  validatorAddress: string;\n  /**\n   * We pass a reference to the new commission rate and min self delegation as\n   * it's not mandatory to update. If not updated, the deserialized rate will be\n   * zero with no way to distinguish if an update was intended.\n   * REF: #2373\n   */\n  commissionRate: string;\n  minSelfDelegation: string;\n}\n\n/** MsgEditValidatorResponse defines the Msg/EditValidator response type. */\nexport interface MsgEditValidatorResponse {}\n\n/**\n * MsgDelegate defines a SDK message for performing a delegation of coins\n * from a delegator to a validator.\n */\nexport interface MsgDelegate {\n  delegatorAddress: string;\n  validatorAddress: string;\n  amount?: Coin;\n}\n\n/** MsgDelegateResponse defines the Msg/Delegate response type. */\nexport interface MsgDelegateResponse {}\n\n/**\n * MsgBeginRedelegate defines a SDK message for performing a redelegation\n * of coins from a delegator and source validator to a destination validator.\n */\nexport interface MsgBeginRedelegate {\n  delegatorAddress: string;\n  validatorSrcAddress: string;\n  validatorDstAddress: string;\n  amount?: Coin;\n}\n\n/** MsgBeginRedelegateResponse defines the Msg/BeginRedelegate response type. */\nexport interface MsgBeginRedelegateResponse {\n  completionTime?: Date;\n}\n\n/**\n * MsgUndelegate defines a SDK message for performing an undelegation from a\n * delegate and a validator.\n */\nexport interface MsgUndelegate {\n  delegatorAddress: string;\n  validatorAddress: string;\n  amount?: Coin;\n}\n\n/** MsgUndelegateResponse defines the Msg/Undelegate response type. */\nexport interface MsgUndelegateResponse {\n  completionTime?: Date;\n}\n\nfunction createBaseMsgCreateValidator(): MsgCreateValidator {\n  return {\n    description: undefined,\n    commission: undefined,\n    minSelfDelegation: \"\",\n    delegatorAddress: \"\",\n    validatorAddress: \"\",\n    pubkey: undefined,\n    value: undefined,\n  };\n}\n\nexport const MsgCreateValidator = {\n  encode(\n    message: MsgCreateValidator,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.description !== undefined) {\n      Description.encode(\n        message.description,\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    if (message.commission !== undefined) {\n      CommissionRates.encode(\n        message.commission,\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    if (message.minSelfDelegation !== \"\") {\n      writer.uint32(26).string(message.minSelfDelegation);\n    }\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(34).string(message.delegatorAddress);\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(42).string(message.validatorAddress);\n    }\n    if (message.pubkey !== undefined) {\n      Any.encode(message.pubkey, writer.uint32(50).fork()).ldelim();\n    }\n    if (message.value !== undefined) {\n      Coin.encode(message.value, writer.uint32(58).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateValidator {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCreateValidator();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.description = Description.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.commission = CommissionRates.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.minSelfDelegation = reader.string();\n          break;\n        case 4:\n          message.delegatorAddress = reader.string();\n          break;\n        case 5:\n          message.validatorAddress = reader.string();\n          break;\n        case 6:\n          message.pubkey = Any.decode(reader, reader.uint32());\n          break;\n        case 7:\n          message.value = Coin.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCreateValidator {\n    return {\n      description: isSet(object.description)\n        ? Description.fromJSON(object.description)\n        : undefined,\n      commission: isSet(object.commission)\n        ? CommissionRates.fromJSON(object.commission)\n        : undefined,\n      minSelfDelegation: isSet(object.minSelfDelegation)\n        ? String(object.minSelfDelegation)\n        : \"\",\n      delegatorAddress: isSet(object.delegatorAddress)\n        ? String(object.delegatorAddress)\n        : \"\",\n      validatorAddress: isSet(object.validatorAddress)\n        ? String(object.validatorAddress)\n        : \"\",\n      pubkey: isSet(object.pubkey) ? Any.fromJSON(object.pubkey) : undefined,\n      value: isSet(object.value) ? Coin.fromJSON(object.value) : undefined,\n    };\n  },\n\n  toJSON(message: MsgCreateValidator): unknown {\n    const obj: any = {};\n    message.description !== undefined &&\n      (obj.description = message.description\n        ? Description.toJSON(message.description)\n        : undefined);\n    message.commission !== undefined &&\n      (obj.commission = message.commission\n        ? CommissionRates.toJSON(message.commission)\n        : undefined);\n    message.minSelfDelegation !== undefined &&\n      (obj.minSelfDelegation = message.minSelfDelegation);\n    message.delegatorAddress !== undefined &&\n      (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorAddress !== undefined &&\n      (obj.validatorAddress = message.validatorAddress);\n    message.pubkey !== undefined &&\n      (obj.pubkey = message.pubkey ? Any.toJSON(message.pubkey) : undefined);\n    message.value !== undefined &&\n      (obj.value = message.value ? Coin.toJSON(message.value) : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCreateValidator>, I>>(\n    object: I\n  ): MsgCreateValidator {\n    const message = createBaseMsgCreateValidator();\n    message.description =\n      object.description !== undefined && object.description !== null\n        ? Description.fromPartial(object.description)\n        : undefined;\n    message.commission =\n      object.commission !== undefined && object.commission !== null\n        ? CommissionRates.fromPartial(object.commission)\n        : undefined;\n    message.minSelfDelegation = object.minSelfDelegation ?? \"\";\n    message.delegatorAddress = object.delegatorAddress ?? \"\";\n    message.validatorAddress = object.validatorAddress ?? \"\";\n    message.pubkey =\n      object.pubkey !== undefined && object.pubkey !== null\n        ? Any.fromPartial(object.pubkey)\n        : undefined;\n    message.value =\n      object.value !== undefined && object.value !== null\n        ? Coin.fromPartial(object.value)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgCreateValidatorResponse(): MsgCreateValidatorResponse {\n  return {};\n}\n\nexport const MsgCreateValidatorResponse = {\n  encode(\n    _: MsgCreateValidatorResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCreateValidatorResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCreateValidatorResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCreateValidatorResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCreateValidatorResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCreateValidatorResponse>, I>>(\n    _: I\n  ): MsgCreateValidatorResponse {\n    const message = createBaseMsgCreateValidatorResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgEditValidator(): MsgEditValidator {\n  return {\n    description: undefined,\n    validatorAddress: \"\",\n    commissionRate: \"\",\n    minSelfDelegation: \"\",\n  };\n}\n\nexport const MsgEditValidator = {\n  encode(\n    message: MsgEditValidator,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.description !== undefined) {\n      Description.encode(\n        message.description,\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(18).string(message.validatorAddress);\n    }\n    if (message.commissionRate !== \"\") {\n      writer.uint32(26).string(message.commissionRate);\n    }\n    if (message.minSelfDelegation !== \"\") {\n      writer.uint32(34).string(message.minSelfDelegation);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgEditValidator {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgEditValidator();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.description = Description.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.validatorAddress = reader.string();\n          break;\n        case 3:\n          message.commissionRate = reader.string();\n          break;\n        case 4:\n          message.minSelfDelegation = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgEditValidator {\n    return {\n      description: isSet(object.description)\n        ? Description.fromJSON(object.description)\n        : undefined,\n      validatorAddress: isSet(object.validatorAddress)\n        ? String(object.validatorAddress)\n        : \"\",\n      commissionRate: isSet(object.commissionRate)\n        ? String(object.commissionRate)\n        : \"\",\n      minSelfDelegation: isSet(object.minSelfDelegation)\n        ? String(object.minSelfDelegation)\n        : \"\",\n    };\n  },\n\n  toJSON(message: MsgEditValidator): unknown {\n    const obj: any = {};\n    message.description !== undefined &&\n      (obj.description = message.description\n        ? Description.toJSON(message.description)\n        : undefined);\n    message.validatorAddress !== undefined &&\n      (obj.validatorAddress = message.validatorAddress);\n    message.commissionRate !== undefined &&\n      (obj.commissionRate = message.commissionRate);\n    message.minSelfDelegation !== undefined &&\n      (obj.minSelfDelegation = message.minSelfDelegation);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgEditValidator>, I>>(\n    object: I\n  ): MsgEditValidator {\n    const message = createBaseMsgEditValidator();\n    message.description =\n      object.description !== undefined && object.description !== null\n        ? Description.fromPartial(object.description)\n        : undefined;\n    message.validatorAddress = object.validatorAddress ?? \"\";\n    message.commissionRate = object.commissionRate ?? \"\";\n    message.minSelfDelegation = object.minSelfDelegation ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgEditValidatorResponse(): MsgEditValidatorResponse {\n  return {};\n}\n\nexport const MsgEditValidatorResponse = {\n  encode(\n    _: MsgEditValidatorResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgEditValidatorResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgEditValidatorResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgEditValidatorResponse {\n    return {};\n  },\n\n  toJSON(_: MsgEditValidatorResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgEditValidatorResponse>, I>>(\n    _: I\n  ): MsgEditValidatorResponse {\n    const message = createBaseMsgEditValidatorResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgDelegate(): MsgDelegate {\n  return { delegatorAddress: \"\", validatorAddress: \"\", amount: undefined };\n}\n\nexport const MsgDelegate = {\n  encode(\n    message: MsgDelegate,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(18).string(message.validatorAddress);\n    }\n    if (message.amount !== undefined) {\n      Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgDelegate {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgDelegate();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorAddress = reader.string();\n          break;\n        case 3:\n          message.amount = Coin.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgDelegate {\n    return {\n      delegatorAddress: isSet(object.delegatorAddress)\n        ? String(object.delegatorAddress)\n        : \"\",\n      validatorAddress: isSet(object.validatorAddress)\n        ? String(object.validatorAddress)\n        : \"\",\n      amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,\n    };\n  },\n\n  toJSON(message: MsgDelegate): unknown {\n    const obj: any = {};\n    message.delegatorAddress !== undefined &&\n      (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorAddress !== undefined &&\n      (obj.validatorAddress = message.validatorAddress);\n    message.amount !== undefined &&\n      (obj.amount = message.amount ? Coin.toJSON(message.amount) : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgDelegate>, I>>(\n    object: I\n  ): MsgDelegate {\n    const message = createBaseMsgDelegate();\n    message.delegatorAddress = object.delegatorAddress ?? \"\";\n    message.validatorAddress = object.validatorAddress ?? \"\";\n    message.amount =\n      object.amount !== undefined && object.amount !== null\n        ? Coin.fromPartial(object.amount)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgDelegateResponse(): MsgDelegateResponse {\n  return {};\n}\n\nexport const MsgDelegateResponse = {\n  encode(\n    _: MsgDelegateResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgDelegateResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgDelegateResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgDelegateResponse {\n    return {};\n  },\n\n  toJSON(_: MsgDelegateResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgDelegateResponse>, I>>(\n    _: I\n  ): MsgDelegateResponse {\n    const message = createBaseMsgDelegateResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgBeginRedelegate(): MsgBeginRedelegate {\n  return {\n    delegatorAddress: \"\",\n    validatorSrcAddress: \"\",\n    validatorDstAddress: \"\",\n    amount: undefined,\n  };\n}\n\nexport const MsgBeginRedelegate = {\n  encode(\n    message: MsgBeginRedelegate,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorSrcAddress !== \"\") {\n      writer.uint32(18).string(message.validatorSrcAddress);\n    }\n    if (message.validatorDstAddress !== \"\") {\n      writer.uint32(26).string(message.validatorDstAddress);\n    }\n    if (message.amount !== undefined) {\n      Coin.encode(message.amount, writer.uint32(34).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgBeginRedelegate {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgBeginRedelegate();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorSrcAddress = reader.string();\n          break;\n        case 3:\n          message.validatorDstAddress = reader.string();\n          break;\n        case 4:\n          message.amount = Coin.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgBeginRedelegate {\n    return {\n      delegatorAddress: isSet(object.delegatorAddress)\n        ? String(object.delegatorAddress)\n        : \"\",\n      validatorSrcAddress: isSet(object.validatorSrcAddress)\n        ? String(object.validatorSrcAddress)\n        : \"\",\n      validatorDstAddress: isSet(object.validatorDstAddress)\n        ? String(object.validatorDstAddress)\n        : \"\",\n      amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,\n    };\n  },\n\n  toJSON(message: MsgBeginRedelegate): unknown {\n    const obj: any = {};\n    message.delegatorAddress !== undefined &&\n      (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorSrcAddress !== undefined &&\n      (obj.validatorSrcAddress = message.validatorSrcAddress);\n    message.validatorDstAddress !== undefined &&\n      (obj.validatorDstAddress = message.validatorDstAddress);\n    message.amount !== undefined &&\n      (obj.amount = message.amount ? Coin.toJSON(message.amount) : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgBeginRedelegate>, I>>(\n    object: I\n  ): MsgBeginRedelegate {\n    const message = createBaseMsgBeginRedelegate();\n    message.delegatorAddress = object.delegatorAddress ?? \"\";\n    message.validatorSrcAddress = object.validatorSrcAddress ?? \"\";\n    message.validatorDstAddress = object.validatorDstAddress ?? \"\";\n    message.amount =\n      object.amount !== undefined && object.amount !== null\n        ? Coin.fromPartial(object.amount)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgBeginRedelegateResponse(): MsgBeginRedelegateResponse {\n  return { completionTime: undefined };\n}\n\nexport const MsgBeginRedelegateResponse = {\n  encode(\n    message: MsgBeginRedelegateResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.completionTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.completionTime),\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgBeginRedelegateResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgBeginRedelegateResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.completionTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgBeginRedelegateResponse {\n    return {\n      completionTime: isSet(object.completionTime)\n        ? fromJsonTimestamp(object.completionTime)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgBeginRedelegateResponse): unknown {\n    const obj: any = {};\n    message.completionTime !== undefined &&\n      (obj.completionTime = message.completionTime.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgBeginRedelegateResponse>, I>>(\n    object: I\n  ): MsgBeginRedelegateResponse {\n    const message = createBaseMsgBeginRedelegateResponse();\n    message.completionTime = object.completionTime ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgUndelegate(): MsgUndelegate {\n  return { delegatorAddress: \"\", validatorAddress: \"\", amount: undefined };\n}\n\nexport const MsgUndelegate = {\n  encode(\n    message: MsgUndelegate,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(18).string(message.validatorAddress);\n    }\n    if (message.amount !== undefined) {\n      Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgUndelegate {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgUndelegate();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorAddress = reader.string();\n          break;\n        case 3:\n          message.amount = Coin.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgUndelegate {\n    return {\n      delegatorAddress: isSet(object.delegatorAddress)\n        ? String(object.delegatorAddress)\n        : \"\",\n      validatorAddress: isSet(object.validatorAddress)\n        ? String(object.validatorAddress)\n        : \"\",\n      amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,\n    };\n  },\n\n  toJSON(message: MsgUndelegate): unknown {\n    const obj: any = {};\n    message.delegatorAddress !== undefined &&\n      (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorAddress !== undefined &&\n      (obj.validatorAddress = message.validatorAddress);\n    message.amount !== undefined &&\n      (obj.amount = message.amount ? Coin.toJSON(message.amount) : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgUndelegate>, I>>(\n    object: I\n  ): MsgUndelegate {\n    const message = createBaseMsgUndelegate();\n    message.delegatorAddress = object.delegatorAddress ?? \"\";\n    message.validatorAddress = object.validatorAddress ?? \"\";\n    message.amount =\n      object.amount !== undefined && object.amount !== null\n        ? Coin.fromPartial(object.amount)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgUndelegateResponse(): MsgUndelegateResponse {\n  return { completionTime: undefined };\n}\n\nexport const MsgUndelegateResponse = {\n  encode(\n    message: MsgUndelegateResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.completionTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.completionTime),\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgUndelegateResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgUndelegateResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.completionTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgUndelegateResponse {\n    return {\n      completionTime: isSet(object.completionTime)\n        ? fromJsonTimestamp(object.completionTime)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgUndelegateResponse): unknown {\n    const obj: any = {};\n    message.completionTime !== undefined &&\n      (obj.completionTime = message.completionTime.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgUndelegateResponse>, I>>(\n    object: I\n  ): MsgUndelegateResponse {\n    const message = createBaseMsgUndelegateResponse();\n    message.completionTime = object.completionTime ?? undefined;\n    return message;\n  },\n};\n\n/** Msg defines the staking Msg service. */\nexport interface Msg {\n  /** CreateValidator defines a method for creating a new validator. */\n  CreateValidator(\n    request: DeepPartial<MsgCreateValidator>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCreateValidatorResponse>;\n  /** EditValidator defines a method for editing an existing validator. */\n  EditValidator(\n    request: DeepPartial<MsgEditValidator>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgEditValidatorResponse>;\n  /**\n   * Delegate defines a method for performing a delegation of coins\n   * from a delegator to a validator.\n   */\n  Delegate(\n    request: DeepPartial<MsgDelegate>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgDelegateResponse>;\n  /**\n   * BeginRedelegate defines a method for performing a redelegation\n   * of coins from a delegator and source validator to a destination validator.\n   */\n  BeginRedelegate(\n    request: DeepPartial<MsgBeginRedelegate>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgBeginRedelegateResponse>;\n  /**\n   * Undelegate defines a method for performing an undelegation from a\n   * delegate and a validator.\n   */\n  Undelegate(\n    request: DeepPartial<MsgUndelegate>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgUndelegateResponse>;\n}\n\nexport class MsgClientImpl implements Msg {\n  private readonly rpc: Rpc;\n\n  constructor(rpc: Rpc) {\n    this.rpc = rpc;\n    this.CreateValidator = this.CreateValidator.bind(this);\n    this.EditValidator = this.EditValidator.bind(this);\n    this.Delegate = this.Delegate.bind(this);\n    this.BeginRedelegate = this.BeginRedelegate.bind(this);\n    this.Undelegate = this.Undelegate.bind(this);\n  }\n\n  CreateValidator(\n    request: DeepPartial<MsgCreateValidator>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCreateValidatorResponse> {\n    return this.rpc.unary(\n      MsgCreateValidatorDesc,\n      MsgCreateValidator.fromPartial(request),\n      metadata\n    );\n  }\n\n  EditValidator(\n    request: DeepPartial<MsgEditValidator>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgEditValidatorResponse> {\n    return this.rpc.unary(\n      MsgEditValidatorDesc,\n      MsgEditValidator.fromPartial(request),\n      metadata\n    );\n  }\n\n  Delegate(\n    request: DeepPartial<MsgDelegate>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgDelegateResponse> {\n    return this.rpc.unary(\n      MsgDelegateDesc,\n      MsgDelegate.fromPartial(request),\n      metadata\n    );\n  }\n\n  BeginRedelegate(\n    request: DeepPartial<MsgBeginRedelegate>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgBeginRedelegateResponse> {\n    return this.rpc.unary(\n      MsgBeginRedelegateDesc,\n      MsgBeginRedelegate.fromPartial(request),\n      metadata\n    );\n  }\n\n  Undelegate(\n    request: DeepPartial<MsgUndelegate>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgUndelegateResponse> {\n    return this.rpc.unary(\n      MsgUndelegateDesc,\n      MsgUndelegate.fromPartial(request),\n      metadata\n    );\n  }\n}\n\nexport const MsgDesc = {\n  serviceName: \"cosmos.staking.v1beta1.Msg\",\n};\n\nexport const MsgCreateValidatorDesc: UnaryMethodDefinitionish = {\n  methodName: \"CreateValidator\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCreateValidator.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCreateValidatorResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgEditValidatorDesc: UnaryMethodDefinitionish = {\n  methodName: \"EditValidator\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgEditValidator.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgEditValidatorResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgDelegateDesc: UnaryMethodDefinitionish = {\n  methodName: \"Delegate\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgDelegate.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgDelegateResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgBeginRedelegateDesc: UnaryMethodDefinitionish = {\n  methodName: \"BeginRedelegate\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgBeginRedelegate.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgBeginRedelegateResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgUndelegateDesc: UnaryMethodDefinitionish = {\n  methodName: \"Undelegate\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgUndelegate.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgUndelegateResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\ninterface UnaryMethodDefinitionishR\n  extends grpc.UnaryMethodDefinition<any, any> {\n  requestStream: any;\n  responseStream: any;\n}\n\ntype UnaryMethodDefinitionish = UnaryMethodDefinitionishR;\n\ninterface Rpc {\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any>;\n}\n\nexport class GrpcWebImpl {\n  private host: string;\n  private options: {\n    transport?: grpc.TransportFactory;\n\n    debug?: boolean;\n    metadata?: grpc.Metadata;\n  };\n\n  constructor(\n    host: string,\n    options: {\n      transport?: grpc.TransportFactory;\n\n      debug?: boolean;\n      metadata?: grpc.Metadata;\n    }\n  ) {\n    this.host = host;\n    this.options = options;\n  }\n\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    _request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any> {\n    const request = { ..._request, ...methodDesc.requestType };\n    const maybeCombinedMetadata =\n      metadata && this.options.metadata\n        ? new BrowserHeaders({\n            ...this.options?.metadata.headersMap,\n            ...metadata?.headersMap,\n          })\n        : metadata || this.options.metadata;\n    return new Promise((resolve, reject) => {\n      grpc.unary(methodDesc, {\n        request,\n        host: this.host,\n        metadata: maybeCombinedMetadata,\n        transport: this.options.transport,\n        debug: this.options.debug,\n        onEnd: function (response) {\n          if (response.status === grpc.Code.OK) {\n            resolve(response.message);\n          } else {\n            const err = new Error(response.statusMessage) as any;\n            err.code = response.status;\n            err.metadata = response.trailers;\n            reject(err);\n          }\n        },\n      });\n    });\n  }\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nfunction toTimestamp(date: Date): Timestamp {\n  const seconds = numberToLong(date.getTime() / 1_000);\n  const nanos = (date.getTime() % 1_000) * 1_000_000;\n  return { seconds, nanos };\n}\n\nfunction fromTimestamp(t: Timestamp): Date {\n  let millis = t.seconds.toNumber() * 1_000;\n  millis += t.nanos / 1_000_000;\n  return new Date(millis);\n}\n\nfunction fromJsonTimestamp(o: any): Date {\n  if (o instanceof Date) {\n    return o;\n  } else if (typeof o === \"string\") {\n    return new Date(o);\n  } else {\n    return fromTimestamp(Timestamp.fromJSON(o));\n  }\n}\n\nfunction numberToLong(number: number) {\n  return Long.fromNumber(number);\n}\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","import { BaseMsg } from './BaseMsg';\nimport {\n  protobufPackage,\n  MsgCreateValidator as MsgCreateValidator_pb,\n  MsgEditValidator as MsgEditValidator_pb,\n  MsgDelegate as MsgDelegate_pb,\n  MsgBeginRedelegate as MsgBeginRedelegate_pb,\n  MsgUndelegate as MsgUndelegate_pb\n} from \"../proto/cosmos/staking/v1beta1/tx\";\nimport {EncodeObject} from \"@cosmjs/proto-signing\";\n\nexport class MsgCreateValidator extends BaseMsg {\n  public protoMsg: MsgCreateValidator_pb;\n  constructor(msg: MsgCreateValidator_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgCreateValidator.typeUrl,\n      value: MsgCreateValidator_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgCreateValidator {\n  export const typeUrl: string = `/${protobufPackage}.MsgCreateValidator`;\n  export const Proto = MsgCreateValidator_pb;\n  export interface Proto extends MsgCreateValidator_pb {}\n}\n\nexport class MsgEditValidator extends BaseMsg {\n  public protoMsg: MsgEditValidator_pb;\n  constructor(msg: MsgEditValidator_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgEditValidator.typeUrl,\n      value: MsgEditValidator_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgEditValidator {\n  export const typeUrl: string = `/${protobufPackage}.MsgEditValidator`;\n  export const Proto = MsgEditValidator_pb;\n  export interface Proto extends MsgEditValidator_pb {}\n}\n\nexport class MsgDelegate extends BaseMsg {\n  public protoMsg: MsgDelegate_pb;\n  constructor(msg: MsgDelegate_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgDelegate.typeUrl,\n      value: MsgDelegate_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgDelegate {\n  export const typeUrl: string = `/${protobufPackage}.MsgDelegate`;\n  export const Proto = MsgDelegate_pb;\n  export interface Proto extends MsgDelegate_pb {}\n}\n\nexport class MsgBeginRedelegate extends BaseMsg {\n  public protoMsg: MsgBeginRedelegate_pb;\n  constructor(msg: MsgBeginRedelegate_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgBeginRedelegate.typeUrl,\n      value: MsgBeginRedelegate_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgBeginRedelegate {\n  export const typeUrl: string = `/${protobufPackage}.MsgBeginRedelegate`;\n  export const Proto = MsgBeginRedelegate_pb;\n  export interface Proto extends MsgBeginRedelegate_pb {}\n}\n\nexport class MsgUndelegate extends BaseMsg {\n  public protoMsg: MsgUndelegate_pb;\n  constructor(msg: MsgUndelegate_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgUndelegate.typeUrl,\n      value: MsgUndelegate_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgUndelegate {\n  export const typeUrl: string = `/${protobufPackage}.MsgUndelegate`;\n  export const Proto = MsgUndelegate_pb;\n  export interface Proto extends MsgUndelegate_pb {}\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport { grpc } from \"@improbable-eng/grpc-web\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { BrowserHeaders } from \"browser-headers\";\nimport { Timestamp } from \"../google/protobuf/timestamp\";\n\nexport const protobufPackage = \"metaoslabs.metaos.swap\";\n\nexport interface MsgCreatePool {\n  creator: string;\n  /** the denom of denom0 in the pool */\n  denom0: string;\n  /** the denom of denom1 in the pool */\n  denom1: string;\n  /** the fee rate for the pool */\n  fee: number;\n  /** the initial square root price of the poo */\n  sqrtPrice: string;\n}\n\nexport interface MsgCreatePoolResponse {}\n\nexport interface MsgCreatePosition {\n  creator: string;\n  /** the denom of token0 in the pool */\n  denom0: string;\n  /** the denom of token1 in the pool */\n  denom1: string;\n  /** the fee rate for the pool */\n  fee: number;\n  /** the price lower bound of the position */\n  tickLower: number;\n  /** the price higher bound of the position */\n  tickUpper: number;\n  /** the desired amount of denom0 in the position */\n  amount0Desired: string;\n  /** the desired amount of denom1 in the position */\n  amount1Desired: string;\n  /** the minimum amount that denom0 needs to add when slippage occurs */\n  amount0Min: string;\n  /** the minimum amount that denom1 needs to add when slippage occurs */\n  amount1Min: string;\n  /** the minted NFT holder address */\n  recipient: string;\n  /** the time by which the transaction must be included to effect the change */\n  deadline?: Date;\n}\n\nexport interface MsgCreatePositionResponse {}\n\nexport interface MsgIncreaseLiquidity {\n  /** the message creator, with tokens paid for the message */\n  creator: string;\n  /** then id of the NFT for which liquidity is being increased */\n  tokenId: string;\n  /** the desired amount of denom0 to be spent */\n  amount0Desired: string;\n  /** the desired amount of denom1 to be spent */\n  amount1Desired: string;\n  /** the minimum amount of denom0 to spend, which serves as a slippage check */\n  amount0Min: string;\n  /** the minimum amount of denom1 to spend, which serves as a slippage check */\n  amount1Min: string;\n  /** the time by which the transaction must be included to effect the change */\n  deadline?: Date;\n}\n\nexport interface MsgIncreaseLiquidityResponse {}\n\nexport interface MsgDecreaseLiquidity {\n  creator: string;\n  /** then id of the NFT for which liquidity is being decreased */\n  tokenId: string;\n  /** the amount by which liquidity will be decreased */\n  liquidity: string;\n  /** the minimum amount of denom0 that should be accounted for the burned liquidity */\n  amount0Min: string;\n  /** the minimum amount of denom1 that should be accounted for the burned liquidity */\n  amount1Min: string;\n  /** the time by which the transaction must be included to effect the change */\n  deadline?: Date;\n}\n\nexport interface MsgDecreaseLiquidityResponse {}\n\nexport interface MsgCollect {\n  creator: string;\n  /** the id of the NFT for which tokens are being collected */\n  tokenId: string;\n  /** the address that should receive the tokens */\n  recipient: string;\n  /** the maximum amount of denom0 to collect */\n  amount0Max: string;\n  /** the maximum amount of denom1 to collect */\n  amount1Max: string;\n  /** whether to get only owed tokens. True means only get the tokens that are owed(less gas), false means trigger settlement first, then collect(more gas) */\n  collectOnly: boolean;\n}\n\nexport interface MsgCollectResponse {}\n\nexport interface MsgSwapExactIn {\n  creator: string;\n  recipient: string;\n  amountIn: string;\n  amountOutMin: string;\n  denoms: string[];\n  fees: number[];\n  deadline?: Date;\n}\n\nexport interface MsgSwapExactInResponse {}\n\nexport interface MsgSwapExactOut {\n  creator: string;\n  recipient: string;\n  amountOut: string;\n  amountInMax: string;\n  denoms: string[];\n  fees: number[];\n  deadline?: Date;\n}\n\nexport interface MsgSwapExactOutResponse {}\n\nexport interface MsgCollectReward {\n  creator: string;\n  /** the id of the NFT for which tokens are being collected */\n  tokenId: string;\n  /** the address that should receive the tokens */\n  recipient: string;\n  /** whether to get only owed tokens. True means only get the tokens that are owed(less gas), false means trigger settlement first, then collect(more gas) */\n  collectOnly: boolean;\n}\n\nexport interface MsgCollectRewardResponse {}\n\nexport interface MsgCollectFeeProtocol {\n  creator: string;\n  /** the pool address */\n  address: string;\n}\n\nexport interface MsgCollectFeeProtocolResponse {}\n\nexport interface MsgGovCorePool {\n  creator: string;\n  address: string;\n  action: string;\n  triggerTime?: Date;\n}\n\nexport interface MsgGovCorePoolResponse {}\n\nfunction createBaseMsgCreatePool(): MsgCreatePool {\n  return { creator: \"\", denom0: \"\", denom1: \"\", fee: 0, sqrtPrice: \"\" };\n}\n\nexport const MsgCreatePool = {\n  encode(\n    message: MsgCreatePool,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.denom0 !== \"\") {\n      writer.uint32(18).string(message.denom0);\n    }\n    if (message.denom1 !== \"\") {\n      writer.uint32(26).string(message.denom1);\n    }\n    if (message.fee !== 0) {\n      writer.uint32(32).int32(message.fee);\n    }\n    if (message.sqrtPrice !== \"\") {\n      writer.uint32(42).string(message.sqrtPrice);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreatePool {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCreatePool();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.denom0 = reader.string();\n          break;\n        case 3:\n          message.denom1 = reader.string();\n          break;\n        case 4:\n          message.fee = reader.int32();\n          break;\n        case 5:\n          message.sqrtPrice = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCreatePool {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      denom0: isSet(object.denom0) ? String(object.denom0) : \"\",\n      denom1: isSet(object.denom1) ? String(object.denom1) : \"\",\n      fee: isSet(object.fee) ? Number(object.fee) : 0,\n      sqrtPrice: isSet(object.sqrtPrice) ? String(object.sqrtPrice) : \"\",\n    };\n  },\n\n  toJSON(message: MsgCreatePool): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.denom0 !== undefined && (obj.denom0 = message.denom0);\n    message.denom1 !== undefined && (obj.denom1 = message.denom1);\n    message.fee !== undefined && (obj.fee = Math.round(message.fee));\n    message.sqrtPrice !== undefined && (obj.sqrtPrice = message.sqrtPrice);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCreatePool>, I>>(\n    object: I\n  ): MsgCreatePool {\n    const message = createBaseMsgCreatePool();\n    message.creator = object.creator ?? \"\";\n    message.denom0 = object.denom0 ?? \"\";\n    message.denom1 = object.denom1 ?? \"\";\n    message.fee = object.fee ?? 0;\n    message.sqrtPrice = object.sqrtPrice ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgCreatePoolResponse(): MsgCreatePoolResponse {\n  return {};\n}\n\nexport const MsgCreatePoolResponse = {\n  encode(\n    _: MsgCreatePoolResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCreatePoolResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCreatePoolResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCreatePoolResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCreatePoolResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCreatePoolResponse>, I>>(\n    _: I\n  ): MsgCreatePoolResponse {\n    const message = createBaseMsgCreatePoolResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgCreatePosition(): MsgCreatePosition {\n  return {\n    creator: \"\",\n    denom0: \"\",\n    denom1: \"\",\n    fee: 0,\n    tickLower: 0,\n    tickUpper: 0,\n    amount0Desired: \"\",\n    amount1Desired: \"\",\n    amount0Min: \"\",\n    amount1Min: \"\",\n    recipient: \"\",\n    deadline: undefined,\n  };\n}\n\nexport const MsgCreatePosition = {\n  encode(\n    message: MsgCreatePosition,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.denom0 !== \"\") {\n      writer.uint32(18).string(message.denom0);\n    }\n    if (message.denom1 !== \"\") {\n      writer.uint32(26).string(message.denom1);\n    }\n    if (message.fee !== 0) {\n      writer.uint32(32).int32(message.fee);\n    }\n    if (message.tickLower !== 0) {\n      writer.uint32(40).int32(message.tickLower);\n    }\n    if (message.tickUpper !== 0) {\n      writer.uint32(48).int32(message.tickUpper);\n    }\n    if (message.amount0Desired !== \"\") {\n      writer.uint32(58).string(message.amount0Desired);\n    }\n    if (message.amount1Desired !== \"\") {\n      writer.uint32(66).string(message.amount1Desired);\n    }\n    if (message.amount0Min !== \"\") {\n      writer.uint32(74).string(message.amount0Min);\n    }\n    if (message.amount1Min !== \"\") {\n      writer.uint32(82).string(message.amount1Min);\n    }\n    if (message.recipient !== \"\") {\n      writer.uint32(90).string(message.recipient);\n    }\n    if (message.deadline !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.deadline),\n        writer.uint32(98).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreatePosition {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCreatePosition();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.denom0 = reader.string();\n          break;\n        case 3:\n          message.denom1 = reader.string();\n          break;\n        case 4:\n          message.fee = reader.int32();\n          break;\n        case 5:\n          message.tickLower = reader.int32();\n          break;\n        case 6:\n          message.tickUpper = reader.int32();\n          break;\n        case 7:\n          message.amount0Desired = reader.string();\n          break;\n        case 8:\n          message.amount1Desired = reader.string();\n          break;\n        case 9:\n          message.amount0Min = reader.string();\n          break;\n        case 10:\n          message.amount1Min = reader.string();\n          break;\n        case 11:\n          message.recipient = reader.string();\n          break;\n        case 12:\n          message.deadline = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCreatePosition {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      denom0: isSet(object.denom0) ? String(object.denom0) : \"\",\n      denom1: isSet(object.denom1) ? String(object.denom1) : \"\",\n      fee: isSet(object.fee) ? Number(object.fee) : 0,\n      tickLower: isSet(object.tickLower) ? Number(object.tickLower) : 0,\n      tickUpper: isSet(object.tickUpper) ? Number(object.tickUpper) : 0,\n      amount0Desired: isSet(object.amount0Desired)\n        ? String(object.amount0Desired)\n        : \"\",\n      amount1Desired: isSet(object.amount1Desired)\n        ? String(object.amount1Desired)\n        : \"\",\n      amount0Min: isSet(object.amount0Min) ? String(object.amount0Min) : \"\",\n      amount1Min: isSet(object.amount1Min) ? String(object.amount1Min) : \"\",\n      recipient: isSet(object.recipient) ? String(object.recipient) : \"\",\n      deadline: isSet(object.deadline)\n        ? fromJsonTimestamp(object.deadline)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgCreatePosition): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.denom0 !== undefined && (obj.denom0 = message.denom0);\n    message.denom1 !== undefined && (obj.denom1 = message.denom1);\n    message.fee !== undefined && (obj.fee = Math.round(message.fee));\n    message.tickLower !== undefined &&\n      (obj.tickLower = Math.round(message.tickLower));\n    message.tickUpper !== undefined &&\n      (obj.tickUpper = Math.round(message.tickUpper));\n    message.amount0Desired !== undefined &&\n      (obj.amount0Desired = message.amount0Desired);\n    message.amount1Desired !== undefined &&\n      (obj.amount1Desired = message.amount1Desired);\n    message.amount0Min !== undefined && (obj.amount0Min = message.amount0Min);\n    message.amount1Min !== undefined && (obj.amount1Min = message.amount1Min);\n    message.recipient !== undefined && (obj.recipient = message.recipient);\n    message.deadline !== undefined &&\n      (obj.deadline = message.deadline.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCreatePosition>, I>>(\n    object: I\n  ): MsgCreatePosition {\n    const message = createBaseMsgCreatePosition();\n    message.creator = object.creator ?? \"\";\n    message.denom0 = object.denom0 ?? \"\";\n    message.denom1 = object.denom1 ?? \"\";\n    message.fee = object.fee ?? 0;\n    message.tickLower = object.tickLower ?? 0;\n    message.tickUpper = object.tickUpper ?? 0;\n    message.amount0Desired = object.amount0Desired ?? \"\";\n    message.amount1Desired = object.amount1Desired ?? \"\";\n    message.amount0Min = object.amount0Min ?? \"\";\n    message.amount1Min = object.amount1Min ?? \"\";\n    message.recipient = object.recipient ?? \"\";\n    message.deadline = object.deadline ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgCreatePositionResponse(): MsgCreatePositionResponse {\n  return {};\n}\n\nexport const MsgCreatePositionResponse = {\n  encode(\n    _: MsgCreatePositionResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCreatePositionResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCreatePositionResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCreatePositionResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCreatePositionResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCreatePositionResponse>, I>>(\n    _: I\n  ): MsgCreatePositionResponse {\n    const message = createBaseMsgCreatePositionResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgIncreaseLiquidity(): MsgIncreaseLiquidity {\n  return {\n    creator: \"\",\n    tokenId: \"\",\n    amount0Desired: \"\",\n    amount1Desired: \"\",\n    amount0Min: \"\",\n    amount1Min: \"\",\n    deadline: undefined,\n  };\n}\n\nexport const MsgIncreaseLiquidity = {\n  encode(\n    message: MsgIncreaseLiquidity,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.tokenId !== \"\") {\n      writer.uint32(18).string(message.tokenId);\n    }\n    if (message.amount0Desired !== \"\") {\n      writer.uint32(26).string(message.amount0Desired);\n    }\n    if (message.amount1Desired !== \"\") {\n      writer.uint32(34).string(message.amount1Desired);\n    }\n    if (message.amount0Min !== \"\") {\n      writer.uint32(42).string(message.amount0Min);\n    }\n    if (message.amount1Min !== \"\") {\n      writer.uint32(50).string(message.amount1Min);\n    }\n    if (message.deadline !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.deadline),\n        writer.uint32(58).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgIncreaseLiquidity {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgIncreaseLiquidity();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.tokenId = reader.string();\n          break;\n        case 3:\n          message.amount0Desired = reader.string();\n          break;\n        case 4:\n          message.amount1Desired = reader.string();\n          break;\n        case 5:\n          message.amount0Min = reader.string();\n          break;\n        case 6:\n          message.amount1Min = reader.string();\n          break;\n        case 7:\n          message.deadline = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgIncreaseLiquidity {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      tokenId: isSet(object.tokenId) ? String(object.tokenId) : \"\",\n      amount0Desired: isSet(object.amount0Desired)\n        ? String(object.amount0Desired)\n        : \"\",\n      amount1Desired: isSet(object.amount1Desired)\n        ? String(object.amount1Desired)\n        : \"\",\n      amount0Min: isSet(object.amount0Min) ? String(object.amount0Min) : \"\",\n      amount1Min: isSet(object.amount1Min) ? String(object.amount1Min) : \"\",\n      deadline: isSet(object.deadline)\n        ? fromJsonTimestamp(object.deadline)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgIncreaseLiquidity): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.tokenId !== undefined && (obj.tokenId = message.tokenId);\n    message.amount0Desired !== undefined &&\n      (obj.amount0Desired = message.amount0Desired);\n    message.amount1Desired !== undefined &&\n      (obj.amount1Desired = message.amount1Desired);\n    message.amount0Min !== undefined && (obj.amount0Min = message.amount0Min);\n    message.amount1Min !== undefined && (obj.amount1Min = message.amount1Min);\n    message.deadline !== undefined &&\n      (obj.deadline = message.deadline.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgIncreaseLiquidity>, I>>(\n    object: I\n  ): MsgIncreaseLiquidity {\n    const message = createBaseMsgIncreaseLiquidity();\n    message.creator = object.creator ?? \"\";\n    message.tokenId = object.tokenId ?? \"\";\n    message.amount0Desired = object.amount0Desired ?? \"\";\n    message.amount1Desired = object.amount1Desired ?? \"\";\n    message.amount0Min = object.amount0Min ?? \"\";\n    message.amount1Min = object.amount1Min ?? \"\";\n    message.deadline = object.deadline ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgIncreaseLiquidityResponse(): MsgIncreaseLiquidityResponse {\n  return {};\n}\n\nexport const MsgIncreaseLiquidityResponse = {\n  encode(\n    _: MsgIncreaseLiquidityResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgIncreaseLiquidityResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgIncreaseLiquidityResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgIncreaseLiquidityResponse {\n    return {};\n  },\n\n  toJSON(_: MsgIncreaseLiquidityResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgIncreaseLiquidityResponse>, I>>(\n    _: I\n  ): MsgIncreaseLiquidityResponse {\n    const message = createBaseMsgIncreaseLiquidityResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgDecreaseLiquidity(): MsgDecreaseLiquidity {\n  return {\n    creator: \"\",\n    tokenId: \"\",\n    liquidity: \"\",\n    amount0Min: \"\",\n    amount1Min: \"\",\n    deadline: undefined,\n  };\n}\n\nexport const MsgDecreaseLiquidity = {\n  encode(\n    message: MsgDecreaseLiquidity,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.tokenId !== \"\") {\n      writer.uint32(18).string(message.tokenId);\n    }\n    if (message.liquidity !== \"\") {\n      writer.uint32(26).string(message.liquidity);\n    }\n    if (message.amount0Min !== \"\") {\n      writer.uint32(34).string(message.amount0Min);\n    }\n    if (message.amount1Min !== \"\") {\n      writer.uint32(42).string(message.amount1Min);\n    }\n    if (message.deadline !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.deadline),\n        writer.uint32(50).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgDecreaseLiquidity {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgDecreaseLiquidity();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.tokenId = reader.string();\n          break;\n        case 3:\n          message.liquidity = reader.string();\n          break;\n        case 4:\n          message.amount0Min = reader.string();\n          break;\n        case 5:\n          message.amount1Min = reader.string();\n          break;\n        case 6:\n          message.deadline = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgDecreaseLiquidity {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      tokenId: isSet(object.tokenId) ? String(object.tokenId) : \"\",\n      liquidity: isSet(object.liquidity) ? String(object.liquidity) : \"\",\n      amount0Min: isSet(object.amount0Min) ? String(object.amount0Min) : \"\",\n      amount1Min: isSet(object.amount1Min) ? String(object.amount1Min) : \"\",\n      deadline: isSet(object.deadline)\n        ? fromJsonTimestamp(object.deadline)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgDecreaseLiquidity): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.tokenId !== undefined && (obj.tokenId = message.tokenId);\n    message.liquidity !== undefined && (obj.liquidity = message.liquidity);\n    message.amount0Min !== undefined && (obj.amount0Min = message.amount0Min);\n    message.amount1Min !== undefined && (obj.amount1Min = message.amount1Min);\n    message.deadline !== undefined &&\n      (obj.deadline = message.deadline.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgDecreaseLiquidity>, I>>(\n    object: I\n  ): MsgDecreaseLiquidity {\n    const message = createBaseMsgDecreaseLiquidity();\n    message.creator = object.creator ?? \"\";\n    message.tokenId = object.tokenId ?? \"\";\n    message.liquidity = object.liquidity ?? \"\";\n    message.amount0Min = object.amount0Min ?? \"\";\n    message.amount1Min = object.amount1Min ?? \"\";\n    message.deadline = object.deadline ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgDecreaseLiquidityResponse(): MsgDecreaseLiquidityResponse {\n  return {};\n}\n\nexport const MsgDecreaseLiquidityResponse = {\n  encode(\n    _: MsgDecreaseLiquidityResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgDecreaseLiquidityResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgDecreaseLiquidityResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgDecreaseLiquidityResponse {\n    return {};\n  },\n\n  toJSON(_: MsgDecreaseLiquidityResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgDecreaseLiquidityResponse>, I>>(\n    _: I\n  ): MsgDecreaseLiquidityResponse {\n    const message = createBaseMsgDecreaseLiquidityResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgCollect(): MsgCollect {\n  return {\n    creator: \"\",\n    tokenId: \"\",\n    recipient: \"\",\n    amount0Max: \"\",\n    amount1Max: \"\",\n    collectOnly: false,\n  };\n}\n\nexport const MsgCollect = {\n  encode(\n    message: MsgCollect,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.tokenId !== \"\") {\n      writer.uint32(18).string(message.tokenId);\n    }\n    if (message.recipient !== \"\") {\n      writer.uint32(26).string(message.recipient);\n    }\n    if (message.amount0Max !== \"\") {\n      writer.uint32(34).string(message.amount0Max);\n    }\n    if (message.amount1Max !== \"\") {\n      writer.uint32(42).string(message.amount1Max);\n    }\n    if (message.collectOnly === true) {\n      writer.uint32(48).bool(message.collectOnly);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCollect {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCollect();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.tokenId = reader.string();\n          break;\n        case 3:\n          message.recipient = reader.string();\n          break;\n        case 4:\n          message.amount0Max = reader.string();\n          break;\n        case 5:\n          message.amount1Max = reader.string();\n          break;\n        case 6:\n          message.collectOnly = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCollect {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      tokenId: isSet(object.tokenId) ? String(object.tokenId) : \"\",\n      recipient: isSet(object.recipient) ? String(object.recipient) : \"\",\n      amount0Max: isSet(object.amount0Max) ? String(object.amount0Max) : \"\",\n      amount1Max: isSet(object.amount1Max) ? String(object.amount1Max) : \"\",\n      collectOnly: isSet(object.collectOnly)\n        ? Boolean(object.collectOnly)\n        : false,\n    };\n  },\n\n  toJSON(message: MsgCollect): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.tokenId !== undefined && (obj.tokenId = message.tokenId);\n    message.recipient !== undefined && (obj.recipient = message.recipient);\n    message.amount0Max !== undefined && (obj.amount0Max = message.amount0Max);\n    message.amount1Max !== undefined && (obj.amount1Max = message.amount1Max);\n    message.collectOnly !== undefined &&\n      (obj.collectOnly = message.collectOnly);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCollect>, I>>(\n    object: I\n  ): MsgCollect {\n    const message = createBaseMsgCollect();\n    message.creator = object.creator ?? \"\";\n    message.tokenId = object.tokenId ?? \"\";\n    message.recipient = object.recipient ?? \"\";\n    message.amount0Max = object.amount0Max ?? \"\";\n    message.amount1Max = object.amount1Max ?? \"\";\n    message.collectOnly = object.collectOnly ?? false;\n    return message;\n  },\n};\n\nfunction createBaseMsgCollectResponse(): MsgCollectResponse {\n  return {};\n}\n\nexport const MsgCollectResponse = {\n  encode(\n    _: MsgCollectResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCollectResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCollectResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCollectResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCollectResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCollectResponse>, I>>(\n    _: I\n  ): MsgCollectResponse {\n    const message = createBaseMsgCollectResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgSwapExactIn(): MsgSwapExactIn {\n  return {\n    creator: \"\",\n    recipient: \"\",\n    amountIn: \"\",\n    amountOutMin: \"\",\n    denoms: [],\n    fees: [],\n    deadline: undefined,\n  };\n}\n\nexport const MsgSwapExactIn = {\n  encode(\n    message: MsgSwapExactIn,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.recipient !== \"\") {\n      writer.uint32(18).string(message.recipient);\n    }\n    if (message.amountIn !== \"\") {\n      writer.uint32(26).string(message.amountIn);\n    }\n    if (message.amountOutMin !== \"\") {\n      writer.uint32(34).string(message.amountOutMin);\n    }\n    for (const v of message.denoms) {\n      writer.uint32(42).string(v!);\n    }\n    writer.uint32(50).fork();\n    for (const v of message.fees) {\n      writer.int32(v);\n    }\n    writer.ldelim();\n    if (message.deadline !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.deadline),\n        writer.uint32(58).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSwapExactIn {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgSwapExactIn();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.recipient = reader.string();\n          break;\n        case 3:\n          message.amountIn = reader.string();\n          break;\n        case 4:\n          message.amountOutMin = reader.string();\n          break;\n        case 5:\n          message.denoms.push(reader.string());\n          break;\n        case 6:\n          if ((tag & 7) === 2) {\n            const end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.fees.push(reader.int32());\n            }\n          } else {\n            message.fees.push(reader.int32());\n          }\n          break;\n        case 7:\n          message.deadline = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgSwapExactIn {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      recipient: isSet(object.recipient) ? String(object.recipient) : \"\",\n      amountIn: isSet(object.amountIn) ? String(object.amountIn) : \"\",\n      amountOutMin: isSet(object.amountOutMin)\n        ? String(object.amountOutMin)\n        : \"\",\n      denoms: Array.isArray(object?.denoms)\n        ? object.denoms.map((e: any) => String(e))\n        : [],\n      fees: Array.isArray(object?.fees)\n        ? object.fees.map((e: any) => Number(e))\n        : [],\n      deadline: isSet(object.deadline)\n        ? fromJsonTimestamp(object.deadline)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgSwapExactIn): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.recipient !== undefined && (obj.recipient = message.recipient);\n    message.amountIn !== undefined && (obj.amountIn = message.amountIn);\n    message.amountOutMin !== undefined &&\n      (obj.amountOutMin = message.amountOutMin);\n    if (message.denoms) {\n      obj.denoms = message.denoms.map((e) => e);\n    } else {\n      obj.denoms = [];\n    }\n    if (message.fees) {\n      obj.fees = message.fees.map((e) => Math.round(e));\n    } else {\n      obj.fees = [];\n    }\n    message.deadline !== undefined &&\n      (obj.deadline = message.deadline.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgSwapExactIn>, I>>(\n    object: I\n  ): MsgSwapExactIn {\n    const message = createBaseMsgSwapExactIn();\n    message.creator = object.creator ?? \"\";\n    message.recipient = object.recipient ?? \"\";\n    message.amountIn = object.amountIn ?? \"\";\n    message.amountOutMin = object.amountOutMin ?? \"\";\n    message.denoms = object.denoms?.map((e) => e) || [];\n    message.fees = object.fees?.map((e) => e) || [];\n    message.deadline = object.deadline ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgSwapExactInResponse(): MsgSwapExactInResponse {\n  return {};\n}\n\nexport const MsgSwapExactInResponse = {\n  encode(\n    _: MsgSwapExactInResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgSwapExactInResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgSwapExactInResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgSwapExactInResponse {\n    return {};\n  },\n\n  toJSON(_: MsgSwapExactInResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgSwapExactInResponse>, I>>(\n    _: I\n  ): MsgSwapExactInResponse {\n    const message = createBaseMsgSwapExactInResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgSwapExactOut(): MsgSwapExactOut {\n  return {\n    creator: \"\",\n    recipient: \"\",\n    amountOut: \"\",\n    amountInMax: \"\",\n    denoms: [],\n    fees: [],\n    deadline: undefined,\n  };\n}\n\nexport const MsgSwapExactOut = {\n  encode(\n    message: MsgSwapExactOut,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.recipient !== \"\") {\n      writer.uint32(18).string(message.recipient);\n    }\n    if (message.amountOut !== \"\") {\n      writer.uint32(26).string(message.amountOut);\n    }\n    if (message.amountInMax !== \"\") {\n      writer.uint32(34).string(message.amountInMax);\n    }\n    for (const v of message.denoms) {\n      writer.uint32(42).string(v!);\n    }\n    writer.uint32(50).fork();\n    for (const v of message.fees) {\n      writer.int32(v);\n    }\n    writer.ldelim();\n    if (message.deadline !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.deadline),\n        writer.uint32(58).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSwapExactOut {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgSwapExactOut();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.recipient = reader.string();\n          break;\n        case 3:\n          message.amountOut = reader.string();\n          break;\n        case 4:\n          message.amountInMax = reader.string();\n          break;\n        case 5:\n          message.denoms.push(reader.string());\n          break;\n        case 6:\n          if ((tag & 7) === 2) {\n            const end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.fees.push(reader.int32());\n            }\n          } else {\n            message.fees.push(reader.int32());\n          }\n          break;\n        case 7:\n          message.deadline = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgSwapExactOut {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      recipient: isSet(object.recipient) ? String(object.recipient) : \"\",\n      amountOut: isSet(object.amountOut) ? String(object.amountOut) : \"\",\n      amountInMax: isSet(object.amountInMax) ? String(object.amountInMax) : \"\",\n      denoms: Array.isArray(object?.denoms)\n        ? object.denoms.map((e: any) => String(e))\n        : [],\n      fees: Array.isArray(object?.fees)\n        ? object.fees.map((e: any) => Number(e))\n        : [],\n      deadline: isSet(object.deadline)\n        ? fromJsonTimestamp(object.deadline)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgSwapExactOut): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.recipient !== undefined && (obj.recipient = message.recipient);\n    message.amountOut !== undefined && (obj.amountOut = message.amountOut);\n    message.amountInMax !== undefined &&\n      (obj.amountInMax = message.amountInMax);\n    if (message.denoms) {\n      obj.denoms = message.denoms.map((e) => e);\n    } else {\n      obj.denoms = [];\n    }\n    if (message.fees) {\n      obj.fees = message.fees.map((e) => Math.round(e));\n    } else {\n      obj.fees = [];\n    }\n    message.deadline !== undefined &&\n      (obj.deadline = message.deadline.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgSwapExactOut>, I>>(\n    object: I\n  ): MsgSwapExactOut {\n    const message = createBaseMsgSwapExactOut();\n    message.creator = object.creator ?? \"\";\n    message.recipient = object.recipient ?? \"\";\n    message.amountOut = object.amountOut ?? \"\";\n    message.amountInMax = object.amountInMax ?? \"\";\n    message.denoms = object.denoms?.map((e) => e) || [];\n    message.fees = object.fees?.map((e) => e) || [];\n    message.deadline = object.deadline ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgSwapExactOutResponse(): MsgSwapExactOutResponse {\n  return {};\n}\n\nexport const MsgSwapExactOutResponse = {\n  encode(\n    _: MsgSwapExactOutResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgSwapExactOutResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgSwapExactOutResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgSwapExactOutResponse {\n    return {};\n  },\n\n  toJSON(_: MsgSwapExactOutResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgSwapExactOutResponse>, I>>(\n    _: I\n  ): MsgSwapExactOutResponse {\n    const message = createBaseMsgSwapExactOutResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgCollectReward(): MsgCollectReward {\n  return { creator: \"\", tokenId: \"\", recipient: \"\", collectOnly: false };\n}\n\nexport const MsgCollectReward = {\n  encode(\n    message: MsgCollectReward,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.tokenId !== \"\") {\n      writer.uint32(18).string(message.tokenId);\n    }\n    if (message.recipient !== \"\") {\n      writer.uint32(26).string(message.recipient);\n    }\n    if (message.collectOnly === true) {\n      writer.uint32(32).bool(message.collectOnly);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCollectReward {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCollectReward();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.tokenId = reader.string();\n          break;\n        case 3:\n          message.recipient = reader.string();\n          break;\n        case 4:\n          message.collectOnly = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCollectReward {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      tokenId: isSet(object.tokenId) ? String(object.tokenId) : \"\",\n      recipient: isSet(object.recipient) ? String(object.recipient) : \"\",\n      collectOnly: isSet(object.collectOnly)\n        ? Boolean(object.collectOnly)\n        : false,\n    };\n  },\n\n  toJSON(message: MsgCollectReward): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.tokenId !== undefined && (obj.tokenId = message.tokenId);\n    message.recipient !== undefined && (obj.recipient = message.recipient);\n    message.collectOnly !== undefined &&\n      (obj.collectOnly = message.collectOnly);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCollectReward>, I>>(\n    object: I\n  ): MsgCollectReward {\n    const message = createBaseMsgCollectReward();\n    message.creator = object.creator ?? \"\";\n    message.tokenId = object.tokenId ?? \"\";\n    message.recipient = object.recipient ?? \"\";\n    message.collectOnly = object.collectOnly ?? false;\n    return message;\n  },\n};\n\nfunction createBaseMsgCollectRewardResponse(): MsgCollectRewardResponse {\n  return {};\n}\n\nexport const MsgCollectRewardResponse = {\n  encode(\n    _: MsgCollectRewardResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCollectRewardResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCollectRewardResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCollectRewardResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCollectRewardResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCollectRewardResponse>, I>>(\n    _: I\n  ): MsgCollectRewardResponse {\n    const message = createBaseMsgCollectRewardResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgCollectFeeProtocol(): MsgCollectFeeProtocol {\n  return { creator: \"\", address: \"\" };\n}\n\nexport const MsgCollectFeeProtocol = {\n  encode(\n    message: MsgCollectFeeProtocol,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.address !== \"\") {\n      writer.uint32(18).string(message.address);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCollectFeeProtocol {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCollectFeeProtocol();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.address = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCollectFeeProtocol {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      address: isSet(object.address) ? String(object.address) : \"\",\n    };\n  },\n\n  toJSON(message: MsgCollectFeeProtocol): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.address !== undefined && (obj.address = message.address);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCollectFeeProtocol>, I>>(\n    object: I\n  ): MsgCollectFeeProtocol {\n    const message = createBaseMsgCollectFeeProtocol();\n    message.creator = object.creator ?? \"\";\n    message.address = object.address ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgCollectFeeProtocolResponse(): MsgCollectFeeProtocolResponse {\n  return {};\n}\n\nexport const MsgCollectFeeProtocolResponse = {\n  encode(\n    _: MsgCollectFeeProtocolResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCollectFeeProtocolResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCollectFeeProtocolResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCollectFeeProtocolResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCollectFeeProtocolResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCollectFeeProtocolResponse>, I>>(\n    _: I\n  ): MsgCollectFeeProtocolResponse {\n    const message = createBaseMsgCollectFeeProtocolResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgGovCorePool(): MsgGovCorePool {\n  return { creator: \"\", address: \"\", action: \"\", triggerTime: undefined };\n}\n\nexport const MsgGovCorePool = {\n  encode(\n    message: MsgGovCorePool,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.address !== \"\") {\n      writer.uint32(18).string(message.address);\n    }\n    if (message.action !== \"\") {\n      writer.uint32(26).string(message.action);\n    }\n    if (message.triggerTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.triggerTime),\n        writer.uint32(34).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgGovCorePool {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgGovCorePool();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.address = reader.string();\n          break;\n        case 3:\n          message.action = reader.string();\n          break;\n        case 4:\n          message.triggerTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgGovCorePool {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      address: isSet(object.address) ? String(object.address) : \"\",\n      action: isSet(object.action) ? String(object.action) : \"\",\n      triggerTime: isSet(object.triggerTime)\n        ? fromJsonTimestamp(object.triggerTime)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgGovCorePool): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.address !== undefined && (obj.address = message.address);\n    message.action !== undefined && (obj.action = message.action);\n    message.triggerTime !== undefined &&\n      (obj.triggerTime = message.triggerTime.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgGovCorePool>, I>>(\n    object: I\n  ): MsgGovCorePool {\n    const message = createBaseMsgGovCorePool();\n    message.creator = object.creator ?? \"\";\n    message.address = object.address ?? \"\";\n    message.action = object.action ?? \"\";\n    message.triggerTime = object.triggerTime ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgGovCorePoolResponse(): MsgGovCorePoolResponse {\n  return {};\n}\n\nexport const MsgGovCorePoolResponse = {\n  encode(\n    _: MsgGovCorePoolResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgGovCorePoolResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgGovCorePoolResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgGovCorePoolResponse {\n    return {};\n  },\n\n  toJSON(_: MsgGovCorePoolResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgGovCorePoolResponse>, I>>(\n    _: I\n  ): MsgGovCorePoolResponse {\n    const message = createBaseMsgGovCorePoolResponse();\n    return message;\n  },\n};\n\n/** Msg defines the Msg service. */\nexport interface Msg {\n  CreatePool(\n    request: DeepPartial<MsgCreatePool>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCreatePoolResponse>;\n  CreatePosition(\n    request: DeepPartial<MsgCreatePosition>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCreatePositionResponse>;\n  IncreaseLiquidity(\n    request: DeepPartial<MsgIncreaseLiquidity>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgIncreaseLiquidityResponse>;\n  DecreaseLiquidity(\n    request: DeepPartial<MsgDecreaseLiquidity>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgDecreaseLiquidityResponse>;\n  Collect(\n    request: DeepPartial<MsgCollect>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCollectResponse>;\n  SwapExactIn(\n    request: DeepPartial<MsgSwapExactIn>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgSwapExactInResponse>;\n  SwapExactOut(\n    request: DeepPartial<MsgSwapExactOut>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgSwapExactOutResponse>;\n  CollectReward(\n    request: DeepPartial<MsgCollectReward>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCollectRewardResponse>;\n  CollectFeeProtocol(\n    request: DeepPartial<MsgCollectFeeProtocol>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCollectFeeProtocolResponse>;\n  /** this line is used by starport scaffolding # proto/tx/rpc */\n  GovCorePool(\n    request: DeepPartial<MsgGovCorePool>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgGovCorePoolResponse>;\n}\n\nexport class MsgClientImpl implements Msg {\n  private readonly rpc: Rpc;\n\n  constructor(rpc: Rpc) {\n    this.rpc = rpc;\n    this.CreatePool = this.CreatePool.bind(this);\n    this.CreatePosition = this.CreatePosition.bind(this);\n    this.IncreaseLiquidity = this.IncreaseLiquidity.bind(this);\n    this.DecreaseLiquidity = this.DecreaseLiquidity.bind(this);\n    this.Collect = this.Collect.bind(this);\n    this.SwapExactIn = this.SwapExactIn.bind(this);\n    this.SwapExactOut = this.SwapExactOut.bind(this);\n    this.CollectReward = this.CollectReward.bind(this);\n    this.CollectFeeProtocol = this.CollectFeeProtocol.bind(this);\n    this.GovCorePool = this.GovCorePool.bind(this);\n  }\n\n  CreatePool(\n    request: DeepPartial<MsgCreatePool>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCreatePoolResponse> {\n    return this.rpc.unary(\n      MsgCreatePoolDesc,\n      MsgCreatePool.fromPartial(request),\n      metadata\n    );\n  }\n\n  CreatePosition(\n    request: DeepPartial<MsgCreatePosition>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCreatePositionResponse> {\n    return this.rpc.unary(\n      MsgCreatePositionDesc,\n      MsgCreatePosition.fromPartial(request),\n      metadata\n    );\n  }\n\n  IncreaseLiquidity(\n    request: DeepPartial<MsgIncreaseLiquidity>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgIncreaseLiquidityResponse> {\n    return this.rpc.unary(\n      MsgIncreaseLiquidityDesc,\n      MsgIncreaseLiquidity.fromPartial(request),\n      metadata\n    );\n  }\n\n  DecreaseLiquidity(\n    request: DeepPartial<MsgDecreaseLiquidity>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgDecreaseLiquidityResponse> {\n    return this.rpc.unary(\n      MsgDecreaseLiquidityDesc,\n      MsgDecreaseLiquidity.fromPartial(request),\n      metadata\n    );\n  }\n\n  Collect(\n    request: DeepPartial<MsgCollect>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCollectResponse> {\n    return this.rpc.unary(\n      MsgCollectDesc,\n      MsgCollect.fromPartial(request),\n      metadata\n    );\n  }\n\n  SwapExactIn(\n    request: DeepPartial<MsgSwapExactIn>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgSwapExactInResponse> {\n    return this.rpc.unary(\n      MsgSwapExactInDesc,\n      MsgSwapExactIn.fromPartial(request),\n      metadata\n    );\n  }\n\n  SwapExactOut(\n    request: DeepPartial<MsgSwapExactOut>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgSwapExactOutResponse> {\n    return this.rpc.unary(\n      MsgSwapExactOutDesc,\n      MsgSwapExactOut.fromPartial(request),\n      metadata\n    );\n  }\n\n  CollectReward(\n    request: DeepPartial<MsgCollectReward>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCollectRewardResponse> {\n    return this.rpc.unary(\n      MsgCollectRewardDesc,\n      MsgCollectReward.fromPartial(request),\n      metadata\n    );\n  }\n\n  CollectFeeProtocol(\n    request: DeepPartial<MsgCollectFeeProtocol>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCollectFeeProtocolResponse> {\n    return this.rpc.unary(\n      MsgCollectFeeProtocolDesc,\n      MsgCollectFeeProtocol.fromPartial(request),\n      metadata\n    );\n  }\n\n  GovCorePool(\n    request: DeepPartial<MsgGovCorePool>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgGovCorePoolResponse> {\n    return this.rpc.unary(\n      MsgGovCorePoolDesc,\n      MsgGovCorePool.fromPartial(request),\n      metadata\n    );\n  }\n}\n\nexport const MsgDesc = {\n  serviceName: \"metaoslabs.metaos.swap.Msg\",\n};\n\nexport const MsgCreatePoolDesc: UnaryMethodDefinitionish = {\n  methodName: \"CreatePool\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCreatePool.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCreatePoolResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgCreatePositionDesc: UnaryMethodDefinitionish = {\n  methodName: \"CreatePosition\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCreatePosition.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCreatePositionResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgIncreaseLiquidityDesc: UnaryMethodDefinitionish = {\n  methodName: \"IncreaseLiquidity\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgIncreaseLiquidity.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgIncreaseLiquidityResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgDecreaseLiquidityDesc: UnaryMethodDefinitionish = {\n  methodName: \"DecreaseLiquidity\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgDecreaseLiquidity.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgDecreaseLiquidityResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgCollectDesc: UnaryMethodDefinitionish = {\n  methodName: \"Collect\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCollect.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCollectResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgSwapExactInDesc: UnaryMethodDefinitionish = {\n  methodName: \"SwapExactIn\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgSwapExactIn.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgSwapExactInResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgSwapExactOutDesc: UnaryMethodDefinitionish = {\n  methodName: \"SwapExactOut\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgSwapExactOut.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgSwapExactOutResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgCollectRewardDesc: UnaryMethodDefinitionish = {\n  methodName: \"CollectReward\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCollectReward.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCollectRewardResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgCollectFeeProtocolDesc: UnaryMethodDefinitionish = {\n  methodName: \"CollectFeeProtocol\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCollectFeeProtocol.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCollectFeeProtocolResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgGovCorePoolDesc: UnaryMethodDefinitionish = {\n  methodName: \"GovCorePool\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgGovCorePool.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgGovCorePoolResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\ninterface UnaryMethodDefinitionishR\n  extends grpc.UnaryMethodDefinition<any, any> {\n  requestStream: any;\n  responseStream: any;\n}\n\ntype UnaryMethodDefinitionish = UnaryMethodDefinitionishR;\n\ninterface Rpc {\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any>;\n}\n\nexport class GrpcWebImpl {\n  private host: string;\n  private options: {\n    transport?: grpc.TransportFactory;\n\n    debug?: boolean;\n    metadata?: grpc.Metadata;\n  };\n\n  constructor(\n    host: string,\n    options: {\n      transport?: grpc.TransportFactory;\n\n      debug?: boolean;\n      metadata?: grpc.Metadata;\n    }\n  ) {\n    this.host = host;\n    this.options = options;\n  }\n\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    _request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any> {\n    const request = { ..._request, ...methodDesc.requestType };\n    const maybeCombinedMetadata =\n      metadata && this.options.metadata\n        ? new BrowserHeaders({\n            ...this.options?.metadata.headersMap,\n            ...metadata?.headersMap,\n          })\n        : metadata || this.options.metadata;\n    return new Promise((resolve, reject) => {\n      grpc.unary(methodDesc, {\n        request,\n        host: this.host,\n        metadata: maybeCombinedMetadata,\n        transport: this.options.transport,\n        debug: this.options.debug,\n        onEnd: function (response) {\n          if (response.status === grpc.Code.OK) {\n            resolve(response.message);\n          } else {\n            const err = new Error(response.statusMessage) as any;\n            err.code = response.status;\n            err.metadata = response.trailers;\n            reject(err);\n          }\n        },\n      });\n    });\n  }\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nfunction toTimestamp(date: Date): Timestamp {\n  const seconds = numberToLong(date.getTime() / 1_000);\n  const nanos = (date.getTime() % 1_000) * 1_000_000;\n  return { seconds, nanos };\n}\n\nfunction fromTimestamp(t: Timestamp): Date {\n  let millis = t.seconds.toNumber() * 1_000;\n  millis += t.nanos / 1_000_000;\n  return new Date(millis);\n}\n\nfunction fromJsonTimestamp(o: any): Date {\n  if (o instanceof Date) {\n    return o;\n  } else if (typeof o === \"string\") {\n    return new Date(o);\n  } else {\n    return fromTimestamp(Timestamp.fromJSON(o));\n  }\n}\n\nfunction numberToLong(number: number) {\n  return Long.fromNumber(number);\n}\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","import {\n  protobufPackage,\n  MsgCreatePool as MsgCreatePool_pb,\n  MsgCreatePosition as MsgCreatePosition_pb,\n  MsgIncreaseLiquidity as MsgIncreaseLiquidity_pb,\n  MsgDecreaseLiquidity as MsgDecreaseLiquidity_pb,\n  MsgCollect as MsgCollect_pb,\n  MsgCollectReward as MsgCollectReward_pb,\n  MsgSwapExactIn as MsgSwapExactIn_pb,\n  MsgSwapExactOut as MsgSwapExactOut_pb,\n  MsgCollectFeeProtocol as MsgCollectFeeProtocol_pb,\n  MsgGovCorePool as MsgGovCorePool_pb,\n} from \"../proto/swap/tx\";\nimport { BaseMsg } from \"./BaseMsg\";\nimport { EncodeObject } from \"@cosmjs/proto-signing\";\n\nexport class MsgCollectReward extends BaseMsg {\n  public protoMsg: MsgCollectReward_pb;\n  constructor(msg: MsgCollectReward_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgCollectReward.typeUrl,\n      value: MsgCollectReward_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgCollectReward {\n  export const typeUrl: string = `/${protobufPackage}.MsgCollectReward`;\n  export const Proto = MsgCollectReward_pb;\n  export interface Proto extends MsgCollectReward_pb {}\n}\n\nexport class MsgSwapExactOut extends BaseMsg {\n  public protoMsg: MsgSwapExactOut_pb;\n  constructor(msg: MsgSwapExactOut_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgSwapExactOut.typeUrl,\n      value: MsgSwapExactOut_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgSwapExactOut {\n  export const typeUrl: string = `/${protobufPackage}.MsgSwapExactOut`;\n  export const Proto = MsgSwapExactOut_pb;\n  export interface Proto extends MsgSwapExactOut_pb {}\n}\n\nexport class MsgSwapExactIn extends BaseMsg {\n  public protoMsg: MsgSwapExactIn_pb;\n  constructor(msg: MsgSwapExactIn_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgSwapExactIn.typeUrl,\n      value: MsgSwapExactIn_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgSwapExactIn {\n  export const typeUrl: string = `/${protobufPackage}.MsgSwapExactIn`;\n  export const Proto = MsgSwapExactIn_pb;\n  export interface Proto extends MsgSwapExactIn_pb {}\n}\n\nexport class MsgCreatePool extends BaseMsg {\n  public protoMsg: MsgCreatePool_pb;\n  constructor(msg: MsgCreatePool_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgCreatePool.typeUrl,\n      value: MsgCreatePool_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgCreatePool {\n  export const typeUrl: string = `/${protobufPackage}.MsgCreatePool`;\n  export const Proto = MsgCreatePool_pb;\n  export interface Proto extends MsgCreatePool_pb {}\n}\n\nexport class MsgCollect extends BaseMsg {\n  public protoMsg: MsgCollect_pb;\n  constructor(msg: MsgCollect_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgCollect.typeUrl,\n      value: MsgCollect_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgCollect {\n  export const typeUrl: string = `/${protobufPackage}.MsgCollect`;\n  export const Proto = MsgCollect_pb;\n  export interface Proto extends MsgCollect_pb {}\n}\n\nexport class MsgCreatePosition extends BaseMsg {\n  public protoMsg: MsgCreatePosition_pb;\n  constructor(msg: MsgCreatePosition_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgCreatePosition.typeUrl,\n      value: MsgCreatePosition_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgCreatePosition {\n  export const typeUrl: string = `/${protobufPackage}.MsgCreatePosition`;\n  export const Proto = MsgCreatePosition_pb;\n  export interface Proto extends MsgCreatePosition_pb {}\n}\n\nexport class MsgDecreaseLiquidity extends BaseMsg {\n  public protoMsg: MsgDecreaseLiquidity_pb;\n  constructor(msg: MsgDecreaseLiquidity_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgDecreaseLiquidity.typeUrl,\n      value: MsgDecreaseLiquidity_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgDecreaseLiquidity {\n  export const typeUrl: string = `/${protobufPackage}.MsgDecreaseLiquidity`;\n  export const Proto = MsgDecreaseLiquidity_pb;\n  export interface Proto extends MsgDecreaseLiquidity_pb {}\n}\n\nexport class MsgIncreaseLiquidity extends BaseMsg {\n  public protoMsg: MsgIncreaseLiquidity_pb;\n  constructor(msg: MsgIncreaseLiquidity_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgIncreaseLiquidity.typeUrl,\n      value: MsgIncreaseLiquidity_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgIncreaseLiquidity {\n  export const typeUrl: string = `/${protobufPackage}.MsgIncreaseLiquidity`;\n  export const Proto = MsgIncreaseLiquidity_pb;\n  export interface Proto extends MsgIncreaseLiquidity_pb {}\n}\n\nexport class MsgCollectFeeProtocol extends BaseMsg {\n  public protoMsg: MsgCollectFeeProtocol_pb;\n  constructor(msg: MsgCollectFeeProtocol_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgCollectFeeProtocol.typeUrl,\n      value: MsgCollectFeeProtocol_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgCollectFeeProtocol {\n  export const typeUrl: string = `/${protobufPackage}.MsgCollectFeeProtocol`;\n  export const Proto = MsgCollectFeeProtocol_pb;\n  export interface Proto extends MsgCollectFeeProtocol_pb {}\n}\n\nexport class MsgGovCorePool extends BaseMsg {\n  public protoMsg: MsgGovCorePool_pb;\n  constructor(msg: MsgGovCorePool_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgGovCorePool.typeUrl,\n      value: MsgGovCorePool_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgGovCorePool {\n  export const typeUrl: string = `/${protobufPackage}.MsgGovCorePool`;\n  export const Proto = MsgGovCorePool_pb;\n  export interface Proto extends MsgGovCorePool_pb {}\n}\n\n","/* eslint-disable */\nimport Long from \"long\";\nimport { grpc } from \"@improbable-eng/grpc-web\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { BrowserHeaders } from \"browser-headers\";\n\nexport const protobufPackage = \"metaoslabs.metaos.token\";\n\nexport interface MsgIssue {\n  creator: string;\n  name: string;\n  symbol: string;\n  decimals: number;\n  initialSupply: string;\n  maxSupply: string;\n  description: string;\n}\n\nexport interface MsgIssueResponse {\n  denom: string;\n}\n\nexport interface MsgMint {\n  creator: string;\n  amount: string;\n}\n\nexport interface MsgMintResponse {}\n\nexport interface MsgBurn {\n  creator: string;\n  amount: string;\n}\n\nexport interface MsgBurnResponse {}\n\nexport interface MsgTransferOwnership {\n  creator: string;\n  denom: string;\n  address: string;\n}\n\nexport interface MsgTransferOwnershipResponse {}\n\nexport interface MsgConfirmOwnership {\n  creator: string;\n  denom: string;\n}\n\nexport interface MsgConfirmOwnershipResponse {}\n\nfunction createBaseMsgIssue(): MsgIssue {\n  return {\n    creator: \"\",\n    name: \"\",\n    symbol: \"\",\n    decimals: 0,\n    initialSupply: \"\",\n    maxSupply: \"\",\n    description: \"\",\n  };\n}\n\nexport const MsgIssue = {\n  encode(\n    message: MsgIssue,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.name !== \"\") {\n      writer.uint32(18).string(message.name);\n    }\n    if (message.symbol !== \"\") {\n      writer.uint32(26).string(message.symbol);\n    }\n    if (message.decimals !== 0) {\n      writer.uint32(32).int32(message.decimals);\n    }\n    if (message.initialSupply !== \"\") {\n      writer.uint32(42).string(message.initialSupply);\n    }\n    if (message.maxSupply !== \"\") {\n      writer.uint32(50).string(message.maxSupply);\n    }\n    if (message.description !== \"\") {\n      writer.uint32(58).string(message.description);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgIssue {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgIssue();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.name = reader.string();\n          break;\n        case 3:\n          message.symbol = reader.string();\n          break;\n        case 4:\n          message.decimals = reader.int32();\n          break;\n        case 5:\n          message.initialSupply = reader.string();\n          break;\n        case 6:\n          message.maxSupply = reader.string();\n          break;\n        case 7:\n          message.description = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgIssue {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      name: isSet(object.name) ? String(object.name) : \"\",\n      symbol: isSet(object.symbol) ? String(object.symbol) : \"\",\n      decimals: isSet(object.decimals) ? Number(object.decimals) : 0,\n      initialSupply: isSet(object.initialSupply)\n        ? String(object.initialSupply)\n        : \"\",\n      maxSupply: isSet(object.maxSupply) ? String(object.maxSupply) : \"\",\n      description: isSet(object.description) ? String(object.description) : \"\",\n    };\n  },\n\n  toJSON(message: MsgIssue): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.name !== undefined && (obj.name = message.name);\n    message.symbol !== undefined && (obj.symbol = message.symbol);\n    message.decimals !== undefined &&\n      (obj.decimals = Math.round(message.decimals));\n    message.initialSupply !== undefined &&\n      (obj.initialSupply = message.initialSupply);\n    message.maxSupply !== undefined && (obj.maxSupply = message.maxSupply);\n    message.description !== undefined &&\n      (obj.description = message.description);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgIssue>, I>>(object: I): MsgIssue {\n    const message = createBaseMsgIssue();\n    message.creator = object.creator ?? \"\";\n    message.name = object.name ?? \"\";\n    message.symbol = object.symbol ?? \"\";\n    message.decimals = object.decimals ?? 0;\n    message.initialSupply = object.initialSupply ?? \"\";\n    message.maxSupply = object.maxSupply ?? \"\";\n    message.description = object.description ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgIssueResponse(): MsgIssueResponse {\n  return { denom: \"\" };\n}\n\nexport const MsgIssueResponse = {\n  encode(\n    message: MsgIssueResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.denom !== \"\") {\n      writer.uint32(10).string(message.denom);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgIssueResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgIssueResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.denom = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgIssueResponse {\n    return {\n      denom: isSet(object.denom) ? String(object.denom) : \"\",\n    };\n  },\n\n  toJSON(message: MsgIssueResponse): unknown {\n    const obj: any = {};\n    message.denom !== undefined && (obj.denom = message.denom);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgIssueResponse>, I>>(\n    object: I\n  ): MsgIssueResponse {\n    const message = createBaseMsgIssueResponse();\n    message.denom = object.denom ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgMint(): MsgMint {\n  return { creator: \"\", amount: \"\" };\n}\n\nexport const MsgMint = {\n  encode(\n    message: MsgMint,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.amount !== \"\") {\n      writer.uint32(18).string(message.amount);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgMint {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgMint();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.amount = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgMint {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      amount: isSet(object.amount) ? String(object.amount) : \"\",\n    };\n  },\n\n  toJSON(message: MsgMint): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.amount !== undefined && (obj.amount = message.amount);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgMint>, I>>(object: I): MsgMint {\n    const message = createBaseMsgMint();\n    message.creator = object.creator ?? \"\";\n    message.amount = object.amount ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgMintResponse(): MsgMintResponse {\n  return {};\n}\n\nexport const MsgMintResponse = {\n  encode(\n    _: MsgMintResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgMintResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgMintResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgMintResponse {\n    return {};\n  },\n\n  toJSON(_: MsgMintResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgMintResponse>, I>>(\n    _: I\n  ): MsgMintResponse {\n    const message = createBaseMsgMintResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgBurn(): MsgBurn {\n  return { creator: \"\", amount: \"\" };\n}\n\nexport const MsgBurn = {\n  encode(\n    message: MsgBurn,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.amount !== \"\") {\n      writer.uint32(18).string(message.amount);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgBurn {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgBurn();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.amount = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgBurn {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      amount: isSet(object.amount) ? String(object.amount) : \"\",\n    };\n  },\n\n  toJSON(message: MsgBurn): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.amount !== undefined && (obj.amount = message.amount);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgBurn>, I>>(object: I): MsgBurn {\n    const message = createBaseMsgBurn();\n    message.creator = object.creator ?? \"\";\n    message.amount = object.amount ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgBurnResponse(): MsgBurnResponse {\n  return {};\n}\n\nexport const MsgBurnResponse = {\n  encode(\n    _: MsgBurnResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgBurnResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgBurnResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgBurnResponse {\n    return {};\n  },\n\n  toJSON(_: MsgBurnResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgBurnResponse>, I>>(\n    _: I\n  ): MsgBurnResponse {\n    const message = createBaseMsgBurnResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgTransferOwnership(): MsgTransferOwnership {\n  return { creator: \"\", denom: \"\", address: \"\" };\n}\n\nexport const MsgTransferOwnership = {\n  encode(\n    message: MsgTransferOwnership,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.denom !== \"\") {\n      writer.uint32(18).string(message.denom);\n    }\n    if (message.address !== \"\") {\n      writer.uint32(26).string(message.address);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgTransferOwnership {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgTransferOwnership();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.denom = reader.string();\n          break;\n        case 3:\n          message.address = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgTransferOwnership {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      denom: isSet(object.denom) ? String(object.denom) : \"\",\n      address: isSet(object.address) ? String(object.address) : \"\",\n    };\n  },\n\n  toJSON(message: MsgTransferOwnership): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.denom !== undefined && (obj.denom = message.denom);\n    message.address !== undefined && (obj.address = message.address);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgTransferOwnership>, I>>(\n    object: I\n  ): MsgTransferOwnership {\n    const message = createBaseMsgTransferOwnership();\n    message.creator = object.creator ?? \"\";\n    message.denom = object.denom ?? \"\";\n    message.address = object.address ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgTransferOwnershipResponse(): MsgTransferOwnershipResponse {\n  return {};\n}\n\nexport const MsgTransferOwnershipResponse = {\n  encode(\n    _: MsgTransferOwnershipResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgTransferOwnershipResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgTransferOwnershipResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgTransferOwnershipResponse {\n    return {};\n  },\n\n  toJSON(_: MsgTransferOwnershipResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgTransferOwnershipResponse>, I>>(\n    _: I\n  ): MsgTransferOwnershipResponse {\n    const message = createBaseMsgTransferOwnershipResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgConfirmOwnership(): MsgConfirmOwnership {\n  return { creator: \"\", denom: \"\" };\n}\n\nexport const MsgConfirmOwnership = {\n  encode(\n    message: MsgConfirmOwnership,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.denom !== \"\") {\n      writer.uint32(18).string(message.denom);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgConfirmOwnership {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgConfirmOwnership();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.denom = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgConfirmOwnership {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      denom: isSet(object.denom) ? String(object.denom) : \"\",\n    };\n  },\n\n  toJSON(message: MsgConfirmOwnership): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.denom !== undefined && (obj.denom = message.denom);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgConfirmOwnership>, I>>(\n    object: I\n  ): MsgConfirmOwnership {\n    const message = createBaseMsgConfirmOwnership();\n    message.creator = object.creator ?? \"\";\n    message.denom = object.denom ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgConfirmOwnershipResponse(): MsgConfirmOwnershipResponse {\n  return {};\n}\n\nexport const MsgConfirmOwnershipResponse = {\n  encode(\n    _: MsgConfirmOwnershipResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgConfirmOwnershipResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgConfirmOwnershipResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgConfirmOwnershipResponse {\n    return {};\n  },\n\n  toJSON(_: MsgConfirmOwnershipResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgConfirmOwnershipResponse>, I>>(\n    _: I\n  ): MsgConfirmOwnershipResponse {\n    const message = createBaseMsgConfirmOwnershipResponse();\n    return message;\n  },\n};\n\n/** Msg defines the Msg service. */\nexport interface Msg {\n  Issue(\n    request: DeepPartial<MsgIssue>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgIssueResponse>;\n  Mint(\n    request: DeepPartial<MsgMint>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgMintResponse>;\n  Burn(\n    request: DeepPartial<MsgBurn>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgBurnResponse>;\n  TransferOwnership(\n    request: DeepPartial<MsgTransferOwnership>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgTransferOwnershipResponse>;\n  /** this line is used by starport scaffolding # proto/tx/rpc */\n  ConfirmOwnership(\n    request: DeepPartial<MsgConfirmOwnership>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgConfirmOwnershipResponse>;\n}\n\nexport class MsgClientImpl implements Msg {\n  private readonly rpc: Rpc;\n\n  constructor(rpc: Rpc) {\n    this.rpc = rpc;\n    this.Issue = this.Issue.bind(this);\n    this.Mint = this.Mint.bind(this);\n    this.Burn = this.Burn.bind(this);\n    this.TransferOwnership = this.TransferOwnership.bind(this);\n    this.ConfirmOwnership = this.ConfirmOwnership.bind(this);\n  }\n\n  Issue(\n    request: DeepPartial<MsgIssue>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgIssueResponse> {\n    return this.rpc.unary(\n      MsgIssueDesc,\n      MsgIssue.fromPartial(request),\n      metadata\n    );\n  }\n\n  Mint(\n    request: DeepPartial<MsgMint>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgMintResponse> {\n    return this.rpc.unary(MsgMintDesc, MsgMint.fromPartial(request), metadata);\n  }\n\n  Burn(\n    request: DeepPartial<MsgBurn>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgBurnResponse> {\n    return this.rpc.unary(MsgBurnDesc, MsgBurn.fromPartial(request), metadata);\n  }\n\n  TransferOwnership(\n    request: DeepPartial<MsgTransferOwnership>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgTransferOwnershipResponse> {\n    return this.rpc.unary(\n      MsgTransferOwnershipDesc,\n      MsgTransferOwnership.fromPartial(request),\n      metadata\n    );\n  }\n\n  ConfirmOwnership(\n    request: DeepPartial<MsgConfirmOwnership>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgConfirmOwnershipResponse> {\n    return this.rpc.unary(\n      MsgConfirmOwnershipDesc,\n      MsgConfirmOwnership.fromPartial(request),\n      metadata\n    );\n  }\n}\n\nexport const MsgDesc = {\n  serviceName: \"metaoslabs.metaos.token.Msg\",\n};\n\nexport const MsgIssueDesc: UnaryMethodDefinitionish = {\n  methodName: \"Issue\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgIssue.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgIssueResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgMintDesc: UnaryMethodDefinitionish = {\n  methodName: \"Mint\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgMint.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgMintResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgBurnDesc: UnaryMethodDefinitionish = {\n  methodName: \"Burn\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgBurn.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgBurnResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgTransferOwnershipDesc: UnaryMethodDefinitionish = {\n  methodName: \"TransferOwnership\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgTransferOwnership.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgTransferOwnershipResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgConfirmOwnershipDesc: UnaryMethodDefinitionish = {\n  methodName: \"ConfirmOwnership\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgConfirmOwnership.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgConfirmOwnershipResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\ninterface UnaryMethodDefinitionishR\n  extends grpc.UnaryMethodDefinition<any, any> {\n  requestStream: any;\n  responseStream: any;\n}\n\ntype UnaryMethodDefinitionish = UnaryMethodDefinitionishR;\n\ninterface Rpc {\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any>;\n}\n\nexport class GrpcWebImpl {\n  private host: string;\n  private options: {\n    transport?: grpc.TransportFactory;\n\n    debug?: boolean;\n    metadata?: grpc.Metadata;\n  };\n\n  constructor(\n    host: string,\n    options: {\n      transport?: grpc.TransportFactory;\n\n      debug?: boolean;\n      metadata?: grpc.Metadata;\n    }\n  ) {\n    this.host = host;\n    this.options = options;\n  }\n\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    _request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any> {\n    const request = { ..._request, ...methodDesc.requestType };\n    const maybeCombinedMetadata =\n      metadata && this.options.metadata\n        ? new BrowserHeaders({\n            ...this.options?.metadata.headersMap,\n            ...metadata?.headersMap,\n          })\n        : metadata || this.options.metadata;\n    return new Promise((resolve, reject) => {\n      grpc.unary(methodDesc, {\n        request,\n        host: this.host,\n        metadata: maybeCombinedMetadata,\n        transport: this.options.transport,\n        debug: this.options.debug,\n        onEnd: function (response) {\n          if (response.status === grpc.Code.OK) {\n            resolve(response.message);\n          } else {\n            const err = new Error(response.statusMessage) as any;\n            err.code = response.status;\n            err.metadata = response.trailers;\n            reject(err);\n          }\n        },\n      });\n    });\n  }\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","import { BaseMsg } from \"./BaseMsg\";\nimport { EncodeObject } from \"@cosmjs/proto-signing\";\nimport {\n  protobufPackage,\n  MsgIssue as MsgIssue_pb,\n  MsgMint as MsgMint_pb,\n  MsgBurn as MsgBurn_pb,\n  MsgTransferOwnership as MsgTransferOwnership_pb,\n  MsgConfirmOwnership as MsgConfirmOwnership_pb,\n} from \"../proto/token/tx\";\n\nexport class MsgIssue extends BaseMsg {\n  public protoMsg: MsgIssue_pb;\n  constructor(msg: MsgIssue_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgIssue.typeUrl,\n      value: MsgIssue_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgIssue {\n  export const typeUrl: string = `/${protobufPackage}.MsgIssue`;\n  export const Proto = MsgIssue_pb;\n  export interface Proto extends MsgIssue_pb {}\n}\n\nexport class MsgMint extends BaseMsg {\n  public protoMsg: MsgMint_pb;\n  constructor(msg: MsgMint_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgMint.typeUrl,\n      value: MsgMint_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgMint {\n  export const typeUrl: string = `/${protobufPackage}.MsgMint`;\n  export const Proto = MsgMint_pb;\n  export interface Proto extends MsgMint_pb {}\n}\n\nexport class MsgBurn extends BaseMsg {\n  public protoMsg: MsgBurn_pb;\n  constructor(msg: MsgBurn_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgBurn.typeUrl,\n      value: MsgBurn_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgBurn {\n  export const typeUrl: string = `/${protobufPackage}.MsgBurn`;\n  export const Proto = MsgBurn_pb;\n  export interface Proto extends MsgBurn_pb {}\n}\n\nexport class MsgTransferOwnership extends BaseMsg {\n  public protoMsg: MsgTransferOwnership_pb;\n  constructor(msg: MsgTransferOwnership_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgTransferOwnership.typeUrl,\n      value: MsgTransferOwnership_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgTransferOwnership {\n  export const typeUrl: string = `/${protobufPackage}.MsgTransferOwnership`;\n  export const Proto = MsgTransferOwnership_pb;\n  export interface Proto extends MsgTransferOwnership_pb {}\n}\n\nexport class MsgConfirmOwnership extends BaseMsg {\n  public protoMsg: MsgConfirmOwnership_pb;\n  constructor(msg: MsgConfirmOwnership_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgConfirmOwnership.typeUrl,\n      value: MsgConfirmOwnership_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgConfirmOwnership {\n  export const typeUrl: string = `/${protobufPackage}.MsgConfirmOwnership`;\n  export const Proto = MsgConfirmOwnership_pb;\n  export interface Proto extends MsgConfirmOwnership_pb {}\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Any } from \"../../../google/protobuf/any\";\n\nexport const protobufPackage = \"cosmwasm.wasm.v1\";\n\n/** AccessType permission types */\nexport enum AccessType {\n  /** ACCESS_TYPE_UNSPECIFIED - AccessTypeUnspecified placeholder for empty value */\n  ACCESS_TYPE_UNSPECIFIED = 0,\n  /** ACCESS_TYPE_NOBODY - AccessTypeNobody forbidden */\n  ACCESS_TYPE_NOBODY = 1,\n  /** ACCESS_TYPE_ONLY_ADDRESS - AccessTypeOnlyAddress restricted to an address */\n  ACCESS_TYPE_ONLY_ADDRESS = 2,\n  /** ACCESS_TYPE_EVERYBODY - AccessTypeEverybody unrestricted */\n  ACCESS_TYPE_EVERYBODY = 3,\n  UNRECOGNIZED = -1,\n}\n\nexport function accessTypeFromJSON(object: any): AccessType {\n  switch (object) {\n    case 0:\n    case \"ACCESS_TYPE_UNSPECIFIED\":\n      return AccessType.ACCESS_TYPE_UNSPECIFIED;\n    case 1:\n    case \"ACCESS_TYPE_NOBODY\":\n      return AccessType.ACCESS_TYPE_NOBODY;\n    case 2:\n    case \"ACCESS_TYPE_ONLY_ADDRESS\":\n      return AccessType.ACCESS_TYPE_ONLY_ADDRESS;\n    case 3:\n    case \"ACCESS_TYPE_EVERYBODY\":\n      return AccessType.ACCESS_TYPE_EVERYBODY;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return AccessType.UNRECOGNIZED;\n  }\n}\n\nexport function accessTypeToJSON(object: AccessType): string {\n  switch (object) {\n    case AccessType.ACCESS_TYPE_UNSPECIFIED:\n      return \"ACCESS_TYPE_UNSPECIFIED\";\n    case AccessType.ACCESS_TYPE_NOBODY:\n      return \"ACCESS_TYPE_NOBODY\";\n    case AccessType.ACCESS_TYPE_ONLY_ADDRESS:\n      return \"ACCESS_TYPE_ONLY_ADDRESS\";\n    case AccessType.ACCESS_TYPE_EVERYBODY:\n      return \"ACCESS_TYPE_EVERYBODY\";\n    case AccessType.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n\n/** ContractCodeHistoryOperationType actions that caused a code change */\nexport enum ContractCodeHistoryOperationType {\n  /** CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED - ContractCodeHistoryOperationTypeUnspecified placeholder for empty value */\n  CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED = 0,\n  /** CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT - ContractCodeHistoryOperationTypeInit on chain contract instantiation */\n  CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT = 1,\n  /** CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE - ContractCodeHistoryOperationTypeMigrate code migration */\n  CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE = 2,\n  /** CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS - ContractCodeHistoryOperationTypeGenesis based on genesis data */\n  CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS = 3,\n  UNRECOGNIZED = -1,\n}\n\nexport function contractCodeHistoryOperationTypeFromJSON(\n  object: any\n): ContractCodeHistoryOperationType {\n  switch (object) {\n    case 0:\n    case \"CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED\":\n      return ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED;\n    case 1:\n    case \"CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT\":\n      return ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT;\n    case 2:\n    case \"CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE\":\n      return ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE;\n    case 3:\n    case \"CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS\":\n      return ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return ContractCodeHistoryOperationType.UNRECOGNIZED;\n  }\n}\n\nexport function contractCodeHistoryOperationTypeToJSON(\n  object: ContractCodeHistoryOperationType\n): string {\n  switch (object) {\n    case ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED:\n      return \"CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED\";\n    case ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT:\n      return \"CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT\";\n    case ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE:\n      return \"CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE\";\n    case ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS:\n      return \"CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS\";\n    case ContractCodeHistoryOperationType.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n\n/** AccessTypeParam */\nexport interface AccessTypeParam {\n  value: AccessType;\n}\n\n/** AccessConfig access control type. */\nexport interface AccessConfig {\n  permission: AccessType;\n  address: string;\n}\n\n/** Params defines the set of wasm parameters. */\nexport interface Params {\n  codeUploadAccess?: AccessConfig;\n  instantiateDefaultPermission: AccessType;\n}\n\n/** CodeInfo is data for the uploaded contract WASM code */\nexport interface CodeInfo {\n  /** CodeHash is the unique identifier created by wasmvm */\n  codeHash: Uint8Array;\n  /** Creator address who initially stored the code */\n  creator: string;\n  /** InstantiateConfig access control to apply on contract creation, optional */\n  instantiateConfig?: AccessConfig;\n}\n\n/** ContractInfo stores a WASM contract instance */\nexport interface ContractInfo {\n  /** CodeID is the reference to the stored Wasm code */\n  codeId: Long;\n  /** Creator address who initially instantiated the contract */\n  creator: string;\n  /** Admin is an optional address that can execute migrations */\n  admin: string;\n  /** Label is optional metadata to be stored with a contract instance. */\n  label: string;\n  /**\n   * Created Tx position when the contract was instantiated.\n   * This data should kept internal and not be exposed via query results. Just\n   * use for sorting\n   */\n  created?: AbsoluteTxPosition;\n  ibcPortId: string;\n  /**\n   * Extension is an extension point to store custom metadata within the\n   * persistence model.\n   */\n  extension?: Any;\n}\n\n/** ContractCodeHistoryEntry metadata to a contract. */\nexport interface ContractCodeHistoryEntry {\n  operation: ContractCodeHistoryOperationType;\n  /** CodeID is the reference to the stored WASM code */\n  codeId: Long;\n  /** Updated Tx position when the operation was executed. */\n  updated?: AbsoluteTxPosition;\n  msg: Uint8Array;\n}\n\n/**\n * AbsoluteTxPosition is a unique transaction position that allows for global\n * ordering of transactions.\n */\nexport interface AbsoluteTxPosition {\n  /** BlockHeight is the block the contract was created at */\n  blockHeight: Long;\n  /**\n   * TxIndex is a monotonic counter within the block (actual transaction index,\n   * or gas consumed)\n   */\n  txIndex: Long;\n}\n\n/** Model is a struct that holds a KV pair */\nexport interface Model {\n  /** hex-encode key to read it better (this is often ascii) */\n  key: Uint8Array;\n  /** base64-encode raw value */\n  value: Uint8Array;\n}\n\nfunction createBaseAccessTypeParam(): AccessTypeParam {\n  return { value: 0 };\n}\n\nexport const AccessTypeParam = {\n  encode(\n    message: AccessTypeParam,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.value !== 0) {\n      writer.uint32(8).int32(message.value);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): AccessTypeParam {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseAccessTypeParam();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.value = reader.int32() as any;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): AccessTypeParam {\n    return {\n      value: isSet(object.value) ? accessTypeFromJSON(object.value) : 0,\n    };\n  },\n\n  toJSON(message: AccessTypeParam): unknown {\n    const obj: any = {};\n    message.value !== undefined &&\n      (obj.value = accessTypeToJSON(message.value));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<AccessTypeParam>, I>>(\n    object: I\n  ): AccessTypeParam {\n    const message = createBaseAccessTypeParam();\n    message.value = object.value ?? 0;\n    return message;\n  },\n};\n\nfunction createBaseAccessConfig(): AccessConfig {\n  return { permission: 0, address: \"\" };\n}\n\nexport const AccessConfig = {\n  encode(\n    message: AccessConfig,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.permission !== 0) {\n      writer.uint32(8).int32(message.permission);\n    }\n    if (message.address !== \"\") {\n      writer.uint32(18).string(message.address);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): AccessConfig {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseAccessConfig();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.permission = reader.int32() as any;\n          break;\n        case 2:\n          message.address = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): AccessConfig {\n    return {\n      permission: isSet(object.permission)\n        ? accessTypeFromJSON(object.permission)\n        : 0,\n      address: isSet(object.address) ? String(object.address) : \"\",\n    };\n  },\n\n  toJSON(message: AccessConfig): unknown {\n    const obj: any = {};\n    message.permission !== undefined &&\n      (obj.permission = accessTypeToJSON(message.permission));\n    message.address !== undefined && (obj.address = message.address);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<AccessConfig>, I>>(\n    object: I\n  ): AccessConfig {\n    const message = createBaseAccessConfig();\n    message.permission = object.permission ?? 0;\n    message.address = object.address ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseParams(): Params {\n  return { codeUploadAccess: undefined, instantiateDefaultPermission: 0 };\n}\n\nexport const Params = {\n  encode(\n    message: Params,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.codeUploadAccess !== undefined) {\n      AccessConfig.encode(\n        message.codeUploadAccess,\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    if (message.instantiateDefaultPermission !== 0) {\n      writer.uint32(16).int32(message.instantiateDefaultPermission);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Params {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseParams();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.codeUploadAccess = AccessConfig.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n        case 2:\n          message.instantiateDefaultPermission = reader.int32() as any;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Params {\n    return {\n      codeUploadAccess: isSet(object.codeUploadAccess)\n        ? AccessConfig.fromJSON(object.codeUploadAccess)\n        : undefined,\n      instantiateDefaultPermission: isSet(object.instantiateDefaultPermission)\n        ? accessTypeFromJSON(object.instantiateDefaultPermission)\n        : 0,\n    };\n  },\n\n  toJSON(message: Params): unknown {\n    const obj: any = {};\n    message.codeUploadAccess !== undefined &&\n      (obj.codeUploadAccess = message.codeUploadAccess\n        ? AccessConfig.toJSON(message.codeUploadAccess)\n        : undefined);\n    message.instantiateDefaultPermission !== undefined &&\n      (obj.instantiateDefaultPermission = accessTypeToJSON(\n        message.instantiateDefaultPermission\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Params>, I>>(object: I): Params {\n    const message = createBaseParams();\n    message.codeUploadAccess =\n      object.codeUploadAccess !== undefined && object.codeUploadAccess !== null\n        ? AccessConfig.fromPartial(object.codeUploadAccess)\n        : undefined;\n    message.instantiateDefaultPermission =\n      object.instantiateDefaultPermission ?? 0;\n    return message;\n  },\n};\n\nfunction createBaseCodeInfo(): CodeInfo {\n  return {\n    codeHash: new Uint8Array(),\n    creator: \"\",\n    instantiateConfig: undefined,\n  };\n}\n\nexport const CodeInfo = {\n  encode(\n    message: CodeInfo,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.codeHash.length !== 0) {\n      writer.uint32(10).bytes(message.codeHash);\n    }\n    if (message.creator !== \"\") {\n      writer.uint32(18).string(message.creator);\n    }\n    if (message.instantiateConfig !== undefined) {\n      AccessConfig.encode(\n        message.instantiateConfig,\n        writer.uint32(42).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): CodeInfo {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseCodeInfo();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.codeHash = reader.bytes();\n          break;\n        case 2:\n          message.creator = reader.string();\n          break;\n        case 5:\n          message.instantiateConfig = AccessConfig.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): CodeInfo {\n    return {\n      codeHash: isSet(object.codeHash)\n        ? bytesFromBase64(object.codeHash)\n        : new Uint8Array(),\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      instantiateConfig: isSet(object.instantiateConfig)\n        ? AccessConfig.fromJSON(object.instantiateConfig)\n        : undefined,\n    };\n  },\n\n  toJSON(message: CodeInfo): unknown {\n    const obj: any = {};\n    message.codeHash !== undefined &&\n      (obj.codeHash = base64FromBytes(\n        message.codeHash !== undefined ? message.codeHash : new Uint8Array()\n      ));\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.instantiateConfig !== undefined &&\n      (obj.instantiateConfig = message.instantiateConfig\n        ? AccessConfig.toJSON(message.instantiateConfig)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<CodeInfo>, I>>(object: I): CodeInfo {\n    const message = createBaseCodeInfo();\n    message.codeHash = object.codeHash ?? new Uint8Array();\n    message.creator = object.creator ?? \"\";\n    message.instantiateConfig =\n      object.instantiateConfig !== undefined &&\n      object.instantiateConfig !== null\n        ? AccessConfig.fromPartial(object.instantiateConfig)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseContractInfo(): ContractInfo {\n  return {\n    codeId: Long.UZERO,\n    creator: \"\",\n    admin: \"\",\n    label: \"\",\n    created: undefined,\n    ibcPortId: \"\",\n    extension: undefined,\n  };\n}\n\nexport const ContractInfo = {\n  encode(\n    message: ContractInfo,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.codeId.isZero()) {\n      writer.uint32(8).uint64(message.codeId);\n    }\n    if (message.creator !== \"\") {\n      writer.uint32(18).string(message.creator);\n    }\n    if (message.admin !== \"\") {\n      writer.uint32(26).string(message.admin);\n    }\n    if (message.label !== \"\") {\n      writer.uint32(34).string(message.label);\n    }\n    if (message.created !== undefined) {\n      AbsoluteTxPosition.encode(\n        message.created,\n        writer.uint32(42).fork()\n      ).ldelim();\n    }\n    if (message.ibcPortId !== \"\") {\n      writer.uint32(50).string(message.ibcPortId);\n    }\n    if (message.extension !== undefined) {\n      Any.encode(message.extension, writer.uint32(58).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): ContractInfo {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseContractInfo();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.codeId = reader.uint64() as Long;\n          break;\n        case 2:\n          message.creator = reader.string();\n          break;\n        case 3:\n          message.admin = reader.string();\n          break;\n        case 4:\n          message.label = reader.string();\n          break;\n        case 5:\n          message.created = AbsoluteTxPosition.decode(reader, reader.uint32());\n          break;\n        case 6:\n          message.ibcPortId = reader.string();\n          break;\n        case 7:\n          message.extension = Any.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ContractInfo {\n    return {\n      codeId: isSet(object.codeId) ? Long.fromValue(object.codeId) : Long.UZERO,\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      admin: isSet(object.admin) ? String(object.admin) : \"\",\n      label: isSet(object.label) ? String(object.label) : \"\",\n      created: isSet(object.created)\n        ? AbsoluteTxPosition.fromJSON(object.created)\n        : undefined,\n      ibcPortId: isSet(object.ibcPortId) ? String(object.ibcPortId) : \"\",\n      extension: isSet(object.extension)\n        ? Any.fromJSON(object.extension)\n        : undefined,\n    };\n  },\n\n  toJSON(message: ContractInfo): unknown {\n    const obj: any = {};\n    message.codeId !== undefined &&\n      (obj.codeId = (message.codeId || Long.UZERO).toString());\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.admin !== undefined && (obj.admin = message.admin);\n    message.label !== undefined && (obj.label = message.label);\n    message.created !== undefined &&\n      (obj.created = message.created\n        ? AbsoluteTxPosition.toJSON(message.created)\n        : undefined);\n    message.ibcPortId !== undefined && (obj.ibcPortId = message.ibcPortId);\n    message.extension !== undefined &&\n      (obj.extension = message.extension\n        ? Any.toJSON(message.extension)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<ContractInfo>, I>>(\n    object: I\n  ): ContractInfo {\n    const message = createBaseContractInfo();\n    message.codeId =\n      object.codeId !== undefined && object.codeId !== null\n        ? Long.fromValue(object.codeId)\n        : Long.UZERO;\n    message.creator = object.creator ?? \"\";\n    message.admin = object.admin ?? \"\";\n    message.label = object.label ?? \"\";\n    message.created =\n      object.created !== undefined && object.created !== null\n        ? AbsoluteTxPosition.fromPartial(object.created)\n        : undefined;\n    message.ibcPortId = object.ibcPortId ?? \"\";\n    message.extension =\n      object.extension !== undefined && object.extension !== null\n        ? Any.fromPartial(object.extension)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseContractCodeHistoryEntry(): ContractCodeHistoryEntry {\n  return {\n    operation: 0,\n    codeId: Long.UZERO,\n    updated: undefined,\n    msg: new Uint8Array(),\n  };\n}\n\nexport const ContractCodeHistoryEntry = {\n  encode(\n    message: ContractCodeHistoryEntry,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.operation !== 0) {\n      writer.uint32(8).int32(message.operation);\n    }\n    if (!message.codeId.isZero()) {\n      writer.uint32(16).uint64(message.codeId);\n    }\n    if (message.updated !== undefined) {\n      AbsoluteTxPosition.encode(\n        message.updated,\n        writer.uint32(26).fork()\n      ).ldelim();\n    }\n    if (message.msg.length !== 0) {\n      writer.uint32(34).bytes(message.msg);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): ContractCodeHistoryEntry {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseContractCodeHistoryEntry();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.operation = reader.int32() as any;\n          break;\n        case 2:\n          message.codeId = reader.uint64() as Long;\n          break;\n        case 3:\n          message.updated = AbsoluteTxPosition.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.msg = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ContractCodeHistoryEntry {\n    return {\n      operation: isSet(object.operation)\n        ? contractCodeHistoryOperationTypeFromJSON(object.operation)\n        : 0,\n      codeId: isSet(object.codeId) ? Long.fromValue(object.codeId) : Long.UZERO,\n      updated: isSet(object.updated)\n        ? AbsoluteTxPosition.fromJSON(object.updated)\n        : undefined,\n      msg: isSet(object.msg) ? bytesFromBase64(object.msg) : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: ContractCodeHistoryEntry): unknown {\n    const obj: any = {};\n    message.operation !== undefined &&\n      (obj.operation = contractCodeHistoryOperationTypeToJSON(\n        message.operation\n      ));\n    message.codeId !== undefined &&\n      (obj.codeId = (message.codeId || Long.UZERO).toString());\n    message.updated !== undefined &&\n      (obj.updated = message.updated\n        ? AbsoluteTxPosition.toJSON(message.updated)\n        : undefined);\n    message.msg !== undefined &&\n      (obj.msg = base64FromBytes(\n        message.msg !== undefined ? message.msg : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<ContractCodeHistoryEntry>, I>>(\n    object: I\n  ): ContractCodeHistoryEntry {\n    const message = createBaseContractCodeHistoryEntry();\n    message.operation = object.operation ?? 0;\n    message.codeId =\n      object.codeId !== undefined && object.codeId !== null\n        ? Long.fromValue(object.codeId)\n        : Long.UZERO;\n    message.updated =\n      object.updated !== undefined && object.updated !== null\n        ? AbsoluteTxPosition.fromPartial(object.updated)\n        : undefined;\n    message.msg = object.msg ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBaseAbsoluteTxPosition(): AbsoluteTxPosition {\n  return { blockHeight: Long.UZERO, txIndex: Long.UZERO };\n}\n\nexport const AbsoluteTxPosition = {\n  encode(\n    message: AbsoluteTxPosition,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.blockHeight.isZero()) {\n      writer.uint32(8).uint64(message.blockHeight);\n    }\n    if (!message.txIndex.isZero()) {\n      writer.uint32(16).uint64(message.txIndex);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): AbsoluteTxPosition {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseAbsoluteTxPosition();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.blockHeight = reader.uint64() as Long;\n          break;\n        case 2:\n          message.txIndex = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): AbsoluteTxPosition {\n    return {\n      blockHeight: isSet(object.blockHeight)\n        ? Long.fromValue(object.blockHeight)\n        : Long.UZERO,\n      txIndex: isSet(object.txIndex)\n        ? Long.fromValue(object.txIndex)\n        : Long.UZERO,\n    };\n  },\n\n  toJSON(message: AbsoluteTxPosition): unknown {\n    const obj: any = {};\n    message.blockHeight !== undefined &&\n      (obj.blockHeight = (message.blockHeight || Long.UZERO).toString());\n    message.txIndex !== undefined &&\n      (obj.txIndex = (message.txIndex || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<AbsoluteTxPosition>, I>>(\n    object: I\n  ): AbsoluteTxPosition {\n    const message = createBaseAbsoluteTxPosition();\n    message.blockHeight =\n      object.blockHeight !== undefined && object.blockHeight !== null\n        ? Long.fromValue(object.blockHeight)\n        : Long.UZERO;\n    message.txIndex =\n      object.txIndex !== undefined && object.txIndex !== null\n        ? Long.fromValue(object.txIndex)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseModel(): Model {\n  return { key: new Uint8Array(), value: new Uint8Array() };\n}\n\nexport const Model = {\n  encode(message: Model, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n    if (message.value.length !== 0) {\n      writer.uint32(18).bytes(message.value);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Model {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseModel();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n        case 2:\n          message.value = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Model {\n    return {\n      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),\n      value: isSet(object.value)\n        ? bytesFromBase64(object.value)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: Model): unknown {\n    const obj: any = {};\n    message.key !== undefined &&\n      (obj.key = base64FromBytes(\n        message.key !== undefined ? message.key : new Uint8Array()\n      ));\n    message.value !== undefined &&\n      (obj.value = base64FromBytes(\n        message.value !== undefined ? message.value : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Model>, I>>(object: I): Model {\n    const message = createBaseModel();\n    message.key = object.key ?? new Uint8Array();\n    message.value = object.value ?? new Uint8Array();\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport { grpc } from \"@improbable-eng/grpc-web\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { AccessConfig } from \"./types\";\nimport { BrowserHeaders } from \"browser-headers\";\nimport { Coin } from \"../../../cosmos/base/v1beta1/coin\";\n\nexport const protobufPackage = \"cosmwasm.wasm.v1\";\n\n/** MsgStoreCode submit Wasm code to the system */\nexport interface MsgStoreCode {\n  /** Sender is the that actor that signed the messages */\n  sender: string;\n  /** WASMByteCode can be raw or gzip compressed */\n  wasmByteCode: Uint8Array;\n  /**\n   * InstantiatePermission access control to apply on contract creation,\n   * optional\n   */\n  instantiatePermission?: AccessConfig;\n}\n\n/** MsgStoreCodeResponse returns store result data. */\nexport interface MsgStoreCodeResponse {\n  /** CodeID is the reference to the stored WASM code */\n  codeId: Long;\n}\n\n/**\n * MsgInstantiateContract create a new smart contract instance for the given\n * code id.\n */\nexport interface MsgInstantiateContract {\n  /** Sender is the that actor that signed the messages */\n  sender: string;\n  /** Admin is an optional address that can execute migrations */\n  admin: string;\n  /** CodeID is the reference to the stored WASM code */\n  codeId: Long;\n  /** Label is optional metadata to be stored with a contract instance. */\n  label: string;\n  /** Msg json encoded message to be passed to the contract on instantiation */\n  msg: Uint8Array;\n  /** Funds coins that are transferred to the contract on instantiation */\n  funds: Coin[];\n}\n\n/** MsgInstantiateContractResponse return instantiation result data */\nexport interface MsgInstantiateContractResponse {\n  /** Address is the bech32 address of the new contract instance. */\n  address: string;\n  /** Data contains base64-encoded bytes to returned from the contract */\n  data: Uint8Array;\n}\n\n/** MsgExecuteContract submits the given message data to a smart contract */\nexport interface MsgExecuteContract {\n  /** Sender is the that actor that signed the messages */\n  sender: string;\n  /** Contract is the address of the smart contract */\n  contract: string;\n  /** Msg json encoded message to be passed to the contract */\n  msg: Uint8Array;\n  /** Funds coins that are transferred to the contract on execution */\n  funds: Coin[];\n}\n\n/** MsgExecuteContractResponse returns execution result data. */\nexport interface MsgExecuteContractResponse {\n  /** Data contains base64-encoded bytes to returned from the contract */\n  data: Uint8Array;\n}\n\n/** MsgMigrateContract runs a code upgrade/ downgrade for a smart contract */\nexport interface MsgMigrateContract {\n  /** Sender is the that actor that signed the messages */\n  sender: string;\n  /** Contract is the address of the smart contract */\n  contract: string;\n  /** CodeID references the new WASM code */\n  codeId: Long;\n  /** Msg json encoded message to be passed to the contract on migration */\n  msg: Uint8Array;\n}\n\n/** MsgMigrateContractResponse returns contract migration result data. */\nexport interface MsgMigrateContractResponse {\n  /**\n   * Data contains same raw bytes returned as data from the wasm contract.\n   * (May be empty)\n   */\n  data: Uint8Array;\n}\n\n/** MsgUpdateAdmin sets a new admin for a smart contract */\nexport interface MsgUpdateAdmin {\n  /** Sender is the that actor that signed the messages */\n  sender: string;\n  /** NewAdmin address to be set */\n  newAdmin: string;\n  /** Contract is the address of the smart contract */\n  contract: string;\n}\n\n/** MsgUpdateAdminResponse returns empty data */\nexport interface MsgUpdateAdminResponse {}\n\n/** MsgClearAdmin removes any admin stored for a smart contract */\nexport interface MsgClearAdmin {\n  /** Sender is the that actor that signed the messages */\n  sender: string;\n  /** Contract is the address of the smart contract */\n  contract: string;\n}\n\n/** MsgClearAdminResponse returns empty data */\nexport interface MsgClearAdminResponse {}\n\nfunction createBaseMsgStoreCode(): MsgStoreCode {\n  return {\n    sender: \"\",\n    wasmByteCode: new Uint8Array(),\n    instantiatePermission: undefined,\n  };\n}\n\nexport const MsgStoreCode = {\n  encode(\n    message: MsgStoreCode,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.sender !== \"\") {\n      writer.uint32(10).string(message.sender);\n    }\n    if (message.wasmByteCode.length !== 0) {\n      writer.uint32(18).bytes(message.wasmByteCode);\n    }\n    if (message.instantiatePermission !== undefined) {\n      AccessConfig.encode(\n        message.instantiatePermission,\n        writer.uint32(42).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgStoreCode {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgStoreCode();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.sender = reader.string();\n          break;\n        case 2:\n          message.wasmByteCode = reader.bytes();\n          break;\n        case 5:\n          message.instantiatePermission = AccessConfig.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgStoreCode {\n    return {\n      sender: isSet(object.sender) ? String(object.sender) : \"\",\n      wasmByteCode: isSet(object.wasmByteCode)\n        ? bytesFromBase64(object.wasmByteCode)\n        : new Uint8Array(),\n      instantiatePermission: isSet(object.instantiatePermission)\n        ? AccessConfig.fromJSON(object.instantiatePermission)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgStoreCode): unknown {\n    const obj: any = {};\n    message.sender !== undefined && (obj.sender = message.sender);\n    message.wasmByteCode !== undefined &&\n      (obj.wasmByteCode = base64FromBytes(\n        message.wasmByteCode !== undefined\n          ? message.wasmByteCode\n          : new Uint8Array()\n      ));\n    message.instantiatePermission !== undefined &&\n      (obj.instantiatePermission = message.instantiatePermission\n        ? AccessConfig.toJSON(message.instantiatePermission)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgStoreCode>, I>>(\n    object: I\n  ): MsgStoreCode {\n    const message = createBaseMsgStoreCode();\n    message.sender = object.sender ?? \"\";\n    message.wasmByteCode = object.wasmByteCode ?? new Uint8Array();\n    message.instantiatePermission =\n      object.instantiatePermission !== undefined &&\n      object.instantiatePermission !== null\n        ? AccessConfig.fromPartial(object.instantiatePermission)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgStoreCodeResponse(): MsgStoreCodeResponse {\n  return { codeId: Long.UZERO };\n}\n\nexport const MsgStoreCodeResponse = {\n  encode(\n    message: MsgStoreCodeResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.codeId.isZero()) {\n      writer.uint32(8).uint64(message.codeId);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgStoreCodeResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgStoreCodeResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.codeId = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgStoreCodeResponse {\n    return {\n      codeId: isSet(object.codeId) ? Long.fromValue(object.codeId) : Long.UZERO,\n    };\n  },\n\n  toJSON(message: MsgStoreCodeResponse): unknown {\n    const obj: any = {};\n    message.codeId !== undefined &&\n      (obj.codeId = (message.codeId || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgStoreCodeResponse>, I>>(\n    object: I\n  ): MsgStoreCodeResponse {\n    const message = createBaseMsgStoreCodeResponse();\n    message.codeId =\n      object.codeId !== undefined && object.codeId !== null\n        ? Long.fromValue(object.codeId)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseMsgInstantiateContract(): MsgInstantiateContract {\n  return {\n    sender: \"\",\n    admin: \"\",\n    codeId: Long.UZERO,\n    label: \"\",\n    msg: new Uint8Array(),\n    funds: [],\n  };\n}\n\nexport const MsgInstantiateContract = {\n  encode(\n    message: MsgInstantiateContract,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.sender !== \"\") {\n      writer.uint32(10).string(message.sender);\n    }\n    if (message.admin !== \"\") {\n      writer.uint32(18).string(message.admin);\n    }\n    if (!message.codeId.isZero()) {\n      writer.uint32(24).uint64(message.codeId);\n    }\n    if (message.label !== \"\") {\n      writer.uint32(34).string(message.label);\n    }\n    if (message.msg.length !== 0) {\n      writer.uint32(42).bytes(message.msg);\n    }\n    for (const v of message.funds) {\n      Coin.encode(v!, writer.uint32(50).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgInstantiateContract {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgInstantiateContract();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.sender = reader.string();\n          break;\n        case 2:\n          message.admin = reader.string();\n          break;\n        case 3:\n          message.codeId = reader.uint64() as Long;\n          break;\n        case 4:\n          message.label = reader.string();\n          break;\n        case 5:\n          message.msg = reader.bytes();\n          break;\n        case 6:\n          message.funds.push(Coin.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgInstantiateContract {\n    return {\n      sender: isSet(object.sender) ? String(object.sender) : \"\",\n      admin: isSet(object.admin) ? String(object.admin) : \"\",\n      codeId: isSet(object.codeId) ? Long.fromValue(object.codeId) : Long.UZERO,\n      label: isSet(object.label) ? String(object.label) : \"\",\n      msg: isSet(object.msg) ? bytesFromBase64(object.msg) : new Uint8Array(),\n      funds: Array.isArray(object?.funds)\n        ? object.funds.map((e: any) => Coin.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: MsgInstantiateContract): unknown {\n    const obj: any = {};\n    message.sender !== undefined && (obj.sender = message.sender);\n    message.admin !== undefined && (obj.admin = message.admin);\n    message.codeId !== undefined &&\n      (obj.codeId = (message.codeId || Long.UZERO).toString());\n    message.label !== undefined && (obj.label = message.label);\n    message.msg !== undefined &&\n      (obj.msg = base64FromBytes(\n        message.msg !== undefined ? message.msg : new Uint8Array()\n      ));\n    if (message.funds) {\n      obj.funds = message.funds.map((e) => (e ? Coin.toJSON(e) : undefined));\n    } else {\n      obj.funds = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgInstantiateContract>, I>>(\n    object: I\n  ): MsgInstantiateContract {\n    const message = createBaseMsgInstantiateContract();\n    message.sender = object.sender ?? \"\";\n    message.admin = object.admin ?? \"\";\n    message.codeId =\n      object.codeId !== undefined && object.codeId !== null\n        ? Long.fromValue(object.codeId)\n        : Long.UZERO;\n    message.label = object.label ?? \"\";\n    message.msg = object.msg ?? new Uint8Array();\n    message.funds = object.funds?.map((e) => Coin.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseMsgInstantiateContractResponse(): MsgInstantiateContractResponse {\n  return { address: \"\", data: new Uint8Array() };\n}\n\nexport const MsgInstantiateContractResponse = {\n  encode(\n    message: MsgInstantiateContractResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.address !== \"\") {\n      writer.uint32(10).string(message.address);\n    }\n    if (message.data.length !== 0) {\n      writer.uint32(18).bytes(message.data);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgInstantiateContractResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgInstantiateContractResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.address = reader.string();\n          break;\n        case 2:\n          message.data = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgInstantiateContractResponse {\n    return {\n      address: isSet(object.address) ? String(object.address) : \"\",\n      data: isSet(object.data)\n        ? bytesFromBase64(object.data)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: MsgInstantiateContractResponse): unknown {\n    const obj: any = {};\n    message.address !== undefined && (obj.address = message.address);\n    message.data !== undefined &&\n      (obj.data = base64FromBytes(\n        message.data !== undefined ? message.data : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgInstantiateContractResponse>, I>>(\n    object: I\n  ): MsgInstantiateContractResponse {\n    const message = createBaseMsgInstantiateContractResponse();\n    message.address = object.address ?? \"\";\n    message.data = object.data ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBaseMsgExecuteContract(): MsgExecuteContract {\n  return { sender: \"\", contract: \"\", msg: new Uint8Array(), funds: [] };\n}\n\nexport const MsgExecuteContract = {\n  encode(\n    message: MsgExecuteContract,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.sender !== \"\") {\n      writer.uint32(10).string(message.sender);\n    }\n    if (message.contract !== \"\") {\n      writer.uint32(18).string(message.contract);\n    }\n    if (message.msg.length !== 0) {\n      writer.uint32(26).bytes(message.msg);\n    }\n    for (const v of message.funds) {\n      Coin.encode(v!, writer.uint32(42).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgExecuteContract {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgExecuteContract();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.sender = reader.string();\n          break;\n        case 2:\n          message.contract = reader.string();\n          break;\n        case 3:\n          message.msg = reader.bytes();\n          break;\n        case 5:\n          message.funds.push(Coin.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgExecuteContract {\n    return {\n      sender: isSet(object.sender) ? String(object.sender) : \"\",\n      contract: isSet(object.contract) ? String(object.contract) : \"\",\n      msg: isSet(object.msg) ? bytesFromBase64(object.msg) : new Uint8Array(),\n      funds: Array.isArray(object?.funds)\n        ? object.funds.map((e: any) => Coin.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: MsgExecuteContract): unknown {\n    const obj: any = {};\n    message.sender !== undefined && (obj.sender = message.sender);\n    message.contract !== undefined && (obj.contract = message.contract);\n    message.msg !== undefined &&\n      (obj.msg = base64FromBytes(\n        message.msg !== undefined ? message.msg : new Uint8Array()\n      ));\n    if (message.funds) {\n      obj.funds = message.funds.map((e) => (e ? Coin.toJSON(e) : undefined));\n    } else {\n      obj.funds = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgExecuteContract>, I>>(\n    object: I\n  ): MsgExecuteContract {\n    const message = createBaseMsgExecuteContract();\n    message.sender = object.sender ?? \"\";\n    message.contract = object.contract ?? \"\";\n    message.msg = object.msg ?? new Uint8Array();\n    message.funds = object.funds?.map((e) => Coin.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseMsgExecuteContractResponse(): MsgExecuteContractResponse {\n  return { data: new Uint8Array() };\n}\n\nexport const MsgExecuteContractResponse = {\n  encode(\n    message: MsgExecuteContractResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.data.length !== 0) {\n      writer.uint32(10).bytes(message.data);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgExecuteContractResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgExecuteContractResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.data = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgExecuteContractResponse {\n    return {\n      data: isSet(object.data)\n        ? bytesFromBase64(object.data)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: MsgExecuteContractResponse): unknown {\n    const obj: any = {};\n    message.data !== undefined &&\n      (obj.data = base64FromBytes(\n        message.data !== undefined ? message.data : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgExecuteContractResponse>, I>>(\n    object: I\n  ): MsgExecuteContractResponse {\n    const message = createBaseMsgExecuteContractResponse();\n    message.data = object.data ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBaseMsgMigrateContract(): MsgMigrateContract {\n  return {\n    sender: \"\",\n    contract: \"\",\n    codeId: Long.UZERO,\n    msg: new Uint8Array(),\n  };\n}\n\nexport const MsgMigrateContract = {\n  encode(\n    message: MsgMigrateContract,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.sender !== \"\") {\n      writer.uint32(10).string(message.sender);\n    }\n    if (message.contract !== \"\") {\n      writer.uint32(18).string(message.contract);\n    }\n    if (!message.codeId.isZero()) {\n      writer.uint32(24).uint64(message.codeId);\n    }\n    if (message.msg.length !== 0) {\n      writer.uint32(34).bytes(message.msg);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgMigrateContract {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgMigrateContract();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.sender = reader.string();\n          break;\n        case 2:\n          message.contract = reader.string();\n          break;\n        case 3:\n          message.codeId = reader.uint64() as Long;\n          break;\n        case 4:\n          message.msg = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgMigrateContract {\n    return {\n      sender: isSet(object.sender) ? String(object.sender) : \"\",\n      contract: isSet(object.contract) ? String(object.contract) : \"\",\n      codeId: isSet(object.codeId) ? Long.fromValue(object.codeId) : Long.UZERO,\n      msg: isSet(object.msg) ? bytesFromBase64(object.msg) : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: MsgMigrateContract): unknown {\n    const obj: any = {};\n    message.sender !== undefined && (obj.sender = message.sender);\n    message.contract !== undefined && (obj.contract = message.contract);\n    message.codeId !== undefined &&\n      (obj.codeId = (message.codeId || Long.UZERO).toString());\n    message.msg !== undefined &&\n      (obj.msg = base64FromBytes(\n        message.msg !== undefined ? message.msg : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgMigrateContract>, I>>(\n    object: I\n  ): MsgMigrateContract {\n    const message = createBaseMsgMigrateContract();\n    message.sender = object.sender ?? \"\";\n    message.contract = object.contract ?? \"\";\n    message.codeId =\n      object.codeId !== undefined && object.codeId !== null\n        ? Long.fromValue(object.codeId)\n        : Long.UZERO;\n    message.msg = object.msg ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBaseMsgMigrateContractResponse(): MsgMigrateContractResponse {\n  return { data: new Uint8Array() };\n}\n\nexport const MsgMigrateContractResponse = {\n  encode(\n    message: MsgMigrateContractResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.data.length !== 0) {\n      writer.uint32(10).bytes(message.data);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgMigrateContractResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgMigrateContractResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.data = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgMigrateContractResponse {\n    return {\n      data: isSet(object.data)\n        ? bytesFromBase64(object.data)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: MsgMigrateContractResponse): unknown {\n    const obj: any = {};\n    message.data !== undefined &&\n      (obj.data = base64FromBytes(\n        message.data !== undefined ? message.data : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgMigrateContractResponse>, I>>(\n    object: I\n  ): MsgMigrateContractResponse {\n    const message = createBaseMsgMigrateContractResponse();\n    message.data = object.data ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBaseMsgUpdateAdmin(): MsgUpdateAdmin {\n  return { sender: \"\", newAdmin: \"\", contract: \"\" };\n}\n\nexport const MsgUpdateAdmin = {\n  encode(\n    message: MsgUpdateAdmin,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.sender !== \"\") {\n      writer.uint32(10).string(message.sender);\n    }\n    if (message.newAdmin !== \"\") {\n      writer.uint32(18).string(message.newAdmin);\n    }\n    if (message.contract !== \"\") {\n      writer.uint32(26).string(message.contract);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateAdmin {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgUpdateAdmin();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.sender = reader.string();\n          break;\n        case 2:\n          message.newAdmin = reader.string();\n          break;\n        case 3:\n          message.contract = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgUpdateAdmin {\n    return {\n      sender: isSet(object.sender) ? String(object.sender) : \"\",\n      newAdmin: isSet(object.newAdmin) ? String(object.newAdmin) : \"\",\n      contract: isSet(object.contract) ? String(object.contract) : \"\",\n    };\n  },\n\n  toJSON(message: MsgUpdateAdmin): unknown {\n    const obj: any = {};\n    message.sender !== undefined && (obj.sender = message.sender);\n    message.newAdmin !== undefined && (obj.newAdmin = message.newAdmin);\n    message.contract !== undefined && (obj.contract = message.contract);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgUpdateAdmin>, I>>(\n    object: I\n  ): MsgUpdateAdmin {\n    const message = createBaseMsgUpdateAdmin();\n    message.sender = object.sender ?? \"\";\n    message.newAdmin = object.newAdmin ?? \"\";\n    message.contract = object.contract ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgUpdateAdminResponse(): MsgUpdateAdminResponse {\n  return {};\n}\n\nexport const MsgUpdateAdminResponse = {\n  encode(\n    _: MsgUpdateAdminResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgUpdateAdminResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgUpdateAdminResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgUpdateAdminResponse {\n    return {};\n  },\n\n  toJSON(_: MsgUpdateAdminResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgUpdateAdminResponse>, I>>(\n    _: I\n  ): MsgUpdateAdminResponse {\n    const message = createBaseMsgUpdateAdminResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgClearAdmin(): MsgClearAdmin {\n  return { sender: \"\", contract: \"\" };\n}\n\nexport const MsgClearAdmin = {\n  encode(\n    message: MsgClearAdmin,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.sender !== \"\") {\n      writer.uint32(10).string(message.sender);\n    }\n    if (message.contract !== \"\") {\n      writer.uint32(26).string(message.contract);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgClearAdmin {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgClearAdmin();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.sender = reader.string();\n          break;\n        case 3:\n          message.contract = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgClearAdmin {\n    return {\n      sender: isSet(object.sender) ? String(object.sender) : \"\",\n      contract: isSet(object.contract) ? String(object.contract) : \"\",\n    };\n  },\n\n  toJSON(message: MsgClearAdmin): unknown {\n    const obj: any = {};\n    message.sender !== undefined && (obj.sender = message.sender);\n    message.contract !== undefined && (obj.contract = message.contract);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgClearAdmin>, I>>(\n    object: I\n  ): MsgClearAdmin {\n    const message = createBaseMsgClearAdmin();\n    message.sender = object.sender ?? \"\";\n    message.contract = object.contract ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgClearAdminResponse(): MsgClearAdminResponse {\n  return {};\n}\n\nexport const MsgClearAdminResponse = {\n  encode(\n    _: MsgClearAdminResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgClearAdminResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgClearAdminResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgClearAdminResponse {\n    return {};\n  },\n\n  toJSON(_: MsgClearAdminResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgClearAdminResponse>, I>>(\n    _: I\n  ): MsgClearAdminResponse {\n    const message = createBaseMsgClearAdminResponse();\n    return message;\n  },\n};\n\n/** Msg defines the wasm Msg service. */\nexport interface Msg {\n  /** StoreCode to submit Wasm code to the system */\n  StoreCode(\n    request: DeepPartial<MsgStoreCode>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgStoreCodeResponse>;\n  /** Instantiate creates a new smart contract instance for the given code id. */\n  InstantiateContract(\n    request: DeepPartial<MsgInstantiateContract>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgInstantiateContractResponse>;\n  /** Execute submits the given message data to a smart contract */\n  ExecuteContract(\n    request: DeepPartial<MsgExecuteContract>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgExecuteContractResponse>;\n  /** Migrate runs a code upgrade/ downgrade for a smart contract */\n  MigrateContract(\n    request: DeepPartial<MsgMigrateContract>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgMigrateContractResponse>;\n  /** UpdateAdmin sets a new   admin for a smart contract */\n  UpdateAdmin(\n    request: DeepPartial<MsgUpdateAdmin>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgUpdateAdminResponse>;\n  /** ClearAdmin removes any admin stored for a smart contract */\n  ClearAdmin(\n    request: DeepPartial<MsgClearAdmin>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgClearAdminResponse>;\n}\n\nexport class MsgClientImpl implements Msg {\n  private readonly rpc: Rpc;\n\n  constructor(rpc: Rpc) {\n    this.rpc = rpc;\n    this.StoreCode = this.StoreCode.bind(this);\n    this.InstantiateContract = this.InstantiateContract.bind(this);\n    this.ExecuteContract = this.ExecuteContract.bind(this);\n    this.MigrateContract = this.MigrateContract.bind(this);\n    this.UpdateAdmin = this.UpdateAdmin.bind(this);\n    this.ClearAdmin = this.ClearAdmin.bind(this);\n  }\n\n  StoreCode(\n    request: DeepPartial<MsgStoreCode>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgStoreCodeResponse> {\n    return this.rpc.unary(\n      MsgStoreCodeDesc,\n      MsgStoreCode.fromPartial(request),\n      metadata\n    );\n  }\n\n  InstantiateContract(\n    request: DeepPartial<MsgInstantiateContract>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgInstantiateContractResponse> {\n    return this.rpc.unary(\n      MsgInstantiateContractDesc,\n      MsgInstantiateContract.fromPartial(request),\n      metadata\n    );\n  }\n\n  ExecuteContract(\n    request: DeepPartial<MsgExecuteContract>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgExecuteContractResponse> {\n    return this.rpc.unary(\n      MsgExecuteContractDesc,\n      MsgExecuteContract.fromPartial(request),\n      metadata\n    );\n  }\n\n  MigrateContract(\n    request: DeepPartial<MsgMigrateContract>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgMigrateContractResponse> {\n    return this.rpc.unary(\n      MsgMigrateContractDesc,\n      MsgMigrateContract.fromPartial(request),\n      metadata\n    );\n  }\n\n  UpdateAdmin(\n    request: DeepPartial<MsgUpdateAdmin>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgUpdateAdminResponse> {\n    return this.rpc.unary(\n      MsgUpdateAdminDesc,\n      MsgUpdateAdmin.fromPartial(request),\n      metadata\n    );\n  }\n\n  ClearAdmin(\n    request: DeepPartial<MsgClearAdmin>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgClearAdminResponse> {\n    return this.rpc.unary(\n      MsgClearAdminDesc,\n      MsgClearAdmin.fromPartial(request),\n      metadata\n    );\n  }\n}\n\nexport const MsgDesc = {\n  serviceName: \"cosmwasm.wasm.v1.Msg\",\n};\n\nexport const MsgStoreCodeDesc: UnaryMethodDefinitionish = {\n  methodName: \"StoreCode\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgStoreCode.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgStoreCodeResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgInstantiateContractDesc: UnaryMethodDefinitionish = {\n  methodName: \"InstantiateContract\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgInstantiateContract.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgInstantiateContractResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgExecuteContractDesc: UnaryMethodDefinitionish = {\n  methodName: \"ExecuteContract\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgExecuteContract.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgExecuteContractResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgMigrateContractDesc: UnaryMethodDefinitionish = {\n  methodName: \"MigrateContract\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgMigrateContract.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgMigrateContractResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgUpdateAdminDesc: UnaryMethodDefinitionish = {\n  methodName: \"UpdateAdmin\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgUpdateAdmin.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgUpdateAdminResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgClearAdminDesc: UnaryMethodDefinitionish = {\n  methodName: \"ClearAdmin\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgClearAdmin.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgClearAdminResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\ninterface UnaryMethodDefinitionishR\n  extends grpc.UnaryMethodDefinition<any, any> {\n  requestStream: any;\n  responseStream: any;\n}\n\ntype UnaryMethodDefinitionish = UnaryMethodDefinitionishR;\n\ninterface Rpc {\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any>;\n}\n\nexport class GrpcWebImpl {\n  private host: string;\n  private options: {\n    transport?: grpc.TransportFactory;\n\n    debug?: boolean;\n    metadata?: grpc.Metadata;\n  };\n\n  constructor(\n    host: string,\n    options: {\n      transport?: grpc.TransportFactory;\n\n      debug?: boolean;\n      metadata?: grpc.Metadata;\n    }\n  ) {\n    this.host = host;\n    this.options = options;\n  }\n\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    _request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any> {\n    const request = { ..._request, ...methodDesc.requestType };\n    const maybeCombinedMetadata =\n      metadata && this.options.metadata\n        ? new BrowserHeaders({\n            ...this.options?.metadata.headersMap,\n            ...metadata?.headersMap,\n          })\n        : metadata || this.options.metadata;\n    return new Promise((resolve, reject) => {\n      grpc.unary(methodDesc, {\n        request,\n        host: this.host,\n        metadata: maybeCombinedMetadata,\n        transport: this.options.transport,\n        debug: this.options.debug,\n        onEnd: function (response) {\n          if (response.status === grpc.Code.OK) {\n            resolve(response.message);\n          } else {\n            const err = new Error(response.statusMessage) as any;\n            err.code = response.status;\n            err.metadata = response.trailers;\n            reject(err);\n          }\n        },\n      });\n    });\n  }\n}\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","import { BaseMsg } from \"./BaseMsg\";\nimport { EncodeObject } from \"@cosmjs/proto-signing\";\nimport {\n  protobufPackage,\n  MsgStoreCode as MsgStoreCode_pb,\n} from \"../proto/cosmwasm/wasm/v1/tx\";\n\nexport class MsgStoreCode extends BaseMsg {\n  public protoMsg: MsgStoreCode_pb;\n  constructor(msg: MsgStoreCode_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgStoreCode.typeUrl,\n      value: MsgStoreCode_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgStoreCode {\n  export const typeUrl: string = `/${protobufPackage}.MsgStoreCode`;\n  export const Proto = MsgStoreCode_pb;\n  export interface Proto extends MsgStoreCode_pb {}\n}\n\n\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"cosmos.crypto.secp256k1\";\n\n/**\n * PubKey defines a secp256k1 public key\n * Key is the compressed form of the pubkey. The first byte depends is a 0x02 byte\n * if the y-coordinate is the lexicographically largest of the two associated with\n * the x-coordinate. Otherwise the first byte is a 0x03.\n * This prefix is followed with the x-coordinate.\n */\nexport interface PubKey {\n  key: Uint8Array;\n}\n\n/** PrivKey defines a secp256k1 private key. */\nexport interface PrivKey {\n  key: Uint8Array;\n}\n\nfunction createBasePubKey(): PubKey {\n  return { key: new Uint8Array() };\n}\n\nexport const PubKey = {\n  encode(\n    message: PubKey,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): PubKey {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBasePubKey();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): PubKey {\n    return {\n      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: PubKey): unknown {\n    const obj: any = {};\n    message.key !== undefined &&\n      (obj.key = base64FromBytes(\n        message.key !== undefined ? message.key : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<PubKey>, I>>(object: I): PubKey {\n    const message = createBasePubKey();\n    message.key = object.key ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBasePrivKey(): PrivKey {\n  return { key: new Uint8Array() };\n}\n\nexport const PrivKey = {\n  encode(\n    message: PrivKey,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): PrivKey {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBasePrivKey();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): PrivKey {\n    return {\n      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: PrivKey): unknown {\n    const obj: any = {};\n    message.key !== undefined &&\n      (obj.key = base64FromBytes(\n        message.key !== undefined ? message.key : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<PrivKey>, I>>(object: I): PrivKey {\n    const message = createBasePrivKey();\n    message.key = object.key ?? new Uint8Array();\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"cosmos.crypto.multisig.v1beta1\";\n\n/**\n * MultiSignature wraps the signatures from a multisig.LegacyAminoPubKey.\n * See cosmos.tx.v1betata1.ModeInfo.Multi for how to specify which signers\n * signed and with which modes.\n */\nexport interface MultiSignature {\n  signatures: Uint8Array[];\n}\n\n/**\n * CompactBitArray is an implementation of a space efficient bit array.\n * This is used to ensure that the encoded data takes up a minimal amount of\n * space after proto encoding.\n * This is not thread safe, and is not intended for concurrent usage.\n */\nexport interface CompactBitArray {\n  extraBitsStored: number;\n  elems: Uint8Array;\n}\n\nfunction createBaseMultiSignature(): MultiSignature {\n  return { signatures: [] };\n}\n\nexport const MultiSignature = {\n  encode(\n    message: MultiSignature,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.signatures) {\n      writer.uint32(10).bytes(v!);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MultiSignature {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMultiSignature();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.signatures.push(reader.bytes());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MultiSignature {\n    return {\n      signatures: Array.isArray(object?.signatures)\n        ? object.signatures.map((e: any) => bytesFromBase64(e))\n        : [],\n    };\n  },\n\n  toJSON(message: MultiSignature): unknown {\n    const obj: any = {};\n    if (message.signatures) {\n      obj.signatures = message.signatures.map((e) =>\n        base64FromBytes(e !== undefined ? e : new Uint8Array())\n      );\n    } else {\n      obj.signatures = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MultiSignature>, I>>(\n    object: I\n  ): MultiSignature {\n    const message = createBaseMultiSignature();\n    message.signatures = object.signatures?.map((e) => e) || [];\n    return message;\n  },\n};\n\nfunction createBaseCompactBitArray(): CompactBitArray {\n  return { extraBitsStored: 0, elems: new Uint8Array() };\n}\n\nexport const CompactBitArray = {\n  encode(\n    message: CompactBitArray,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.extraBitsStored !== 0) {\n      writer.uint32(8).uint32(message.extraBitsStored);\n    }\n    if (message.elems.length !== 0) {\n      writer.uint32(18).bytes(message.elems);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): CompactBitArray {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseCompactBitArray();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.extraBitsStored = reader.uint32();\n          break;\n        case 2:\n          message.elems = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): CompactBitArray {\n    return {\n      extraBitsStored: isSet(object.extraBitsStored)\n        ? Number(object.extraBitsStored)\n        : 0,\n      elems: isSet(object.elems)\n        ? bytesFromBase64(object.elems)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: CompactBitArray): unknown {\n    const obj: any = {};\n    message.extraBitsStored !== undefined &&\n      (obj.extraBitsStored = Math.round(message.extraBitsStored));\n    message.elems !== undefined &&\n      (obj.elems = base64FromBytes(\n        message.elems !== undefined ? message.elems : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<CompactBitArray>, I>>(\n    object: I\n  ): CompactBitArray {\n    const message = createBaseCompactBitArray();\n    message.extraBitsStored = object.extraBitsStored ?? 0;\n    message.elems = object.elems ?? new Uint8Array();\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Any } from \"../../../../google/protobuf/any\";\nimport { CompactBitArray } from \"../../../crypto/multisig/v1beta1/multisig\";\n\nexport const protobufPackage = \"cosmos.tx.signing.v1beta1\";\n\n/** SignMode represents a signing mode with its own security guarantees. */\nexport enum SignMode {\n  /**\n   * SIGN_MODE_UNSPECIFIED - SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be\n   * rejected\n   */\n  SIGN_MODE_UNSPECIFIED = 0,\n  /**\n   * SIGN_MODE_DIRECT - SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is\n   * verified with raw bytes from Tx\n   */\n  SIGN_MODE_DIRECT = 1,\n  /**\n   * SIGN_MODE_TEXTUAL - SIGN_MODE_TEXTUAL is a future signing mode that will verify some\n   * human-readable textual representation on top of the binary representation\n   * from SIGN_MODE_DIRECT\n   */\n  SIGN_MODE_TEXTUAL = 2,\n  /**\n   * SIGN_MODE_LEGACY_AMINO_JSON - SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses\n   * Amino JSON and will be removed in the future\n   */\n  SIGN_MODE_LEGACY_AMINO_JSON = 127,\n  /**\n   * SIGN_MODE_EIP_191 - SIGN_MODE_EIP_191 specifies the sign mode for EIP 191 signing on the Cosmos\n   * SDK. Ref: https://eips.ethereum.org/EIPS/eip-191\n   *\n   * Currently, SIGN_MODE_EIP_191 is registered as a SignMode enum variant,\n   * but is not implemented on the SDK by default. To enable EIP-191, you need\n   * to pass a custom `TxConfig` that has an implementation of\n   * `SignModeHandler` for EIP-191. The SDK may decide to fully support\n   * EIP-191 in the future.\n   *\n   * Since: cosmos-sdk 0.45.2\n   */\n  SIGN_MODE_EIP_191 = 191,\n  UNRECOGNIZED = -1,\n}\n\nexport function signModeFromJSON(object: any): SignMode {\n  switch (object) {\n    case 0:\n    case \"SIGN_MODE_UNSPECIFIED\":\n      return SignMode.SIGN_MODE_UNSPECIFIED;\n    case 1:\n    case \"SIGN_MODE_DIRECT\":\n      return SignMode.SIGN_MODE_DIRECT;\n    case 2:\n    case \"SIGN_MODE_TEXTUAL\":\n      return SignMode.SIGN_MODE_TEXTUAL;\n    case 127:\n    case \"SIGN_MODE_LEGACY_AMINO_JSON\":\n      return SignMode.SIGN_MODE_LEGACY_AMINO_JSON;\n    case 191:\n    case \"SIGN_MODE_EIP_191\":\n      return SignMode.SIGN_MODE_EIP_191;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return SignMode.UNRECOGNIZED;\n  }\n}\n\nexport function signModeToJSON(object: SignMode): string {\n  switch (object) {\n    case SignMode.SIGN_MODE_UNSPECIFIED:\n      return \"SIGN_MODE_UNSPECIFIED\";\n    case SignMode.SIGN_MODE_DIRECT:\n      return \"SIGN_MODE_DIRECT\";\n    case SignMode.SIGN_MODE_TEXTUAL:\n      return \"SIGN_MODE_TEXTUAL\";\n    case SignMode.SIGN_MODE_LEGACY_AMINO_JSON:\n      return \"SIGN_MODE_LEGACY_AMINO_JSON\";\n    case SignMode.SIGN_MODE_EIP_191:\n      return \"SIGN_MODE_EIP_191\";\n    case SignMode.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n\n/** SignatureDescriptors wraps multiple SignatureDescriptor's. */\nexport interface SignatureDescriptors {\n  /** signatures are the signature descriptors */\n  signatures: SignatureDescriptor[];\n}\n\n/**\n * SignatureDescriptor is a convenience type which represents the full data for\n * a signature including the public key of the signer, signing modes and the\n * signature itself. It is primarily used for coordinating signatures between\n * clients.\n */\nexport interface SignatureDescriptor {\n  /** public_key is the public key of the signer */\n  publicKey?: Any;\n  data?: SignatureDescriptor_Data;\n  /**\n   * sequence is the sequence of the account, which describes the\n   * number of committed transactions signed by a given address. It is used to prevent\n   * replay attacks.\n   */\n  sequence: Long;\n}\n\n/** Data represents signature data */\nexport interface SignatureDescriptor_Data {\n  /** single represents a single signer */\n  single?: SignatureDescriptor_Data_Single | undefined;\n  /** multi represents a multisig signer */\n  multi?: SignatureDescriptor_Data_Multi | undefined;\n}\n\n/** Single is the signature data for a single signer */\nexport interface SignatureDescriptor_Data_Single {\n  /** mode is the signing mode of the single signer */\n  mode: SignMode;\n  /** signature is the raw signature bytes */\n  signature: Uint8Array;\n}\n\n/** Multi is the signature data for a multisig public key */\nexport interface SignatureDescriptor_Data_Multi {\n  /** bitarray specifies which keys within the multisig are signing */\n  bitarray?: CompactBitArray;\n  /** signatures is the signatures of the multi-signature */\n  signatures: SignatureDescriptor_Data[];\n}\n\nfunction createBaseSignatureDescriptors(): SignatureDescriptors {\n  return { signatures: [] };\n}\n\nexport const SignatureDescriptors = {\n  encode(\n    message: SignatureDescriptors,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.signatures) {\n      SignatureDescriptor.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): SignatureDescriptors {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSignatureDescriptors();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.signatures.push(\n            SignatureDescriptor.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SignatureDescriptors {\n    return {\n      signatures: Array.isArray(object?.signatures)\n        ? object.signatures.map((e: any) => SignatureDescriptor.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: SignatureDescriptors): unknown {\n    const obj: any = {};\n    if (message.signatures) {\n      obj.signatures = message.signatures.map((e) =>\n        e ? SignatureDescriptor.toJSON(e) : undefined\n      );\n    } else {\n      obj.signatures = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SignatureDescriptors>, I>>(\n    object: I\n  ): SignatureDescriptors {\n    const message = createBaseSignatureDescriptors();\n    message.signatures =\n      object.signatures?.map((e) => SignatureDescriptor.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseSignatureDescriptor(): SignatureDescriptor {\n  return { publicKey: undefined, data: undefined, sequence: Long.UZERO };\n}\n\nexport const SignatureDescriptor = {\n  encode(\n    message: SignatureDescriptor,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.publicKey !== undefined) {\n      Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.data !== undefined) {\n      SignatureDescriptor_Data.encode(\n        message.data,\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    if (!message.sequence.isZero()) {\n      writer.uint32(24).uint64(message.sequence);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): SignatureDescriptor {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSignatureDescriptor();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.publicKey = Any.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.data = SignatureDescriptor_Data.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n        case 3:\n          message.sequence = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SignatureDescriptor {\n    return {\n      publicKey: isSet(object.publicKey)\n        ? Any.fromJSON(object.publicKey)\n        : undefined,\n      data: isSet(object.data)\n        ? SignatureDescriptor_Data.fromJSON(object.data)\n        : undefined,\n      sequence: isSet(object.sequence)\n        ? Long.fromValue(object.sequence)\n        : Long.UZERO,\n    };\n  },\n\n  toJSON(message: SignatureDescriptor): unknown {\n    const obj: any = {};\n    message.publicKey !== undefined &&\n      (obj.publicKey = message.publicKey\n        ? Any.toJSON(message.publicKey)\n        : undefined);\n    message.data !== undefined &&\n      (obj.data = message.data\n        ? SignatureDescriptor_Data.toJSON(message.data)\n        : undefined);\n    message.sequence !== undefined &&\n      (obj.sequence = (message.sequence || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SignatureDescriptor>, I>>(\n    object: I\n  ): SignatureDescriptor {\n    const message = createBaseSignatureDescriptor();\n    message.publicKey =\n      object.publicKey !== undefined && object.publicKey !== null\n        ? Any.fromPartial(object.publicKey)\n        : undefined;\n    message.data =\n      object.data !== undefined && object.data !== null\n        ? SignatureDescriptor_Data.fromPartial(object.data)\n        : undefined;\n    message.sequence =\n      object.sequence !== undefined && object.sequence !== null\n        ? Long.fromValue(object.sequence)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseSignatureDescriptor_Data(): SignatureDescriptor_Data {\n  return { single: undefined, multi: undefined };\n}\n\nexport const SignatureDescriptor_Data = {\n  encode(\n    message: SignatureDescriptor_Data,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.single !== undefined) {\n      SignatureDescriptor_Data_Single.encode(\n        message.single,\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    if (message.multi !== undefined) {\n      SignatureDescriptor_Data_Multi.encode(\n        message.multi,\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): SignatureDescriptor_Data {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSignatureDescriptor_Data();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.single = SignatureDescriptor_Data_Single.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n        case 2:\n          message.multi = SignatureDescriptor_Data_Multi.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SignatureDescriptor_Data {\n    return {\n      single: isSet(object.single)\n        ? SignatureDescriptor_Data_Single.fromJSON(object.single)\n        : undefined,\n      multi: isSet(object.multi)\n        ? SignatureDescriptor_Data_Multi.fromJSON(object.multi)\n        : undefined,\n    };\n  },\n\n  toJSON(message: SignatureDescriptor_Data): unknown {\n    const obj: any = {};\n    message.single !== undefined &&\n      (obj.single = message.single\n        ? SignatureDescriptor_Data_Single.toJSON(message.single)\n        : undefined);\n    message.multi !== undefined &&\n      (obj.multi = message.multi\n        ? SignatureDescriptor_Data_Multi.toJSON(message.multi)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SignatureDescriptor_Data>, I>>(\n    object: I\n  ): SignatureDescriptor_Data {\n    const message = createBaseSignatureDescriptor_Data();\n    message.single =\n      object.single !== undefined && object.single !== null\n        ? SignatureDescriptor_Data_Single.fromPartial(object.single)\n        : undefined;\n    message.multi =\n      object.multi !== undefined && object.multi !== null\n        ? SignatureDescriptor_Data_Multi.fromPartial(object.multi)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseSignatureDescriptor_Data_Single(): SignatureDescriptor_Data_Single {\n  return { mode: 0, signature: new Uint8Array() };\n}\n\nexport const SignatureDescriptor_Data_Single = {\n  encode(\n    message: SignatureDescriptor_Data_Single,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.mode !== 0) {\n      writer.uint32(8).int32(message.mode);\n    }\n    if (message.signature.length !== 0) {\n      writer.uint32(18).bytes(message.signature);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): SignatureDescriptor_Data_Single {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSignatureDescriptor_Data_Single();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.mode = reader.int32() as any;\n          break;\n        case 2:\n          message.signature = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SignatureDescriptor_Data_Single {\n    return {\n      mode: isSet(object.mode) ? signModeFromJSON(object.mode) : 0,\n      signature: isSet(object.signature)\n        ? bytesFromBase64(object.signature)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: SignatureDescriptor_Data_Single): unknown {\n    const obj: any = {};\n    message.mode !== undefined && (obj.mode = signModeToJSON(message.mode));\n    message.signature !== undefined &&\n      (obj.signature = base64FromBytes(\n        message.signature !== undefined ? message.signature : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SignatureDescriptor_Data_Single>, I>>(\n    object: I\n  ): SignatureDescriptor_Data_Single {\n    const message = createBaseSignatureDescriptor_Data_Single();\n    message.mode = object.mode ?? 0;\n    message.signature = object.signature ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBaseSignatureDescriptor_Data_Multi(): SignatureDescriptor_Data_Multi {\n  return { bitarray: undefined, signatures: [] };\n}\n\nexport const SignatureDescriptor_Data_Multi = {\n  encode(\n    message: SignatureDescriptor_Data_Multi,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.bitarray !== undefined) {\n      CompactBitArray.encode(\n        message.bitarray,\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    for (const v of message.signatures) {\n      SignatureDescriptor_Data.encode(v!, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): SignatureDescriptor_Data_Multi {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSignatureDescriptor_Data_Multi();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.bitarray = CompactBitArray.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.signatures.push(\n            SignatureDescriptor_Data.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SignatureDescriptor_Data_Multi {\n    return {\n      bitarray: isSet(object.bitarray)\n        ? CompactBitArray.fromJSON(object.bitarray)\n        : undefined,\n      signatures: Array.isArray(object?.signatures)\n        ? object.signatures.map((e: any) =>\n            SignatureDescriptor_Data.fromJSON(e)\n          )\n        : [],\n    };\n  },\n\n  toJSON(message: SignatureDescriptor_Data_Multi): unknown {\n    const obj: any = {};\n    message.bitarray !== undefined &&\n      (obj.bitarray = message.bitarray\n        ? CompactBitArray.toJSON(message.bitarray)\n        : undefined);\n    if (message.signatures) {\n      obj.signatures = message.signatures.map((e) =>\n        e ? SignatureDescriptor_Data.toJSON(e) : undefined\n      );\n    } else {\n      obj.signatures = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SignatureDescriptor_Data_Multi>, I>>(\n    object: I\n  ): SignatureDescriptor_Data_Multi {\n    const message = createBaseSignatureDescriptor_Data_Multi();\n    message.bitarray =\n      object.bitarray !== undefined && object.bitarray !== null\n        ? CompactBitArray.fromPartial(object.bitarray)\n        : undefined;\n    message.signatures =\n      object.signatures?.map((e) => SignatureDescriptor_Data.fromPartial(e)) ||\n      [];\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Any } from \"../../../google/protobuf/any\";\nimport {\n  SignMode,\n  signModeFromJSON,\n  signModeToJSON,\n} from \"../signing/v1beta1/signing\";\nimport { CompactBitArray } from \"../../crypto/multisig/v1beta1/multisig\";\nimport { Coin } from \"../../base/v1beta1/coin\";\n\nexport const protobufPackage = \"cosmos.tx.v1beta1\";\n\n/** Tx is the standard type used for broadcasting transactions. */\nexport interface Tx {\n  /** body is the processable content of the transaction */\n  body?: TxBody;\n  /**\n   * auth_info is the authorization related content of the transaction,\n   * specifically signers, signer modes and fee\n   */\n  authInfo?: AuthInfo;\n  /**\n   * signatures is a list of signatures that matches the length and order of\n   * AuthInfo's signer_infos to allow connecting signature meta information like\n   * public key and signing mode by position.\n   */\n  signatures: Uint8Array[];\n}\n\n/**\n * TxRaw is a variant of Tx that pins the signer's exact binary representation\n * of body and auth_info. This is used for signing, broadcasting and\n * verification. The binary `serialize(tx: TxRaw)` is stored in Tendermint and\n * the hash `sha256(serialize(tx: TxRaw))` becomes the \"txhash\", commonly used\n * as the transaction ID.\n */\nexport interface TxRaw {\n  /**\n   * body_bytes is a protobuf serialization of a TxBody that matches the\n   * representation in SignDoc.\n   */\n  bodyBytes: Uint8Array;\n  /**\n   * auth_info_bytes is a protobuf serialization of an AuthInfo that matches the\n   * representation in SignDoc.\n   */\n  authInfoBytes: Uint8Array;\n  /**\n   * signatures is a list of signatures that matches the length and order of\n   * AuthInfo's signer_infos to allow connecting signature meta information like\n   * public key and signing mode by position.\n   */\n  signatures: Uint8Array[];\n}\n\n/** SignDoc is the type used for generating sign bytes for SIGN_MODE_DIRECT. */\nexport interface SignDoc {\n  /**\n   * body_bytes is protobuf serialization of a TxBody that matches the\n   * representation in TxRaw.\n   */\n  bodyBytes: Uint8Array;\n  /**\n   * auth_info_bytes is a protobuf serialization of an AuthInfo that matches the\n   * representation in TxRaw.\n   */\n  authInfoBytes: Uint8Array;\n  /**\n   * chain_id is the unique identifier of the chain this transaction targets.\n   * It prevents signed transactions from being used on another chain by an\n   * attacker\n   */\n  chainId: string;\n  /** account_number is the account number of the account in state */\n  accountNumber: Long;\n}\n\n/** TxBody is the body of a transaction that all signers sign over. */\nexport interface TxBody {\n  /**\n   * messages is a list of messages to be executed. The required signers of\n   * those messages define the number and order of elements in AuthInfo's\n   * signer_infos and Tx's signatures. Each required signer address is added to\n   * the list only the first time it occurs.\n   * By convention, the first required signer (usually from the first message)\n   * is referred to as the primary signer and pays the fee for the whole\n   * transaction.\n   */\n  messages: Any[];\n  /**\n   * memo is any arbitrary note/comment to be added to the transaction.\n   * WARNING: in clients, any publicly exposed text should not be called memo,\n   * but should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122).\n   */\n  memo: string;\n  /**\n   * timeout is the block height after which this transaction will not\n   * be processed by the chain\n   */\n  timeoutHeight: Long;\n  /**\n   * extension_options are arbitrary options that can be added by chains\n   * when the default options are not sufficient. If any of these are present\n   * and can't be handled, the transaction will be rejected\n   */\n  extensionOptions: Any[];\n  /**\n   * extension_options are arbitrary options that can be added by chains\n   * when the default options are not sufficient. If any of these are present\n   * and can't be handled, they will be ignored\n   */\n  nonCriticalExtensionOptions: Any[];\n}\n\n/**\n * AuthInfo describes the fee and signer modes that are used to sign a\n * transaction.\n */\nexport interface AuthInfo {\n  /**\n   * signer_infos defines the signing modes for the required signers. The number\n   * and order of elements must match the required signers from TxBody's\n   * messages. The first element is the primary signer and the one which pays\n   * the fee.\n   */\n  signerInfos: SignerInfo[];\n  /**\n   * Fee is the fee and gas limit for the transaction. The first signer is the\n   * primary signer and the one which pays the fee. The fee can be calculated\n   * based on the cost of evaluating the body and doing signature verification\n   * of the signers. This can be estimated via simulation.\n   */\n  fee?: Fee;\n}\n\n/**\n * SignerInfo describes the public key and signing mode of a single top-level\n * signer.\n */\nexport interface SignerInfo {\n  /**\n   * public_key is the public key of the signer. It is optional for accounts\n   * that already exist in state. If unset, the verifier can use the required \\\n   * signer address for this position and lookup the public key.\n   */\n  publicKey?: Any;\n  /**\n   * mode_info describes the signing mode of the signer and is a nested\n   * structure to support nested multisig pubkey's\n   */\n  modeInfo?: ModeInfo;\n  /**\n   * sequence is the sequence of the account, which describes the\n   * number of committed transactions signed by a given address. It is used to\n   * prevent replay attacks.\n   */\n  sequence: Long;\n}\n\n/** ModeInfo describes the signing mode of a single or nested multisig signer. */\nexport interface ModeInfo {\n  /** single represents a single signer */\n  single?: ModeInfo_Single | undefined;\n  /** multi represents a nested multisig signer */\n  multi?: ModeInfo_Multi | undefined;\n}\n\n/**\n * Single is the mode info for a single signer. It is structured as a message\n * to allow for additional fields such as locale for SIGN_MODE_TEXTUAL in the\n * future\n */\nexport interface ModeInfo_Single {\n  /** mode is the signing mode of the single signer */\n  mode: SignMode;\n}\n\n/** Multi is the mode info for a multisig public key */\nexport interface ModeInfo_Multi {\n  /** bitarray specifies which keys within the multisig are signing */\n  bitarray?: CompactBitArray;\n  /**\n   * mode_infos is the corresponding modes of the signers of the multisig\n   * which could include nested multisig public keys\n   */\n  modeInfos: ModeInfo[];\n}\n\n/**\n * Fee includes the amount of coins paid in fees and the maximum\n * gas to be used by the transaction. The ratio yields an effective \"gasprice\",\n * which must be above some miminum to be accepted into the mempool.\n */\nexport interface Fee {\n  /** amount is the amount of coins to be paid as a fee */\n  amount: Coin[];\n  /**\n   * gas_limit is the maximum gas that can be used in transaction processing\n   * before an out of gas error occurs\n   */\n  gasLimit: Long;\n  /**\n   * if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees.\n   * the payer must be a tx signer (and thus have signed this field in AuthInfo).\n   * setting this field does *not* change the ordering of required signers for the transaction.\n   */\n  payer: string;\n  /**\n   * if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used\n   * to pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does\n   * not support fee grants, this will fail\n   */\n  granter: string;\n}\n\nfunction createBaseTx(): Tx {\n  return { body: undefined, authInfo: undefined, signatures: [] };\n}\n\nexport const Tx = {\n  encode(message: Tx, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (message.body !== undefined) {\n      TxBody.encode(message.body, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.authInfo !== undefined) {\n      AuthInfo.encode(message.authInfo, writer.uint32(18).fork()).ldelim();\n    }\n    for (const v of message.signatures) {\n      writer.uint32(26).bytes(v!);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Tx {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTx();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.body = TxBody.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.authInfo = AuthInfo.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.signatures.push(reader.bytes());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Tx {\n    return {\n      body: isSet(object.body) ? TxBody.fromJSON(object.body) : undefined,\n      authInfo: isSet(object.authInfo)\n        ? AuthInfo.fromJSON(object.authInfo)\n        : undefined,\n      signatures: Array.isArray(object?.signatures)\n        ? object.signatures.map((e: any) => bytesFromBase64(e))\n        : [],\n    };\n  },\n\n  toJSON(message: Tx): unknown {\n    const obj: any = {};\n    message.body !== undefined &&\n      (obj.body = message.body ? TxBody.toJSON(message.body) : undefined);\n    message.authInfo !== undefined &&\n      (obj.authInfo = message.authInfo\n        ? AuthInfo.toJSON(message.authInfo)\n        : undefined);\n    if (message.signatures) {\n      obj.signatures = message.signatures.map((e) =>\n        base64FromBytes(e !== undefined ? e : new Uint8Array())\n      );\n    } else {\n      obj.signatures = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Tx>, I>>(object: I): Tx {\n    const message = createBaseTx();\n    message.body =\n      object.body !== undefined && object.body !== null\n        ? TxBody.fromPartial(object.body)\n        : undefined;\n    message.authInfo =\n      object.authInfo !== undefined && object.authInfo !== null\n        ? AuthInfo.fromPartial(object.authInfo)\n        : undefined;\n    message.signatures = object.signatures?.map((e) => e) || [];\n    return message;\n  },\n};\n\nfunction createBaseTxRaw(): TxRaw {\n  return {\n    bodyBytes: new Uint8Array(),\n    authInfoBytes: new Uint8Array(),\n    signatures: [],\n  };\n}\n\nexport const TxRaw = {\n  encode(message: TxRaw, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (message.bodyBytes.length !== 0) {\n      writer.uint32(10).bytes(message.bodyBytes);\n    }\n    if (message.authInfoBytes.length !== 0) {\n      writer.uint32(18).bytes(message.authInfoBytes);\n    }\n    for (const v of message.signatures) {\n      writer.uint32(26).bytes(v!);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): TxRaw {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTxRaw();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.bodyBytes = reader.bytes();\n          break;\n        case 2:\n          message.authInfoBytes = reader.bytes();\n          break;\n        case 3:\n          message.signatures.push(reader.bytes());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): TxRaw {\n    return {\n      bodyBytes: isSet(object.bodyBytes)\n        ? bytesFromBase64(object.bodyBytes)\n        : new Uint8Array(),\n      authInfoBytes: isSet(object.authInfoBytes)\n        ? bytesFromBase64(object.authInfoBytes)\n        : new Uint8Array(),\n      signatures: Array.isArray(object?.signatures)\n        ? object.signatures.map((e: any) => bytesFromBase64(e))\n        : [],\n    };\n  },\n\n  toJSON(message: TxRaw): unknown {\n    const obj: any = {};\n    message.bodyBytes !== undefined &&\n      (obj.bodyBytes = base64FromBytes(\n        message.bodyBytes !== undefined ? message.bodyBytes : new Uint8Array()\n      ));\n    message.authInfoBytes !== undefined &&\n      (obj.authInfoBytes = base64FromBytes(\n        message.authInfoBytes !== undefined\n          ? message.authInfoBytes\n          : new Uint8Array()\n      ));\n    if (message.signatures) {\n      obj.signatures = message.signatures.map((e) =>\n        base64FromBytes(e !== undefined ? e : new Uint8Array())\n      );\n    } else {\n      obj.signatures = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<TxRaw>, I>>(object: I): TxRaw {\n    const message = createBaseTxRaw();\n    message.bodyBytes = object.bodyBytes ?? new Uint8Array();\n    message.authInfoBytes = object.authInfoBytes ?? new Uint8Array();\n    message.signatures = object.signatures?.map((e) => e) || [];\n    return message;\n  },\n};\n\nfunction createBaseSignDoc(): SignDoc {\n  return {\n    bodyBytes: new Uint8Array(),\n    authInfoBytes: new Uint8Array(),\n    chainId: \"\",\n    accountNumber: Long.UZERO,\n  };\n}\n\nexport const SignDoc = {\n  encode(\n    message: SignDoc,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.bodyBytes.length !== 0) {\n      writer.uint32(10).bytes(message.bodyBytes);\n    }\n    if (message.authInfoBytes.length !== 0) {\n      writer.uint32(18).bytes(message.authInfoBytes);\n    }\n    if (message.chainId !== \"\") {\n      writer.uint32(26).string(message.chainId);\n    }\n    if (!message.accountNumber.isZero()) {\n      writer.uint32(32).uint64(message.accountNumber);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): SignDoc {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSignDoc();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.bodyBytes = reader.bytes();\n          break;\n        case 2:\n          message.authInfoBytes = reader.bytes();\n          break;\n        case 3:\n          message.chainId = reader.string();\n          break;\n        case 4:\n          message.accountNumber = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SignDoc {\n    return {\n      bodyBytes: isSet(object.bodyBytes)\n        ? bytesFromBase64(object.bodyBytes)\n        : new Uint8Array(),\n      authInfoBytes: isSet(object.authInfoBytes)\n        ? bytesFromBase64(object.authInfoBytes)\n        : new Uint8Array(),\n      chainId: isSet(object.chainId) ? String(object.chainId) : \"\",\n      accountNumber: isSet(object.accountNumber)\n        ? Long.fromValue(object.accountNumber)\n        : Long.UZERO,\n    };\n  },\n\n  toJSON(message: SignDoc): unknown {\n    const obj: any = {};\n    message.bodyBytes !== undefined &&\n      (obj.bodyBytes = base64FromBytes(\n        message.bodyBytes !== undefined ? message.bodyBytes : new Uint8Array()\n      ));\n    message.authInfoBytes !== undefined &&\n      (obj.authInfoBytes = base64FromBytes(\n        message.authInfoBytes !== undefined\n          ? message.authInfoBytes\n          : new Uint8Array()\n      ));\n    message.chainId !== undefined && (obj.chainId = message.chainId);\n    message.accountNumber !== undefined &&\n      (obj.accountNumber = (message.accountNumber || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SignDoc>, I>>(object: I): SignDoc {\n    const message = createBaseSignDoc();\n    message.bodyBytes = object.bodyBytes ?? new Uint8Array();\n    message.authInfoBytes = object.authInfoBytes ?? new Uint8Array();\n    message.chainId = object.chainId ?? \"\";\n    message.accountNumber =\n      object.accountNumber !== undefined && object.accountNumber !== null\n        ? Long.fromValue(object.accountNumber)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseTxBody(): TxBody {\n  return {\n    messages: [],\n    memo: \"\",\n    timeoutHeight: Long.UZERO,\n    extensionOptions: [],\n    nonCriticalExtensionOptions: [],\n  };\n}\n\nexport const TxBody = {\n  encode(\n    message: TxBody,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.messages) {\n      Any.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.memo !== \"\") {\n      writer.uint32(18).string(message.memo);\n    }\n    if (!message.timeoutHeight.isZero()) {\n      writer.uint32(24).uint64(message.timeoutHeight);\n    }\n    for (const v of message.extensionOptions) {\n      Any.encode(v!, writer.uint32(8186).fork()).ldelim();\n    }\n    for (const v of message.nonCriticalExtensionOptions) {\n      Any.encode(v!, writer.uint32(16378).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): TxBody {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTxBody();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.messages.push(Any.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.memo = reader.string();\n          break;\n        case 3:\n          message.timeoutHeight = reader.uint64() as Long;\n          break;\n        case 1023:\n          message.extensionOptions.push(Any.decode(reader, reader.uint32()));\n          break;\n        case 2047:\n          message.nonCriticalExtensionOptions.push(\n            Any.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): TxBody {\n    return {\n      messages: Array.isArray(object?.messages)\n        ? object.messages.map((e: any) => Any.fromJSON(e))\n        : [],\n      memo: isSet(object.memo) ? String(object.memo) : \"\",\n      timeoutHeight: isSet(object.timeoutHeight)\n        ? Long.fromValue(object.timeoutHeight)\n        : Long.UZERO,\n      extensionOptions: Array.isArray(object?.extensionOptions)\n        ? object.extensionOptions.map((e: any) => Any.fromJSON(e))\n        : [],\n      nonCriticalExtensionOptions: Array.isArray(\n        object?.nonCriticalExtensionOptions\n      )\n        ? object.nonCriticalExtensionOptions.map((e: any) => Any.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: TxBody): unknown {\n    const obj: any = {};\n    if (message.messages) {\n      obj.messages = message.messages.map((e) =>\n        e ? Any.toJSON(e) : undefined\n      );\n    } else {\n      obj.messages = [];\n    }\n    message.memo !== undefined && (obj.memo = message.memo);\n    message.timeoutHeight !== undefined &&\n      (obj.timeoutHeight = (message.timeoutHeight || Long.UZERO).toString());\n    if (message.extensionOptions) {\n      obj.extensionOptions = message.extensionOptions.map((e) =>\n        e ? Any.toJSON(e) : undefined\n      );\n    } else {\n      obj.extensionOptions = [];\n    }\n    if (message.nonCriticalExtensionOptions) {\n      obj.nonCriticalExtensionOptions = message.nonCriticalExtensionOptions.map(\n        (e) => (e ? Any.toJSON(e) : undefined)\n      );\n    } else {\n      obj.nonCriticalExtensionOptions = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<TxBody>, I>>(object: I): TxBody {\n    const message = createBaseTxBody();\n    message.messages = object.messages?.map((e) => Any.fromPartial(e)) || [];\n    message.memo = object.memo ?? \"\";\n    message.timeoutHeight =\n      object.timeoutHeight !== undefined && object.timeoutHeight !== null\n        ? Long.fromValue(object.timeoutHeight)\n        : Long.UZERO;\n    message.extensionOptions =\n      object.extensionOptions?.map((e) => Any.fromPartial(e)) || [];\n    message.nonCriticalExtensionOptions =\n      object.nonCriticalExtensionOptions?.map((e) => Any.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseAuthInfo(): AuthInfo {\n  return { signerInfos: [], fee: undefined };\n}\n\nexport const AuthInfo = {\n  encode(\n    message: AuthInfo,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.signerInfos) {\n      SignerInfo.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.fee !== undefined) {\n      Fee.encode(message.fee, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): AuthInfo {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseAuthInfo();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.signerInfos.push(SignerInfo.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.fee = Fee.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): AuthInfo {\n    return {\n      signerInfos: Array.isArray(object?.signerInfos)\n        ? object.signerInfos.map((e: any) => SignerInfo.fromJSON(e))\n        : [],\n      fee: isSet(object.fee) ? Fee.fromJSON(object.fee) : undefined,\n    };\n  },\n\n  toJSON(message: AuthInfo): unknown {\n    const obj: any = {};\n    if (message.signerInfos) {\n      obj.signerInfos = message.signerInfos.map((e) =>\n        e ? SignerInfo.toJSON(e) : undefined\n      );\n    } else {\n      obj.signerInfos = [];\n    }\n    message.fee !== undefined &&\n      (obj.fee = message.fee ? Fee.toJSON(message.fee) : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<AuthInfo>, I>>(object: I): AuthInfo {\n    const message = createBaseAuthInfo();\n    message.signerInfos =\n      object.signerInfos?.map((e) => SignerInfo.fromPartial(e)) || [];\n    message.fee =\n      object.fee !== undefined && object.fee !== null\n        ? Fee.fromPartial(object.fee)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseSignerInfo(): SignerInfo {\n  return { publicKey: undefined, modeInfo: undefined, sequence: Long.UZERO };\n}\n\nexport const SignerInfo = {\n  encode(\n    message: SignerInfo,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.publicKey !== undefined) {\n      Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.modeInfo !== undefined) {\n      ModeInfo.encode(message.modeInfo, writer.uint32(18).fork()).ldelim();\n    }\n    if (!message.sequence.isZero()) {\n      writer.uint32(24).uint64(message.sequence);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): SignerInfo {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSignerInfo();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.publicKey = Any.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.modeInfo = ModeInfo.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.sequence = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SignerInfo {\n    return {\n      publicKey: isSet(object.publicKey)\n        ? Any.fromJSON(object.publicKey)\n        : undefined,\n      modeInfo: isSet(object.modeInfo)\n        ? ModeInfo.fromJSON(object.modeInfo)\n        : undefined,\n      sequence: isSet(object.sequence)\n        ? Long.fromValue(object.sequence)\n        : Long.UZERO,\n    };\n  },\n\n  toJSON(message: SignerInfo): unknown {\n    const obj: any = {};\n    message.publicKey !== undefined &&\n      (obj.publicKey = message.publicKey\n        ? Any.toJSON(message.publicKey)\n        : undefined);\n    message.modeInfo !== undefined &&\n      (obj.modeInfo = message.modeInfo\n        ? ModeInfo.toJSON(message.modeInfo)\n        : undefined);\n    message.sequence !== undefined &&\n      (obj.sequence = (message.sequence || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SignerInfo>, I>>(\n    object: I\n  ): SignerInfo {\n    const message = createBaseSignerInfo();\n    message.publicKey =\n      object.publicKey !== undefined && object.publicKey !== null\n        ? Any.fromPartial(object.publicKey)\n        : undefined;\n    message.modeInfo =\n      object.modeInfo !== undefined && object.modeInfo !== null\n        ? ModeInfo.fromPartial(object.modeInfo)\n        : undefined;\n    message.sequence =\n      object.sequence !== undefined && object.sequence !== null\n        ? Long.fromValue(object.sequence)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseModeInfo(): ModeInfo {\n  return { single: undefined, multi: undefined };\n}\n\nexport const ModeInfo = {\n  encode(\n    message: ModeInfo,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.single !== undefined) {\n      ModeInfo_Single.encode(message.single, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.multi !== undefined) {\n      ModeInfo_Multi.encode(message.multi, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): ModeInfo {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseModeInfo();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.single = ModeInfo_Single.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.multi = ModeInfo_Multi.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ModeInfo {\n    return {\n      single: isSet(object.single)\n        ? ModeInfo_Single.fromJSON(object.single)\n        : undefined,\n      multi: isSet(object.multi)\n        ? ModeInfo_Multi.fromJSON(object.multi)\n        : undefined,\n    };\n  },\n\n  toJSON(message: ModeInfo): unknown {\n    const obj: any = {};\n    message.single !== undefined &&\n      (obj.single = message.single\n        ? ModeInfo_Single.toJSON(message.single)\n        : undefined);\n    message.multi !== undefined &&\n      (obj.multi = message.multi\n        ? ModeInfo_Multi.toJSON(message.multi)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<ModeInfo>, I>>(object: I): ModeInfo {\n    const message = createBaseModeInfo();\n    message.single =\n      object.single !== undefined && object.single !== null\n        ? ModeInfo_Single.fromPartial(object.single)\n        : undefined;\n    message.multi =\n      object.multi !== undefined && object.multi !== null\n        ? ModeInfo_Multi.fromPartial(object.multi)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseModeInfo_Single(): ModeInfo_Single {\n  return { mode: 0 };\n}\n\nexport const ModeInfo_Single = {\n  encode(\n    message: ModeInfo_Single,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.mode !== 0) {\n      writer.uint32(8).int32(message.mode);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): ModeInfo_Single {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseModeInfo_Single();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.mode = reader.int32() as any;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ModeInfo_Single {\n    return {\n      mode: isSet(object.mode) ? signModeFromJSON(object.mode) : 0,\n    };\n  },\n\n  toJSON(message: ModeInfo_Single): unknown {\n    const obj: any = {};\n    message.mode !== undefined && (obj.mode = signModeToJSON(message.mode));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<ModeInfo_Single>, I>>(\n    object: I\n  ): ModeInfo_Single {\n    const message = createBaseModeInfo_Single();\n    message.mode = object.mode ?? 0;\n    return message;\n  },\n};\n\nfunction createBaseModeInfo_Multi(): ModeInfo_Multi {\n  return { bitarray: undefined, modeInfos: [] };\n}\n\nexport const ModeInfo_Multi = {\n  encode(\n    message: ModeInfo_Multi,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.bitarray !== undefined) {\n      CompactBitArray.encode(\n        message.bitarray,\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    for (const v of message.modeInfos) {\n      ModeInfo.encode(v!, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): ModeInfo_Multi {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseModeInfo_Multi();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.bitarray = CompactBitArray.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.modeInfos.push(ModeInfo.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ModeInfo_Multi {\n    return {\n      bitarray: isSet(object.bitarray)\n        ? CompactBitArray.fromJSON(object.bitarray)\n        : undefined,\n      modeInfos: Array.isArray(object?.modeInfos)\n        ? object.modeInfos.map((e: any) => ModeInfo.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: ModeInfo_Multi): unknown {\n    const obj: any = {};\n    message.bitarray !== undefined &&\n      (obj.bitarray = message.bitarray\n        ? CompactBitArray.toJSON(message.bitarray)\n        : undefined);\n    if (message.modeInfos) {\n      obj.modeInfos = message.modeInfos.map((e) =>\n        e ? ModeInfo.toJSON(e) : undefined\n      );\n    } else {\n      obj.modeInfos = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<ModeInfo_Multi>, I>>(\n    object: I\n  ): ModeInfo_Multi {\n    const message = createBaseModeInfo_Multi();\n    message.bitarray =\n      object.bitarray !== undefined && object.bitarray !== null\n        ? CompactBitArray.fromPartial(object.bitarray)\n        : undefined;\n    message.modeInfos =\n      object.modeInfos?.map((e) => ModeInfo.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseFee(): Fee {\n  return { amount: [], gasLimit: Long.UZERO, payer: \"\", granter: \"\" };\n}\n\nexport const Fee = {\n  encode(message: Fee, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    for (const v of message.amount) {\n      Coin.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    if (!message.gasLimit.isZero()) {\n      writer.uint32(16).uint64(message.gasLimit);\n    }\n    if (message.payer !== \"\") {\n      writer.uint32(26).string(message.payer);\n    }\n    if (message.granter !== \"\") {\n      writer.uint32(34).string(message.granter);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Fee {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseFee();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.amount.push(Coin.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.gasLimit = reader.uint64() as Long;\n          break;\n        case 3:\n          message.payer = reader.string();\n          break;\n        case 4:\n          message.granter = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Fee {\n    return {\n      amount: Array.isArray(object?.amount)\n        ? object.amount.map((e: any) => Coin.fromJSON(e))\n        : [],\n      gasLimit: isSet(object.gasLimit)\n        ? Long.fromValue(object.gasLimit)\n        : Long.UZERO,\n      payer: isSet(object.payer) ? String(object.payer) : \"\",\n      granter: isSet(object.granter) ? String(object.granter) : \"\",\n    };\n  },\n\n  toJSON(message: Fee): unknown {\n    const obj: any = {};\n    if (message.amount) {\n      obj.amount = message.amount.map((e) => (e ? Coin.toJSON(e) : undefined));\n    } else {\n      obj.amount = [];\n    }\n    message.gasLimit !== undefined &&\n      (obj.gasLimit = (message.gasLimit || Long.UZERO).toString());\n    message.payer !== undefined && (obj.payer = message.payer);\n    message.granter !== undefined && (obj.granter = message.granter);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Fee>, I>>(object: I): Fee {\n    const message = createBaseFee();\n    message.amount = object.amount?.map((e) => Coin.fromPartial(e)) || [];\n    message.gasLimit =\n      object.gasLimit !== undefined && object.gasLimit !== null\n        ? Long.fromValue(object.gasLimit)\n        : Long.UZERO;\n    message.payer = object.payer ?? \"\";\n    message.granter = object.granter ?? \"\";\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","import invariant from \"tiny-invariant\";\nimport {APIClient} from \"./APIClient\";\nimport {\n  GeneratedType,\n  OfflineSigner,\n  Registry,\n  TxBodyEncodeObject,\n} from \"@cosmjs/proto-signing\";\nimport { Any } from \"cosmjs-types/google/protobuf/any\";\nimport {\n  BaseMsg,\n\n  MsgGrant,\n  MsgExec,\n  MsgRevoke,\n  MsgSend,\n  MsgMultiSend,\n  MsgVerifyInvariant,\n  MsgFundCommunityPool,\n  MsgSetWithdrawAddress,\n  MsgWithdrawDelegatorReward,\n  MsgWithdrawValidatorCommission,\n  MsgSubmitEvidence,\n  MsgGrantAllowance,\n  MsgRevokeAllowance,\n  MsgCreateVestingAccount,\n  MsgGovRepurchase,\n  MsgEthereumTx,\n  MsgSendNft,\n  MsgCreateRandSwapRewardConfig,\n  MsgOpenRandSwapReward,\n  MsgCloseRandSwapReward,\n  MsgUpdateRandSwapRewardConfig,\n  MsgCreateLiquidityRewardConfig,\n  MsgUpdateLiquidityRewardConfig,\n  MsgOpenLiquidityReward,\n  MsgCloseLiquidityReward,\n  MsgCollectFeeProtocol,\n  MsgGovCorePool,\n  MsgIssue,\n  MsgMint,\n  MsgBurn,\n  MsgTransferOwnership,\n  MsgConfirmOwnership,\n  MsgStoreCode,\n\n  MsgCollect,\n  MsgCollectReward,\n  MsgCreatePool,\n  MsgCreatePosition,\n  MsgDecreaseLiquidity,\n  MsgIncreaseLiquidity,\n  MsgSwapExactIn,\n  MsgSwapExactOut,\n  MsgSubmitProposal,\n  MsgDeposit,\n  MsgVote,\n  MsgVoteWeighted,\n  MsgCreateValidator,\n  MsgEditValidator,\n  MsgDelegate,\n  MsgBeginRedelegate,\n  MsgUndelegate,\n  MsgCollectRandSwapReward\n} from \"../msgs\";\nimport { SigningStargateClient } from \"@cosmjs/stargate\";\nimport { PubKey } from \"../proto/cosmos/crypto/secp256k1/keys\";\nimport {\n  SignerInfo,\n  ModeInfo,\n  ModeInfo_Single,\n  Fee,\n  AuthInfo,\n  SignDoc,\n  TxRaw,\n} from \"../proto/cosmos/tx/v1beta1/tx\";\nimport { SignMode } from \"../proto/cosmos/tx/signing/v1beta1/signing\";\nimport { Coin } from \"../proto/cosmos/base/v1beta1/coin\";\nimport { fromBase64, toBase64 } from \"@cosmjs/encoding\";\nimport {Chain_Id, CHAIN_NAMES, NETWORK_DETAILS} from \"../constants\";\n\nexport interface ISender {\n  address: string;\n  pubkey: Uint8Array;\n  accountNumber: number;\n  sequence: number;\n}\n\nexport interface TxGenerated {\n  signDirect: {\n    body: TxBodyEncodeObject;\n    authInfo: AuthInfo;\n    signBytes: string;\n  };\n}\n\nexport const SIGN_DIRECT = SignMode.SIGN_MODE_DIRECT;\n\nexport class TxClient {\n  public chainId: Chain_Id;\n  public apiClient: APIClient;\n  public rpcUrl: string;\n  public accountAddress: string;\n  public signer: OfflineSigner;\n  public registry: Registry;\n\n  // public walletClient: SigningStargateClient | null = null;\n  // public sender: ISender | null = null;\n\n  constructor(\n    chainId: Chain_Id,\n    apiClient: APIClient,\n    rpcUrl: string,\n    signer: OfflineSigner,\n    accountAddress: string,\n  ) {\n    invariant(!!signer, \"wallet is required!\");\n\n    this.chainId = chainId;\n    this.apiClient = apiClient;\n    this.rpcUrl = rpcUrl;\n    this.signer = signer;\n    this.accountAddress = accountAddress;\n\n    const registryTypes = new Map<string, GeneratedType>();\n\n    registryTypes.set(MsgGrant.typeUrl, MsgGrant.Proto);\n    registryTypes.set(MsgExec.typeUrl, MsgExec.Proto);\n    registryTypes.set(MsgRevoke.typeUrl, MsgRevoke.Proto);\n    registryTypes.set(MsgSend.typeUrl, MsgSend.Proto);\n    registryTypes.set(MsgMultiSend.typeUrl, MsgMultiSend.Proto);\n    registryTypes.set(MsgVerifyInvariant.typeUrl, MsgVerifyInvariant.Proto);\n    registryTypes.set(MsgFundCommunityPool.typeUrl, MsgFundCommunityPool.Proto);\n    registryTypes.set(MsgSetWithdrawAddress.typeUrl, MsgSetWithdrawAddress.Proto);\n    registryTypes.set(MsgWithdrawDelegatorReward.typeUrl, MsgWithdrawDelegatorReward.Proto);\n    registryTypes.set(MsgWithdrawValidatorCommission.typeUrl, MsgWithdrawValidatorCommission.Proto);\n    registryTypes.set(MsgSubmitEvidence.typeUrl, MsgSubmitEvidence.Proto);\n    registryTypes.set(MsgGrantAllowance.typeUrl, MsgGrantAllowance.Proto);\n    registryTypes.set(MsgRevokeAllowance.typeUrl, MsgRevokeAllowance.Proto);\n    registryTypes.set(MsgCreateVestingAccount.typeUrl, MsgCreateVestingAccount.Proto);\n    registryTypes.set(MsgGovRepurchase.typeUrl, MsgGovRepurchase.Proto);\n    registryTypes.set(MsgEthereumTx.typeUrl, MsgEthereumTx.Proto);\n    registryTypes.set(MsgSendNft.typeUrl, MsgSendNft.Proto);\n    registryTypes.set(MsgCreateRandSwapRewardConfig.typeUrl, MsgCreateRandSwapRewardConfig.Proto);\n    registryTypes.set(MsgOpenRandSwapReward.typeUrl, MsgOpenRandSwapReward.Proto);\n    registryTypes.set(MsgCloseRandSwapReward.typeUrl, MsgCloseRandSwapReward.Proto);\n    registryTypes.set(MsgUpdateRandSwapRewardConfig.typeUrl, MsgUpdateRandSwapRewardConfig.Proto);\n    registryTypes.set(MsgCreateLiquidityRewardConfig.typeUrl, MsgCreateLiquidityRewardConfig.Proto);\n    registryTypes.set(MsgUpdateLiquidityRewardConfig.typeUrl, MsgUpdateLiquidityRewardConfig.Proto);\n    registryTypes.set(MsgOpenLiquidityReward.typeUrl, MsgOpenLiquidityReward.Proto);\n    registryTypes.set(MsgCloseLiquidityReward.typeUrl, MsgCloseLiquidityReward.Proto);\n    registryTypes.set(MsgCollectFeeProtocol.typeUrl, MsgCollectFeeProtocol.Proto);\n    registryTypes.set(MsgGovCorePool.typeUrl, MsgGovCorePool.Proto);\n    registryTypes.set(MsgIssue.typeUrl, MsgIssue.Proto);\n    registryTypes.set(MsgMint.typeUrl, MsgMint.Proto);\n    registryTypes.set(MsgBurn.typeUrl, MsgBurn.Proto);\n    registryTypes.set(MsgTransferOwnership.typeUrl, MsgTransferOwnership.Proto);\n    registryTypes.set(MsgConfirmOwnership.typeUrl, MsgConfirmOwnership.Proto);\n    registryTypes.set(MsgStoreCode.typeUrl, MsgStoreCode.Proto);\n\n    registryTypes.set(MsgCollect.typeUrl, MsgCollect.Proto);\n    registryTypes.set(MsgCollectReward.typeUrl, MsgCollectReward.Proto);\n    registryTypes.set(MsgCreatePool.typeUrl, MsgCreatePool.Proto);\n    registryTypes.set(MsgCreatePosition.typeUrl, MsgCreatePosition.Proto);\n    registryTypes.set(MsgDecreaseLiquidity.typeUrl, MsgDecreaseLiquidity.Proto);\n    registryTypes.set(MsgIncreaseLiquidity.typeUrl, MsgIncreaseLiquidity.Proto);\n    registryTypes.set(MsgSwapExactIn.typeUrl, MsgSwapExactIn.Proto);\n    registryTypes.set(MsgSwapExactOut.typeUrl, MsgSwapExactOut.Proto);\n    registryTypes.set(MsgSubmitProposal.typeUrl, MsgSubmitProposal.Proto);\n    registryTypes.set(MsgDeposit.typeUrl, MsgDeposit.Proto);\n    registryTypes.set(MsgVote.typeUrl, MsgVote.Proto);\n    registryTypes.set(MsgVoteWeighted.typeUrl, MsgVoteWeighted.Proto);\n    registryTypes.set(MsgCreateValidator.typeUrl, MsgCreateValidator.Proto);\n    registryTypes.set(MsgEditValidator.typeUrl, MsgEditValidator.Proto);\n    registryTypes.set(MsgDelegate.typeUrl, MsgDelegate.Proto);\n    registryTypes.set(MsgBeginRedelegate.typeUrl, MsgBeginRedelegate.Proto);\n    registryTypes.set(MsgUndelegate.typeUrl, MsgUndelegate.Proto);\n    registryTypes.set(MsgCollectRandSwapReward.typeUrl, MsgCollectRandSwapReward.Proto);\n\n    this.registry = new Registry(registryTypes);\n  }\n\n  public async getSender(): Promise<ISender> {\n    const { authAPI } = this.apiClient;\n    const {\n      account: {\n        base_account: {\n          pub_key,\n          account_number,\n          sequence,\n        },\n      },\n    } = await authAPI.accounts(this.accountAddress);\n    const { address, pubkey } = (await this.signer.getAccounts())[0];\n    return {\n      address: this.accountAddress,\n      pubkey,\n      accountNumber: parseInt(account_number),\n      sequence: parseInt(sequence),\n    } as ISender;\n  }\n\n  public async sendTransaction(\n    messages: BaseMsg | Array<BaseMsg>,\n    gasLimit?: number,\n    memo = \"\",\n  ) {\n    const sender = await this.getSender();\n    // const pubKeyDecoded = Buffer.from(sender.pubkey, \"base64\");\n\n    // 1. SignDirect\n    const signInfoDirect = createSignerInfo(\n      sender.pubkey,\n      sender.sequence,\n      SIGN_DIRECT\n    );\n\n    // 2. authInfo\n    let authInfoDirect;\n    if (gasLimit) {\n      // 2. Fee\n      const feeMessage = createFee(\n        '',\n        NETWORK_DETAILS[this.chainId].nativeCurrency.base,\n        gasLimit\n      );\n      authInfoDirect = createAuthInfo(signInfoDirect, feeMessage);\n    } else {\n      authInfoDirect = AuthInfo.fromPartial({\n        signerInfos: [signInfoDirect],\n        fee:{}\n      });\n    }\n\n    // 3. txbody\n    // const body = createBodyWithMultipleMessages(messages, memo);\n    const _messages = messages instanceof Array ? messages : [messages];\n    const body = createTxBodyEncodeObject(_messages, memo);\n\n    // 4. signDoc\n    const signDocDirect = createSigDoc(\n      this.registry.encode(body),\n      AuthInfo.encode(authInfoDirect).finish(),\n      this.chainId,\n      sender.accountNumber\n    );\n\n    // 5. sign\n    let walletClient;\n    walletClient = await SigningStargateClient.connectWithSigner(\n      this.rpcUrl,\n      this.signer,\n      {\n        registry: this.registry,\n        prefix: NETWORK_DETAILS[this.chainId].nativeCurrency.symbol.toLowerCase(),\n      }\n    );\n    // @ts-ignore\n    const { signed, signature } = await walletClient.signer.signDirect(\n      this.accountAddress,\n      signDocDirect\n    );\n\n    const txRaw = TxRaw.fromPartial({\n      bodyBytes: signed.bodyBytes,\n      authInfoBytes: signed.authInfoBytes,\n      signatures: [fromBase64(signature.signature)],\n    });\n    const txBytes = TxRaw.encode(txRaw).finish();\n\n    return walletClient.broadcastTx(txBytes);\n  }\n\n  public async getEstimatedFee(\n    messages: BaseMsg | Array<BaseMsg>,\n    memo: string = \"\"\n  ) {\n    const sender = await this.getSender();\n    // const pubKeyDecoded = Buffer.from(sender.pubkey, \"base64\");\n\n    // 1. SignDirect\n    const signInfoDirect = createSignerInfo(\n      sender.pubkey,\n      sender.sequence,\n      SIGN_DIRECT\n    );\n\n    // 2. authInfo\n    const authInfoDirect = AuthInfo.fromPartial({\n      signerInfos: [signInfoDirect],\n      fee:{}\n    });\n\n    // 3. txbody\n    // const body = createBodyWithMultipleMessages(messages, memo);\n    const _messages = messages instanceof Array ? messages : [messages];\n    const body = createTxBodyEncodeObject(_messages, memo);\n\n    // 4. signDoc\n    const signDocDirect = createSigDoc(\n      this.registry.encode(body),\n      AuthInfo.encode(authInfoDirect).finish(),\n      this.chainId,\n      sender.accountNumber\n    );\n    console.log(signDocDirect);\n\n    const txRaw = TxRaw.fromPartial({\n      bodyBytes: signDocDirect.bodyBytes,\n      authInfoBytes: signDocDirect.authInfoBytes,\n      signatures: [new Uint8Array()],\n    });\n    const txBytes = TxRaw.encode(txRaw).finish();\n\n    const { gasInfo } = await this.apiClient.txAPI.simulate({\n      txBytes\n    });\n\n    console.log('gas_used: ' + gasInfo?.gasUsed);\n\n    return gasInfo?.gasUsed;\n  }\n}\n\nexport function createTxBodyEncodeObject(\n  messages: Array<BaseMsg>,\n  memo: string\n): TxBodyEncodeObject {\n  const results = messages.map((item) => {\n    return item.generateMessage();\n  });\n  return {\n    typeUrl: \"/cosmos.tx.v1beta1.TxBody\",\n    value: {\n      messages: results,\n      memo: memo,\n    },\n  };\n}\n\nexport function createSigDoc(\n  bodyBytes: Uint8Array,\n  authInfoBytes: Uint8Array,\n  chainId: string,\n  accountNumber: number\n) {\n  return SignDoc.fromPartial({\n    bodyBytes,\n    authInfoBytes,\n    chainId,\n    accountNumber,\n  });\n}\n\nfunction createAuthInfo(signerInfo: SignerInfo, fee: Fee) {\n  return AuthInfo.fromPartial({\n    signerInfos: [signerInfo],\n    fee,\n  });\n}\n\nfunction createFee(fee: string, denom: string, gasLimit: number) {\n  return Fee.fromPartial({\n    amount: [\n      Coin.fromPartial({\n        denom,\n        amount: fee,\n      }),\n    ],\n    gasLimit,\n  });\n}\n\nfunction createSignerInfo(\n  publicKey: Uint8Array,\n  sequence: number,\n  mode: number\n) {\n  const pubkey = Any.fromPartial({\n    typeUrl: \"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\n    value: PubKey.encode({\n      key: publicKey,\n    }).finish(),\n  });\n  const signerInfo = SignerInfo.fromPartial({\n    publicKey: pubkey,\n    modeInfo: ModeInfo.fromPartial({\n      single: ModeInfo_Single.fromPartial({\n        mode,\n      }),\n    }),\n    sequence,\n  });\n\n  return signerInfo;\n}\n"],"names":["APIRequester","baseURL","axios","Axios","create","headers","Accept","timeout","get","endpoint","params","then","d","toCamelCase","data","post","obj","rtn","Array","map","key","hasOwnProperty","newKey","replace","k","toUpperCase","BaseAPI","request","AuthAPI","accounts","accountAddress","AuthzAPI","grants","granter","grantee","msgTypeUrl","msg_type_url","BankAPI","allBalances","balance","denom","totalSupply","supplyOf","DeflationAPI","allRepurchase","getRepurchase","GovAPI","proposals","proposal","proposalId","deposits","deposit","depositor","votes","vote","voter","tallyResult","paramsType","MintAPI","inflation","annualProvisions","PoolIncentiveAPI","allLiquidityPoolReward","getLiquidityPoolReward","address","allLiquidityRewardConfig","getLiquidityRewardConfig","id","allLiquidityRewardDenomR","getLiquidityRewardDenom","allRandSwapAccountReward","getRandSwapAccountReward","account","allRandSwapPoolReward","getRandSwapPoolReward","allRandSwapRewardConfig","getRandSwapRewardConfig","allRandSwapRewardDenom","getRandSwapRewardDenom","allRandSwapRewardReveal","getRandSwapRewardReveal","configId","round","SlashingAPI","signingInfos","signingInfo","valConsAddress","StakingAPI","delegations","delegator","redelegations","unbondingDelegations","delegatorDelegations","validator","delegationsByDelegator","delegationsByDelegatorValidator","validators","validatorsByValidator","validatorsDelegationsByValidator","validatorsDelegationsByValidatorDelegator","validatorsUnbondingDelegationsByValidatorDelegator","validatorsUnbondingDelegations","pool","SwapAPI","allCorePool","getCorePool","liquidityPositionByIds","tokenIds","qs","stringify","indices","liquidityPositionById","tokenId","getLiquidityPositionTokenUri","allLiquidityPositionOwner","skip_zero_liquidity","allPoolFee","getPoolFee","fee","allPoolObservation","allPoolPosition","owner","poolSlot0Aggregation","addresses","allPoolSlot0","allPoolTick","allPool","getPool","getPoolObservation","index","getPoolPosition","tickLower","tickUpper","getPoolSlot0","quoteSwapExactIn","quoteSwapExactOut","TendermintAPI","blockInfo","height","url","undefined","nodeInfo","syncing","validatorSet","TokenAPI","allMetadata","getMetadata","allOwnershipConfirmation","getOwnershipConfirmation","TxAPI","simulate","broadcast","tx","txBlock","txInfo","txHash","search","options","WasmAPI","codes","code","codeID","contractsByCode","contractInfo","contractAddress","to32","value","arr","split","len","length","result","forEach","item","push","i","unshift","deepCopy","source","JSON","parse","encrypt","prefix","suffix","substr","ONE_DAY_TO_SECONDS","ONE_YEAR_TO_DAYS","Fee_Amount","FEE_AMOUNT_DETAIL","LOWEST","label","description","LOW","MEDIUM","HIGH","Chain_Id","CHAIN_NAMES","Mainnet","Testnet","Devnet","NETWORK_DETAILS","chainId","chainName","nativeCurrency","base","name","symbol","display_exponent","logo_uri","nodeUrl","rpcUrl","blockExplorerUrl","ZERO","DEFAULT_USER_PRECISION","DEFAULT_PRECISION","MAX_PRECISION","REG_NUMBER","RegExp","REG_DECIMAL_SIMPLE","REG_DECIMAL","TICK_SPACINGS","BASE_UNIT_TICK","toDecimalPlaces","precision","Decimal","ROUND_UP","toString","e","String","toAmountString","roundingMode","ROUND_DOWN","toSignificantDigits","toAmountFloor","toAmountCeil","toAmountFee","isEmptyAmount","_value","mul","Math","pow","floor","isZero","toExactAmount","CosmosDecimal","fromUserInput","formatNumber","seperator","fixed","div","toFixed","moment","locale","formatMoment","pattern","format","formatUnixMoment","formatTime","time","formatDiffTime","fromNow","toUsd","getPoolAddress","denom0","denom1","Bech32","encode","sha256","toUtf8","slice","getPercentByFeeAmount","isNumeric","isNaN","parseFloat","checkInputNumber","test","plus","value1","value2","minus","multipliedBy","isGreaterThan","greaterThanOrEqualTo","isLessThan","lessThan","isEqualTo","equals","pow18","ceil","powM18","shift","isPositive","greaterThan","objectToMap","Map","Object","entries","arrayToMap","array","property","set","sortsBefore","baseToken","quoteToken","toLowerCase","toPercent","hundred","decimalNumber","number","int","float","Number","Transaction_Status","longToNumber","long","gt","MAX_SAFE_INTEGER","globalThis","Error","toNumber","Tip_Level","Direction","LiquidityMath","getRightSideLiquidity","leftRangeValue","rightRangeValue","priceValue","amount","numerator","_value1","sqrt","_value2","denominator","sub","getLeftSideLiquidity","getLiquidityFromAmount0","amount0","pc","deltaX","_getDiverForDeltaX","lower","upper","_getDiverForDeltaY","getLiquidityFromAmount1","amount1","deltaY","getAmount1FromAmount0","token0","liquidity","getAmount0FromAmount1","token1","getAmountByLiquidity","deltaXDiver","deltaYDiver","TickMath","priceToClosestTick","price","log2","getNearestTickByPrice","feeAmount","trim","INVALID_TICK","MIN_TICK_VALUE","MIN_TICK","MAX_TICK_VALUE","MAX_TICK","tick","nearestUsableTick","getFormattedPriceByTick","isLowestTick","isHighestTick","getPriceByTick","getNearestPriceByInput","nearestTick","getPriceBySqrtPrice","sqrtPrice","getSqrtPriceByPrice","getBaseTickRange","fromToken","toToken","leftRange","rightRange","getNearestLowestTick","getNearestHighestTick","getNearestPricesByFullTick","lowestPrice","highestPrice","highestTick","lowestTick","tickSpacing","rounded","TransactionLooper","status","onTransactionSuccess","transactionHash","counter","APIClient","URL","apiRequester","authAPI","authzAPI","bankAPI","deflationAPI","govAPI","mintAPI","poolIncentiveAPI","slashingAPI","stakingAPI","swapAPI","tendermintAPI","tokenAPI","txAPI","wasmAPI","BaseMsg","createBaseAny","typeUrl","Uint8Array","Any","message","writer","_m0","uint32","string","bytes","decode","input","reader","end","pos","tag","skipType","fromJSON","object","isSet","bytesFromBase64","toJSON","base64FromBytes","fromPartial","self","window","global","atob","b64","Buffer","from","bin","charCodeAt","btoa","byte","fromCharCode","join","Long","createBaseTimestamp","seconds","nanos","Timestamp","int64","int32","fromValue","createBaseGrant","authorization","expiration","Grant","fork","ldelim","toTimestamp","fromTimestamp","fromJsonTimestamp","toISOString","date","numberToLong","getTime","t","millis","Date","o","fromNumber","protobufPackage","createBaseMsgGrant","grant","MsgGrant","createBaseMsgExec","msgs","MsgExec","v","isArray","createBaseMsgRevoke","MsgRevoke","msg","protoMsg","generateMessage","MsgGrant_pb","MsgExec_pb","MsgRevoke_pb","createBaseCoin","Coin","createBaseInput","coins","Input","createBaseOutput","Output","createBaseMsgSend","fromAddress","toAddress","MsgSend","createBaseMsgMultiSend","inputs","outputs","MsgMultiSend","MsgSend_pb","MsgMultiSend_pb","createBaseMsgVerifyInvariant","sender","invariantModuleName","invariantRoute","MsgVerifyInvariant","MsgVerifyInvariant_pb","createBaseMsgSetWithdrawAddress","delegatorAddress","withdrawAddress","MsgSetWithdrawAddress","createBaseMsgWithdrawDelegatorReward","validatorAddress","MsgWithdrawDelegatorReward","createBaseMsgWithdrawValidatorCommission","MsgWithdrawValidatorCommission","createBaseMsgFundCommunityPool","MsgFundCommunityPool","MsgFundCommunityPool_pb","MsgSetWithdrawAddress_pb","MsgWithdrawDelegatorReward_pb","MsgWithdrawValidatorCommission_pb","createBaseMsgSubmitEvidence","submitter","evidence","MsgSubmitEvidence","MsgSubmitEvidence_pb","createBaseMsgGrantAllowance","allowance","MsgGrantAllowance","createBaseMsgRevokeAllowance","MsgRevokeAllowance","MsgGrantAllowance_pb","MsgRevokeAllowance_pb","createBaseDuration","Duration","VoteOption","voteOptionFromJSON","VOTE_OPTION_UNSPECIFIED","VOTE_OPTION_YES","VOTE_OPTION_ABSTAIN","VOTE_OPTION_NO","VOTE_OPTION_NO_WITH_VETO","UNRECOGNIZED","voteOptionToJSON","ProposalStatus","createBaseWeightedVoteOption","option","weight","WeightedVoteOption","createBaseMsgSubmitProposal","content","initialDeposit","proposer","MsgSubmitProposal","createBaseMsgVote","UZERO","MsgVote","uint64","createBaseMsgVoteWeighted","MsgVoteWeighted","createBaseMsgDeposit","MsgDeposit","MsgSubmitProposal_pb","MsgDeposit_pb","MsgVote_pb","MsgVoteWeighted_pb","createBaseMsgCreateVestingAccount","endTime","delayed","MsgCreateVestingAccount","bool","Boolean","MsgCreateVestingAccount_pb","createBaseRepurchase","sellMinAmount","sellMaxAmount","denoms","fees","Repurchase","end2","createBaseMsgGovRepurchase","creator","repurchase","MsgGovRepurchase","MsgGovRepurchase_pb","createBaseMsgEthereumTx","size","hash","MsgEthereumTx","MsgEthereumTx_pb","classId","receiver","MsgSendNft","createBaseRandSwapRewardSubConfig","title","numberOfReveal","RandSwapRewardSubConfig","createBaseRandSwapRewardConfig","enabled","intervalPeriod","mintable","decimal","totalReward","subConfigs","pools","RandSwapRewardConfig","createBaseLiquidityRewardSubConfig","LiquidityRewardSubConfig","createBaseLiquidityRewardConfig","totalRewardPerDay","LiquidityRewardConfig","createBaseMsgCreateRandSwapRewardConfig","config","MsgCreateRandSwapRewardConfig","createBaseMsgOpenRandSwapReward","MsgOpenRandSwapReward","createBaseMsgCloseRandSwapReward","MsgCloseRandSwapReward","createBaseMsgUpdateRandSwapRewardConfig","MsgUpdateRandSwapRewardConfig","createBaseMsgCollectRandSwapReward","recipient","MsgCollectRandSwapReward","createBaseMsgCreateLiquidityRewardConfig","MsgCreateLiquidityRewardConfig","createBaseMsgUpdateLiquidityRewardConfig","MsgUpdateLiquidityRewardConfig","createBaseMsgOpenLiquidityReward","MsgOpenLiquidityReward","createBaseMsgCloseLiquidityReward","MsgCloseLiquidityReward","MsgCreateRandSwapRewardConfig_pb","MsgCollectRandSwapReward_pb","MsgOpenRandSwapReward_pb","MsgCloseRandSwapReward_pb","MsgUpdateRandSwapRewardConfig_pb","MsgCreateLiquidityRewardConfig_pb","MsgUpdateLiquidityRewardConfig_pb","MsgOpenLiquidityReward_pb","MsgCloseLiquidityReward_pb","BlockIDFlag","SignedMsgType","BondStatus","createBaseCommissionRates","rate","maxRate","maxChangeRate","CommissionRates","createBaseDescription","moniker","identity","website","securityContact","details","Description","createBaseMsgCreateValidator","commission","minSelfDelegation","pubkey","MsgCreateValidator","createBaseMsgEditValidator","commissionRate","MsgEditValidator","createBaseMsgDelegate","MsgDelegate","createBaseMsgBeginRedelegate","validatorSrcAddress","validatorDstAddress","MsgBeginRedelegate","createBaseMsgUndelegate","MsgUndelegate","MsgCreateValidator_pb","MsgEditValidator_pb","MsgDelegate_pb","MsgBeginRedelegate_pb","MsgUndelegate_pb","createBaseMsgCreatePool","MsgCreatePool","createBaseMsgCreatePosition","amount0Desired","amount1Desired","amount0Min","amount1Min","deadline","MsgCreatePosition","createBaseMsgIncreaseLiquidity","MsgIncreaseLiquidity","createBaseMsgDecreaseLiquidity","MsgDecreaseLiquidity","createBaseMsgCollect","amount0Max","amount1Max","collectOnly","MsgCollect","createBaseMsgSwapExactIn","amountIn","amountOutMin","MsgSwapExactIn","createBaseMsgSwapExactOut","amountOut","amountInMax","MsgSwapExactOut","createBaseMsgCollectReward","MsgCollectReward","createBaseMsgCollectFeeProtocol","MsgCollectFeeProtocol","createBaseMsgGovCorePool","action","triggerTime","MsgGovCorePool","MsgCollectReward_pb","MsgSwapExactOut_pb","MsgSwapExactIn_pb","MsgCreatePool_pb","MsgCollect_pb","MsgCreatePosition_pb","MsgDecreaseLiquidity_pb","MsgIncreaseLiquidity_pb","MsgCollectFeeProtocol_pb","MsgGovCorePool_pb","createBaseMsgIssue","decimals","initialSupply","maxSupply","MsgIssue","createBaseMsgMint","MsgMint","createBaseMsgBurn","MsgBurn","createBaseMsgTransferOwnership","MsgTransferOwnership","createBaseMsgConfirmOwnership","MsgConfirmOwnership","MsgIssue_pb","MsgMint_pb","MsgBurn_pb","MsgTransferOwnership_pb","MsgConfirmOwnership_pb","AccessType","accessTypeFromJSON","ACCESS_TYPE_UNSPECIFIED","ACCESS_TYPE_NOBODY","ACCESS_TYPE_ONLY_ADDRESS","ACCESS_TYPE_EVERYBODY","accessTypeToJSON","ContractCodeHistoryOperationType","createBaseAccessConfig","permission","AccessConfig","createBaseMsgStoreCode","wasmByteCode","instantiatePermission","MsgStoreCode","MsgStoreCode_pb","createBasePubKey","PubKey","createBaseCompactBitArray","extraBitsStored","elems","CompactBitArray","SignMode","signModeFromJSON","SIGN_MODE_UNSPECIFIED","SIGN_MODE_DIRECT","SIGN_MODE_TEXTUAL","SIGN_MODE_LEGACY_AMINO_JSON","SIGN_MODE_EIP_191","signModeToJSON","createBaseTxRaw","bodyBytes","authInfoBytes","signatures","TxRaw","createBaseSignDoc","accountNumber","SignDoc","createBaseAuthInfo","signerInfos","AuthInfo","SignerInfo","Fee","createBaseSignerInfo","publicKey","modeInfo","sequence","ModeInfo","createBaseModeInfo","single","multi","ModeInfo_Single","ModeInfo_Multi","createBaseModeInfo_Single","mode","createBaseModeInfo_Multi","bitarray","modeInfos","createBaseFee","gasLimit","payer","SIGN_DIRECT","TxClient","apiClient","signer","registry","invariant","registryTypes","Proto","Registry","getSender","base_account","account_number","getAccounts","parseInt","sendTransaction","messages","memo","signInfoDirect","createSignerInfo","feeMessage","createFee","authInfoDirect","createAuthInfo","_messages","body","createTxBodyEncodeObject","signDocDirect","createSigDoc","finish","SigningStargateClient","connectWithSigner","walletClient","signDirect","signed","signature","txRaw","fromBase64","txBytes","broadcastTx","getEstimatedFee","console","log","gasInfo","gasUsed","results","signerInfo"],"mappings":"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"}